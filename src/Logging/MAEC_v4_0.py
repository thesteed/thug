#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Jan 24 12:20:09 2014 by generateDS.py version 2.12a.
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class BehaviorType(GeneratedsSuper):
    """The BehaviorType is one of the foundational MAEC types, and serves
    as a method for the characterization of malicious behaviors
    found or observed in malware. Behaviors can be thought of as
    representing the purpose behind groups of MAEC Actions, and are
    therefore representative of distinct portions of higher-level
    malware functionality. Thus, while a malware instance may
    perform some multitude of Actions, it is likely that these
    Actions represent only a few distinct behaviors. Some examples
    include vulnerability exploitation, email address harvesting,
    the disabling of a security service, etc.The required id field
    specifies a unique ID for this Behavior. The ID must follow the
    pattern defined in the BehaviorIDPattern simple type.The
    ordinal_position field specifies the ordinal position of the
    Behavior with respect to the execution of the malware.The status
    field specifies the execution status of the Behavior being
    characterized.The duration field specifies the duration of the
    Behavior. One way to derive such a value may be to calculate the
    difference between the timestamps of the first and last actions
    that compose the behavior."""
    subclass = None
    superclass = None
    def __init__(self, status=None, duration=None, ordinal_position=None, id=None, Purpose=None, Description=None, Discovery_Method=None, Action_Composition=None, Associated_Code=None, Relationships=None):
        self.status = _cast(None, status)
        self.duration = _cast(None, duration)
        self.ordinal_position = _cast(int, ordinal_position)
        self.id = _cast(None, id)
        self.Purpose = Purpose
        self.Description = Description
        self.Discovery_Method = Discovery_Method
        self.Action_Composition = Action_Composition
        self.Associated_Code = Associated_Code
        self.Relationships = Relationships
    def factory(*args_, **kwargs_):
        if BehaviorType.subclass:
            return BehaviorType.subclass(*args_, **kwargs_)
        else:
            return BehaviorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Discovery_Method(self): return self.Discovery_Method
    def set_Discovery_Method(self, Discovery_Method): self.Discovery_Method = Discovery_Method
    def get_Action_Composition(self): return self.Action_Composition
    def set_Action_Composition(self, Action_Composition): self.Action_Composition = Action_Composition
    def get_Associated_Code(self): return self.Associated_Code
    def set_Associated_Code(self, Associated_Code): self.Associated_Code = Associated_Code
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_ordinal_position(self): return self.ordinal_position
    def set_ordinal_position(self, ordinal_position): self.ordinal_position = ordinal_position
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Purpose is not None or
            self.Description is not None or
            self.Discovery_Method is not None or
            self.Action_Composition is not None or
            self.Associated_Code is not None or
            self.Relationships is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorType'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_format_string(quote_attrib(self.duration).encode(ExternalEncoding), input_name='duration'), ))
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            outfile.write(' ordinal_position="%s"' % self.gds_format_integer(self.ordinal_position, input_name='ordinal_position'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Purpose is not None:
            self.Purpose.export(outfile, level, namespace_, name_='Purpose', pretty_print=pretty_print)
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Discovery_Method is not None:
            self.Discovery_Method.export(outfile, level, namespace_, name_='Discovery_Method', pretty_print=pretty_print)
        if self.Action_Composition is not None:
            self.Action_Composition.export(outfile, level, namespace_, name_='Action_Composition', pretty_print=pretty_print)
        if self.Associated_Code is not None:
            self.Associated_Code.export(outfile, level, namespace_, name_='Associated_Code', pretty_print=pretty_print)
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, namespace_, name_='Relationships', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehaviorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % (self.status,))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            showIndent(outfile, level)
            outfile.write('duration="%s",\n' % (self.duration,))
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            showIndent(outfile, level)
            outfile.write('ordinal_position=%d,\n' % (self.ordinal_position,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Purpose is not None:
            showIndent(outfile, level)
            outfile.write('Purpose=model_.BehaviorPurposeType(\n')
            self.Purpose.exportLiteral(outfile, level, name_='Purpose')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('Discovery_Method=model_.MeasureSourceType(\n')
            self.Discovery_Method.exportLiteral(outfile, level, name_='Discovery_Method')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Composition is not None:
            showIndent(outfile, level)
            outfile.write('Action_Composition=model_.BehavioralActionsType(\n')
            self.Action_Composition.exportLiteral(outfile, level, name_='Action_Composition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Associated_Code is not None:
            showIndent(outfile, level)
            outfile.write('Associated_Code=model_.AssociatedCodeType(\n')
            self.Associated_Code.exportLiteral(outfile, level, name_='Associated_Code')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.BehaviorRelationshipListType(\n')
            self.Relationships.exportLiteral(outfile, level, name_='Relationships')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('ordinal_position', node)
        if value is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            try:
                self.ordinal_position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ordinal_position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Purpose':
            obj_ = BehaviorPurposeType.factory()
            obj_.build(child_)
            self.Purpose = obj_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Discovery_Method':
            obj_ = MeasureSourceType.factory()
            obj_.build(child_)
            self.Discovery_Method = obj_
        elif nodeName_ == 'Action_Composition':
            obj_ = BehavioralActionsType.factory()
            obj_.build(child_)
            self.Action_Composition = obj_
        elif nodeName_ == 'Associated_Code':
            obj_ = AssociatedCodeType.factory()
            obj_.build(child_)
            self.Associated_Code = obj_
        elif nodeName_ == 'Relationships':
            obj_ = BehaviorRelationshipListType.factory()
            obj_.build(child_)
            self.Relationships = obj_
# end class BehaviorType


class BundleType(GeneratedsSuper):
    """The BundleType serves as the high-level construct which encapsulates
    all Bundle elements, and represents some characterized analysis
    data (from any arbitrary set of analyses) for a single malware
    instance in terms of its MAEC Components (e.g., Behaviors,
    Actions, Objects, etc.).The required id field specifies a unique
    ID for this MAEC Bundle. The ID must follow the pattern defined
    in the BundleIDPattern simple type.The required schema_version
    field specifies the version of the MAEC Bundle Schema that the
    document has been written in and that should be used for
    validation.The required defined_subject field specifies whether
    the subject attributes of the malware instance characterized
    here are included inside this Bundle (via the top-level
    Malware_Instance_Object_Attributes element) or elsewhere (such
    as a MAEC Subject in a MAEC Package).The content_type field
    specifies the general type of content contained in this Bundle,
    e.g. static analysis tool output, dynamic analysis tool output,
    etc.The timestamp field specifies the date/time that the bundle
    was generated."""
    subclass = None
    superclass = None
    def __init__(self, defined_subject=None, content_type=None, id=None, schema_version=None, timestamp=None, Malware_Instance_Object_Attributes=None, AV_Classifications=None, Process_Tree=None, Behaviors=None, Actions=None, Objects=None, Candidate_Indicators=None, Collections=None):
        self.defined_subject = _cast(bool, defined_subject)
        self.content_type = _cast(None, content_type)
        self.id = _cast(None, id)
        self.schema_version = _cast(float, schema_version)
        if isinstance(timestamp, basestring):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.Malware_Instance_Object_Attributes = Malware_Instance_Object_Attributes
        self.AV_Classifications = AV_Classifications
        self.Process_Tree = Process_Tree
        self.Behaviors = Behaviors
        self.Actions = Actions
        self.Objects = Objects
        self.Candidate_Indicators = Candidate_Indicators
        self.Collections = Collections
    def factory(*args_, **kwargs_):
        if BundleType.subclass:
            return BundleType.subclass(*args_, **kwargs_)
        else:
            return BundleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Malware_Instance_Object_Attributes(self): return self.Malware_Instance_Object_Attributes
    def set_Malware_Instance_Object_Attributes(self, Malware_Instance_Object_Attributes): self.Malware_Instance_Object_Attributes = Malware_Instance_Object_Attributes
    def get_AV_Classifications(self): return self.AV_Classifications
    def set_AV_Classifications(self, AV_Classifications): self.AV_Classifications = AV_Classifications
    def get_Process_Tree(self): return self.Process_Tree
    def set_Process_Tree(self, Process_Tree): self.Process_Tree = Process_Tree
    def get_Behaviors(self): return self.Behaviors
    def set_Behaviors(self, Behaviors): self.Behaviors = Behaviors
    def get_Actions(self): return self.Actions
    def set_Actions(self, Actions): self.Actions = Actions
    def get_Objects(self): return self.Objects
    def set_Objects(self, Objects): self.Objects = Objects
    def get_Candidate_Indicators(self): return self.Candidate_Indicators
    def set_Candidate_Indicators(self, Candidate_Indicators): self.Candidate_Indicators = Candidate_Indicators
    def get_Collections(self): return self.Collections
    def set_Collections(self, Collections): self.Collections = Collections
    def get_defined_subject(self): return self.defined_subject
    def set_defined_subject(self, defined_subject): self.defined_subject = defined_subject
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_schema_version(self): return self.schema_version
    def set_schema_version(self, schema_version): self.schema_version = schema_version
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def hasContent_(self):
        if (
            self.Malware_Instance_Object_Attributes is not None or
            self.AV_Classifications is not None or
            self.Process_Tree is not None or
            self.Behaviors is not None or
            self.Actions is not None or
            self.Objects is not None or
            self.Candidate_Indicators is not None or
            self.Collections is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BundleType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BundleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BundleType'):
        if self.defined_subject is not None and 'defined_subject' not in already_processed:
            already_processed.add('defined_subject')
            outfile.write(' defined_subject="%s"' % self.gds_format_boolean(self.defined_subject, input_name='defined_subject'))
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            outfile.write(' content_type=%s' % (quote_attrib(self.content_type), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.schema_version is not None and 'schema_version' not in already_processed:
            already_processed.add('schema_version')
            outfile.write(' schema_version="%s"' % self.gds_format_float(self.schema_version, input_name='schema_version'))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BundleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Malware_Instance_Object_Attributes is not None:
            self.Malware_Instance_Object_Attributes.export(outfile, level, namespace_, name_='Malware_Instance_Object_Attributes', pretty_print=pretty_print)
        if self.AV_Classifications is not None:
            self.AV_Classifications.export(outfile, level, namespace_, name_='AV_Classifications', pretty_print=pretty_print)
        if self.Process_Tree is not None:
            self.Process_Tree.export(outfile, level, namespace_, name_='Process_Tree', pretty_print=pretty_print)
        if self.Behaviors is not None:
            self.Behaviors.export(outfile, level, namespace_, name_='Behaviors', pretty_print=pretty_print)
        if self.Actions is not None:
            self.Actions.export(outfile, level, namespace_, name_='Actions', pretty_print=pretty_print)
        if self.Objects is not None:
            self.Objects.export(outfile, level, namespace_, name_='Objects', pretty_print=pretty_print)
        if self.Candidate_Indicators is not None:
            self.Candidate_Indicators.export(outfile, level, namespace_, name_='Candidate_Indicators', pretty_print=pretty_print)
        if self.Collections is not None:
            self.Collections.export(outfile, level, namespace_, name_='Collections', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BundleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.defined_subject is not None and 'defined_subject' not in already_processed:
            already_processed.add('defined_subject')
            showIndent(outfile, level)
            outfile.write('defined_subject=%s,\n' % (self.defined_subject,))
        if self.content_type is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            showIndent(outfile, level)
            outfile.write('content_type=%s,\n' % (self.content_type,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.schema_version is not None and 'schema_version' not in already_processed:
            already_processed.add('schema_version')
            showIndent(outfile, level)
            outfile.write('schema_version=%f,\n' % (self.schema_version,))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Malware_Instance_Object_Attributes is not None:
            showIndent(outfile, level)
            outfile.write('Malware_Instance_Object_Attributes=model_.ObjectType(\n')
            self.Malware_Instance_Object_Attributes.exportLiteral(outfile, level, name_='Malware_Instance_Object_Attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AV_Classifications is not None:
            showIndent(outfile, level)
            outfile.write('AV_Classifications=model_.AVClassificationsType(\n')
            self.AV_Classifications.exportLiteral(outfile, level, name_='AV_Classifications')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Process_Tree is not None:
            showIndent(outfile, level)
            outfile.write('Process_Tree=model_.ProcessTreeType(\n')
            self.Process_Tree.exportLiteral(outfile, level, name_='Process_Tree')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Behaviors is not None:
            showIndent(outfile, level)
            outfile.write('Behaviors=model_.BehaviorListType(\n')
            self.Behaviors.exportLiteral(outfile, level, name_='Behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Actions is not None:
            showIndent(outfile, level)
            outfile.write('Actions=model_.ActionListType(\n')
            self.Actions.exportLiteral(outfile, level, name_='Actions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Objects is not None:
            showIndent(outfile, level)
            outfile.write('Objects=model_.ObjectListType(\n')
            self.Objects.exportLiteral(outfile, level, name_='Objects')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Candidate_Indicators is not None:
            showIndent(outfile, level)
            outfile.write('Candidate_Indicators=model_.CandidateIndicatorListType(\n')
            self.Candidate_Indicators.exportLiteral(outfile, level, name_='Candidate_Indicators')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Collections is not None:
            showIndent(outfile, level)
            outfile.write('Collections=model_.CollectionsType(\n')
            self.Collections.exportLiteral(outfile, level, name_='Collections')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defined_subject', node)
        if value is not None and 'defined_subject' not in already_processed:
            already_processed.add('defined_subject')
            if value in ('true', '1'):
                self.defined_subject = True
            elif value in ('false', '0'):
                self.defined_subject = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('content_type', node)
        if value is not None and 'content_type' not in already_processed:
            already_processed.add('content_type')
            self.content_type = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('schema_version', node)
        if value is not None and 'schema_version' not in already_processed:
            already_processed.add('schema_version')
            try:
                self.schema_version = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (schema_version): %s' % exp)
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Malware_Instance_Object_Attributes':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Malware_Instance_Object_Attributes = obj_
        elif nodeName_ == 'AV_Classifications':
            obj_ = AVClassificationsType.factory()
            obj_.build(child_)
            self.AV_Classifications = obj_
        elif nodeName_ == 'Process_Tree':
            obj_ = ProcessTreeType.factory()
            obj_.build(child_)
            self.Process_Tree = obj_
        elif nodeName_ == 'Behaviors':
            obj_ = BehaviorListType.factory()
            obj_.build(child_)
            self.Behaviors = obj_
        elif nodeName_ == 'Actions':
            obj_ = ActionListType.factory()
            obj_.build(child_)
            self.Actions = obj_
        elif nodeName_ == 'Objects':
            obj_ = ObjectListType.factory()
            obj_.build(child_)
            self.Objects = obj_
        elif nodeName_ == 'Candidate_Indicators':
            obj_ = CandidateIndicatorListType.factory()
            obj_.build(child_)
            self.Candidate_Indicators = obj_
        elif nodeName_ == 'Collections':
            obj_ = CollectionsType.factory()
            obj_.build(child_)
            self.Collections = obj_
# end class BundleType


class APICallType(GeneratedsSuper):
    """The APICallType provides a method for the characterization of API
    calls, including functions and their parameters.The
    function_name field contains the exact name of the API function
    called, e.g. CreateFileEx.The normalized_function_name field
    contains the normalized name of the API function called, e.g.
    CreateFile."""
    subclass = None
    superclass = None
    def __init__(self, normalized_function_name=None, function_name=None, Address=None, Return_Value=None, Parameters=None):
        self.normalized_function_name = _cast(None, normalized_function_name)
        self.function_name = _cast(None, function_name)
        self.Address = Address
        self.Return_Value = Return_Value
        self.Parameters = Parameters
    def factory(*args_, **kwargs_):
        if APICallType.subclass:
            return APICallType.subclass(*args_, **kwargs_)
        else:
            return APICallType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Return_Value(self): return self.Return_Value
    def set_Return_Value(self, Return_Value): self.Return_Value = Return_Value
    def get_Parameters(self): return self.Parameters
    def set_Parameters(self, Parameters): self.Parameters = Parameters
    def get_normalized_function_name(self): return self.normalized_function_name
    def set_normalized_function_name(self, normalized_function_name): self.normalized_function_name = normalized_function_name
    def get_function_name(self): return self.function_name
    def set_function_name(self, function_name): self.function_name = function_name
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Return_Value is not None or
            self.Parameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='APICallType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APICallType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='APICallType'):
        if self.normalized_function_name is not None and 'normalized_function_name' not in already_processed:
            already_processed.add('normalized_function_name')
            outfile.write(' normalized_function_name=%s' % (self.gds_format_string(quote_attrib(self.normalized_function_name).encode(ExternalEncoding), input_name='normalized_function_name'), ))
        if self.function_name is not None and 'function_name' not in already_processed:
            already_processed.add('function_name')
            outfile.write(' function_name=%s' % (self.gds_format_string(quote_attrib(self.function_name).encode(ExternalEncoding), input_name='function_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='APICallType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddress>%s</%sAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.Address).encode(ExternalEncoding), input_name='Address'), namespace_, eol_))
        if self.Return_Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReturn_Value>%s</%sReturn_Value>%s' % (namespace_, self.gds_format_string(quote_xml(self.Return_Value).encode(ExternalEncoding), input_name='Return_Value'), namespace_, eol_))
        if self.Parameters is not None:
            self.Parameters.export(outfile, level, namespace_, name_='Parameters', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='APICallType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.normalized_function_name is not None and 'normalized_function_name' not in already_processed:
            already_processed.add('normalized_function_name')
            showIndent(outfile, level)
            outfile.write('normalized_function_name="%s",\n' % (self.normalized_function_name,))
        if self.function_name is not None and 'function_name' not in already_processed:
            already_processed.add('function_name')
            showIndent(outfile, level)
            outfile.write('function_name="%s",\n' % (self.function_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=%s,\n' % quote_python(self.Address).encode(ExternalEncoding))
        if self.Return_Value is not None:
            showIndent(outfile, level)
            outfile.write('Return_Value=%s,\n' % quote_python(self.Return_Value).encode(ExternalEncoding))
        if self.Parameters is not None:
            showIndent(outfile, level)
            outfile.write('Parameters=model_.ParameterListType(\n')
            self.Parameters.exportLiteral(outfile, level, name_='Parameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('normalized_function_name', node)
        if value is not None and 'normalized_function_name' not in already_processed:
            already_processed.add('normalized_function_name')
            self.normalized_function_name = value
        value = find_attr_value_('function_name', node)
        if value is not None and 'function_name' not in already_processed:
            already_processed.add('function_name')
            self.function_name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            Address_ = child_.text
            Address_ = self.gds_validate_string(Address_, node, 'Address')
            self.Address = Address_
        elif nodeName_ == 'Return_Value':
            Return_Value_ = child_.text
            Return_Value_ = self.gds_validate_string(Return_Value_, node, 'Return_Value')
            self.Return_Value = Return_Value_
        elif nodeName_ == 'Parameters':
            obj_ = ParameterListType.factory()
            obj_.build(child_)
            self.Parameters = obj_
# end class APICallType


class ActionImplementationType(GeneratedsSuper):
    """The ActionImplementationType serves as a method for the
    characterization of Action Implementations. Currently supported
    are implementations achieved through API function calls and
    abstractly defined code. The id field specifies a unique ID for
    this Action Implementation. The ID must follow the pattern
    defined in the ActionImpIDPattern simple type. The required type
    field refers to the type of Action Implementation being
    characterized in this element."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, Compatible_Platforms=None, API_Call=None, Code=None):
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.Compatible_Platforms = Compatible_Platforms
        self.API_Call = API_Call
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
    def factory(*args_, **kwargs_):
        if ActionImplementationType.subclass:
            return ActionImplementationType.subclass(*args_, **kwargs_)
        else:
            return ActionImplementationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Compatible_Platforms(self): return self.Compatible_Platforms
    def set_Compatible_Platforms(self, Compatible_Platforms): self.Compatible_Platforms = Compatible_Platforms
    def get_API_Call(self): return self.API_Call
    def set_API_Call(self, API_Call): self.API_Call = API_Call
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def add_Code(self, value): self.Code.append(value)
    def insert_Code(self, index, value): self.Code[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Compatible_Platforms is not None or
            self.API_Call is not None or
            self.Code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionImplementationType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:CodeObj="http://cybox.mitre.org/objects#CodeObject-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionImplementationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionImplementationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionImplementationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Compatible_Platforms is not None:
            self.Compatible_Platforms.export(outfile, level, namespace_, name_='Compatible_Platforms', pretty_print=pretty_print)
        if self.API_Call is not None:
            self.API_Call.export(outfile, level, namespace_, name_='API_Call', pretty_print=pretty_print)
        for Code_ in self.Code:
            Code_.export(outfile, level, namespace_, name_='Code', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionImplementationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Compatible_Platforms is not None:
            showIndent(outfile, level)
            outfile.write('Compatible_Platforms=model_.PlatformListType(\n')
            self.Compatible_Platforms.exportLiteral(outfile, level, name_='Compatible_Platforms')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.API_Call is not None:
            showIndent(outfile, level)
            outfile.write('API_Call=model_.APICallType(\n')
            self.API_Call.exportLiteral(outfile, level, name_='API_Call')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Code=[\n')
        level += 1
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('model_.CodeObjectType(\n')
            Code_.exportLiteral(outfile, level, name_='CodeObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Compatible_Platforms':
            obj_ = PlatformListType.factory()
            obj_.build(child_)
            self.Compatible_Platforms = obj_
        elif nodeName_ == 'API_Call':
            obj_ = APICallType.factory()
            obj_.build(child_)
            self.API_Call = obj_
        elif nodeName_ == 'Code':
            obj_ = CodeObjectType.factory()
            obj_.build(child_)
            self.Code.append(obj_)
# end class ActionImplementationType


class CVEVulnerabilityType(GeneratedsSuper):
    """The CVEVulnerabilityType provides a way of referencing specific
    vulnerabilities that malware exploits or attempts to exploit via
    a Common Vulnerabilities and Exposures (CVE) identifier. For
    more information on CVE please see http://cve.mitre.org. The
    cve_id attribute contains the ID of the CVE that is being
    referenced, e.g., CVE-1999-0002."""
    subclass = None
    superclass = None
    def __init__(self, cve_id=None, Description=None):
        self.cve_id = _cast(None, cve_id)
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CVEVulnerabilityType.subclass:
            return CVEVulnerabilityType.subclass(*args_, **kwargs_)
        else:
            return CVEVulnerabilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_cve_id(self): return self.cve_id
    def set_cve_id(self, cve_id): self.cve_id = cve_id
    def hasContent_(self):
        if (
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CVEVulnerabilityType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVEVulnerabilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CVEVulnerabilityType'):
        if self.cve_id is not None and 'cve_id' not in already_processed:
            already_processed.add('cve_id')
            outfile.write(' cve_id=%s' % (self.gds_format_string(quote_attrib(self.cve_id).encode(ExternalEncoding), input_name='cve_id'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CVEVulnerabilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CVEVulnerabilityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cve_id is not None and 'cve_id' not in already_processed:
            already_processed.add('cve_id')
            showIndent(outfile, level)
            outfile.write('cve_id="%s",\n' % (self.cve_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cve_id', node)
        if value is not None and 'cve_id' not in already_processed:
            already_processed.add('cve_id')
            self.cve_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CVEVulnerabilityType


class BaseCollectionType(GeneratedsSuper):
    """The BaseCollectionType is the base type for other MAEC collection
    types.The name field specifies the name of the collection."""
    subclass = None
    superclass = None
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, extensiontype_=None):
        self.name = _cast(None, name)
        self.Affinity_Type = Affinity_Type
        self.Affinity_Degree = Affinity_Degree
        self.Description = Description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if BaseCollectionType.subclass:
            return BaseCollectionType.subclass(*args_, **kwargs_)
        else:
            return BaseCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Affinity_Type(self): return self.Affinity_Type
    def set_Affinity_Type(self, Affinity_Type): self.Affinity_Type = Affinity_Type
    def get_Affinity_Degree(self): return self.Affinity_Degree
    def set_Affinity_Degree(self, Affinity_Degree): self.Affinity_Degree = Affinity_Degree
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Affinity_Type is not None or
            self.Affinity_Degree is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BaseCollectionType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaseCollectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BaseCollectionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BaseCollectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Affinity_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAffinity_Type>%s</%sAffinity_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.Affinity_Type).encode(ExternalEncoding), input_name='Affinity_Type'), namespace_, eol_))
        if self.Affinity_Degree is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAffinity_Degree>%s</%sAffinity_Degree>%s' % (namespace_, self.gds_format_string(quote_xml(self.Affinity_Degree).encode(ExternalEncoding), input_name='Affinity_Degree'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='BaseCollectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Affinity_Type is not None:
            showIndent(outfile, level)
            outfile.write('Affinity_Type=%s,\n' % quote_python(self.Affinity_Type).encode(ExternalEncoding))
        if self.Affinity_Degree is not None:
            showIndent(outfile, level)
            outfile.write('Affinity_Degree=%s,\n' % quote_python(self.Affinity_Degree).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Affinity_Type':
            Affinity_Type_ = child_.text
            Affinity_Type_ = self.gds_validate_string(Affinity_Type_, node, 'Affinity_Type')
            self.Affinity_Type = Affinity_Type_
        elif nodeName_ == 'Affinity_Degree':
            Affinity_Degree_ = child_.text
            Affinity_Degree_ = self.gds_validate_string(Affinity_Degree_, node, 'Affinity_Degree')
            self.Affinity_Degree = Affinity_Degree_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class BaseCollectionType


class BehaviorRelationshipType(GeneratedsSuper):
    """The BehaviorRelationshipType provides a method for the
    characterization of relationships between Behaviors. The type
    field specifies the nature of the relationship between Behaviors
    that is being captured."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, Behavior_Reference=None):
        self.type_ = _cast(None, type_)
        if Behavior_Reference is None:
            self.Behavior_Reference = []
        else:
            self.Behavior_Reference = Behavior_Reference
    def factory(*args_, **kwargs_):
        if BehaviorRelationshipType.subclass:
            return BehaviorRelationshipType.subclass(*args_, **kwargs_)
        else:
            return BehaviorRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Reference(self): return self.Behavior_Reference
    def set_Behavior_Reference(self, Behavior_Reference): self.Behavior_Reference = Behavior_Reference
    def add_Behavior_Reference(self, value): self.Behavior_Reference.append(value)
    def insert_Behavior_Reference(self, index, value): self.Behavior_Reference[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Behavior_Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorRelationshipType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorRelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorRelationshipType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorRelationshipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Behavior_Reference_ in self.Behavior_Reference:
            Behavior_Reference_.export(outfile, level, namespace_, name_='Behavior_Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehaviorRelationshipType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior_Reference=[\n')
        level += 1
        for Behavior_Reference_ in self.Behavior_Reference:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorReferenceType(\n')
            Behavior_Reference_.exportLiteral(outfile, level, name_='BehaviorReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Reference':
            obj_ = BehaviorReferenceType.factory()
            obj_.build(child_)
            self.Behavior_Reference.append(obj_)
# end class BehaviorRelationshipType


class AVClassificationsType(GeneratedsSuper):
    """The AVClassificationsType captures any Anti-Virus (AV) tool
    classifications for an Object."""
    subclass = None
    superclass = None
    def __init__(self, AV_Classification=None):
        if AV_Classification is None:
            self.AV_Classification = []
        else:
            self.AV_Classification = AV_Classification
    def factory(*args_, **kwargs_):
        if AVClassificationsType.subclass:
            return AVClassificationsType.subclass(*args_, **kwargs_)
        else:
            return AVClassificationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AV_Classification(self): return self.AV_Classification
    def set_AV_Classification(self, AV_Classification): self.AV_Classification = AV_Classification
    def add_AV_Classification(self, value): self.AV_Classification.append(value)
    def insert_AV_Classification(self, index, value): self.AV_Classification[index] = value
    def hasContent_(self):
        if (
            self.AV_Classification
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='AVClassificationsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AVClassificationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='AVClassificationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='AVClassificationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AV_Classification_ in self.AV_Classification:
            AV_Classification_.export(outfile, level, namespace_, name_='AV_Classification', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AVClassificationsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AV_Classification=[\n')
        level += 1
        for AV_Classification_ in self.AV_Classification:
            showIndent(outfile, level)
            outfile.write('model_.AVClassificationType(\n')
            AV_Classification_.exportLiteral(outfile, level, name_='AVClassificationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AV_Classification':
            obj_ = AVClassificationType.factory()
            obj_.build(child_)
            self.AV_Classification.append(obj_)
# end class AVClassificationsType


class ParameterType(GeneratedsSuper):
    """The ParameterType characterizes function parameters.This field
    refers to the ordinal position of the parameter with respect to
    the function where it is used.The name field specifies the name
    of the parameter.The value field specifies the actual value of
    the parameter."""
    subclass = None
    superclass = None
    def __init__(self, ordinal_position=None, name=None, value=None):
        self.ordinal_position = _cast(int, ordinal_position)
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if ParameterType.subclass:
            return ParameterType.subclass(*args_, **kwargs_)
        else:
            return ParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ordinal_position(self): return self.ordinal_position
    def set_ordinal_position(self, ordinal_position): self.ordinal_position = ordinal_position
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ParameterType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ParameterType'):
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            outfile.write(' ordinal_position="%s"' % self.gds_format_integer(self.ordinal_position, input_name='ordinal_position'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ParameterType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ParameterType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            showIndent(outfile, level)
            outfile.write('ordinal_position=%d,\n' % (self.ordinal_position,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ordinal_position', node)
        if value is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            try:
                self.ordinal_position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ordinal_position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParameterType


class ParameterListType(GeneratedsSuper):
    """The ParametersType captures a list of function parameters."""
    subclass = None
    superclass = None
    def __init__(self, Parameter=None):
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
    def factory(*args_, **kwargs_):
        if ParameterListType.subclass:
            return ParameterListType.subclass(*args_, **kwargs_)
        else:
            return ParameterListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter(self, index, value): self.Parameter[index] = value
    def hasContent_(self):
        if (
            self.Parameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ParameterListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ParameterListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ParameterListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ParameterListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.ParameterType(\n')
            Parameter_.exportLiteral(outfile, level, name_='ParameterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Parameter':
            obj_ = ParameterType.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
# end class ParameterListType


class AssociatedCodeType(GeneratedsSuper):
    """The AssociatedCodeType serves as generic way of specifying any code
    snippets associated with a MAEC entity, such as a Behavior."""
    subclass = None
    superclass = None
    def __init__(self, Code_Snippet=None):
        if Code_Snippet is None:
            self.Code_Snippet = []
        else:
            self.Code_Snippet = Code_Snippet
    def factory(*args_, **kwargs_):
        if AssociatedCodeType.subclass:
            return AssociatedCodeType.subclass(*args_, **kwargs_)
        else:
            return AssociatedCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code_Snippet(self): return self.Code_Snippet
    def set_Code_Snippet(self, Code_Snippet): self.Code_Snippet = Code_Snippet
    def add_Code_Snippet(self, value): self.Code_Snippet.append(value)
    def insert_Code_Snippet(self, index, value): self.Code_Snippet[index] = value
    def hasContent_(self):
        if (
            self.Code_Snippet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='AssociatedCodeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:CodeObj="http://cybox.mitre.org/objects#CodeObject-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedCodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='AssociatedCodeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='AssociatedCodeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Code_Snippet_ in self.Code_Snippet:
            Code_Snippet_.export(outfile, level, namespace_, name_='Code_Snippet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AssociatedCodeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Code_Snippet=[\n')
        level += 1
        for Code_Snippet_ in self.Code_Snippet:
            showIndent(outfile, level)
            outfile.write('model_.CodeObjectType(\n')
            Code_Snippet_.exportLiteral(outfile, level, name_='CodeObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code_Snippet':
            obj_ = CodeObjectType.factory()
            obj_.build(child_)
            self.Code_Snippet.append(obj_)
# end class AssociatedCodeType


class BehaviorPurposeType(GeneratedsSuper):
    """The BehaviorPurposeType captures the purpose behind a malware
    Behavior."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Vulnerability_Exploit=None):
        self.Description = Description
        self.Vulnerability_Exploit = Vulnerability_Exploit
    def factory(*args_, **kwargs_):
        if BehaviorPurposeType.subclass:
            return BehaviorPurposeType.subclass(*args_, **kwargs_)
        else:
            return BehaviorPurposeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Vulnerability_Exploit(self): return self.Vulnerability_Exploit
    def set_Vulnerability_Exploit(self, Vulnerability_Exploit): self.Vulnerability_Exploit = Vulnerability_Exploit
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Vulnerability_Exploit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorPurposeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorPurposeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorPurposeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorPurposeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Vulnerability_Exploit is not None:
            self.Vulnerability_Exploit.export(outfile, level, namespace_, name_='Vulnerability_Exploit', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehaviorPurposeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Vulnerability_Exploit is not None:
            showIndent(outfile, level)
            outfile.write('Vulnerability_Exploit=model_.VulnerabilityExploitType(\n')
            self.Vulnerability_Exploit.exportLiteral(outfile, level, name_='Vulnerability_Exploit')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Vulnerability_Exploit':
            obj_ = VulnerabilityExploitType.factory()
            obj_.build(child_)
            self.Vulnerability_Exploit = obj_
# end class BehaviorPurposeType


class PlatformListType(GeneratedsSuper):
    """The PlatformListType captures a list of software or hardware
    platforms."""
    subclass = None
    superclass = None
    def __init__(self, Platform=None):
        if Platform is None:
            self.Platform = []
        else:
            self.Platform = Platform
    def factory(*args_, **kwargs_):
        if PlatformListType.subclass:
            return PlatformListType.subclass(*args_, **kwargs_)
        else:
            return PlatformListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Platform(self): return self.Platform
    def set_Platform(self, Platform): self.Platform = Platform
    def add_Platform(self, value): self.Platform.append(value)
    def insert_Platform(self, index, value): self.Platform[index] = value
    def hasContent_(self):
        if (
            self.Platform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PlatformListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PlatformListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PlatformListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Platform_ in self.Platform:
            Platform_.export(outfile, level, namespace_, name_='Platform', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Platform=[\n')
        level += 1
        for Platform_ in self.Platform:
            showIndent(outfile, level)
            outfile.write('model_.PlatformSpecificationType(\n')
            Platform_.exportLiteral(outfile, level, name_='PlatformSpecificationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Platform':
            obj_ = PlatformSpecificationType.factory()
            obj_.build(child_)
            self.Platform.append(obj_)
# end class PlatformListType


class VulnerabilityExploitType(GeneratedsSuper):
    """The VulnerabilityExploitType characterizes any vulnerability that
    may be exploited by malware through a Behavior.The
    known_vulnerability field specifies whether the vulnerability
    that the malware is exploiting has been previously identified.
    If so, it should be referenced via a CVE ID in the CVE element.
    If not, the platform(s) targeted by the vulnerability
    exploitation behavior may be specified in the Targeted_Platforms
    element."""
    subclass = None
    superclass = None
    def __init__(self, known_vulnerability=None, CVE=None, Targeted_Platforms=None):
        self.known_vulnerability = _cast(bool, known_vulnerability)
        self.CVE = CVE
        self.Targeted_Platforms = Targeted_Platforms
    def factory(*args_, **kwargs_):
        if VulnerabilityExploitType.subclass:
            return VulnerabilityExploitType.subclass(*args_, **kwargs_)
        else:
            return VulnerabilityExploitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CVE(self): return self.CVE
    def set_CVE(self, CVE): self.CVE = CVE
    def get_Targeted_Platforms(self): return self.Targeted_Platforms
    def set_Targeted_Platforms(self, Targeted_Platforms): self.Targeted_Platforms = Targeted_Platforms
    def get_known_vulnerability(self): return self.known_vulnerability
    def set_known_vulnerability(self, known_vulnerability): self.known_vulnerability = known_vulnerability
    def hasContent_(self):
        if (
            self.CVE is not None or
            self.Targeted_Platforms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='VulnerabilityExploitType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VulnerabilityExploitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='VulnerabilityExploitType'):
        if self.known_vulnerability is not None and 'known_vulnerability' not in already_processed:
            already_processed.add('known_vulnerability')
            outfile.write(' known_vulnerability="%s"' % self.gds_format_boolean(self.known_vulnerability, input_name='known_vulnerability'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='VulnerabilityExploitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CVE is not None:
            self.CVE.export(outfile, level, namespace_, name_='CVE', pretty_print=pretty_print)
        if self.Targeted_Platforms is not None:
            self.Targeted_Platforms.export(outfile, level, namespace_, name_='Targeted_Platforms', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VulnerabilityExploitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.known_vulnerability is not None and 'known_vulnerability' not in already_processed:
            already_processed.add('known_vulnerability')
            showIndent(outfile, level)
            outfile.write('known_vulnerability=%s,\n' % (self.known_vulnerability,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CVE is not None:
            showIndent(outfile, level)
            outfile.write('CVE=model_.CVEVulnerabilityType(\n')
            self.CVE.exportLiteral(outfile, level, name_='CVE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targeted_Platforms is not None:
            showIndent(outfile, level)
            outfile.write('Targeted_Platforms=model_.PlatformListType(\n')
            self.Targeted_Platforms.exportLiteral(outfile, level, name_='Targeted_Platforms')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('known_vulnerability', node)
        if value is not None and 'known_vulnerability' not in already_processed:
            already_processed.add('known_vulnerability')
            if value in ('true', '1'):
                self.known_vulnerability = True
            elif value in ('false', '0'):
                self.known_vulnerability = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CVE':
            obj_ = CVEVulnerabilityType.factory()
            obj_.build(child_)
            self.CVE = obj_
        elif nodeName_ == 'Targeted_Platforms':
            obj_ = PlatformListType.factory()
            obj_.build(child_)
            self.Targeted_Platforms = obj_
# end class VulnerabilityExploitType


class BehaviorRelationshipListType(GeneratedsSuper):
    """The BehaviorRelationshipListType captures any relationships between
    a Behavior and other Behaviors."""
    subclass = None
    superclass = None
    def __init__(self, Relationship=None):
        if Relationship is None:
            self.Relationship = []
        else:
            self.Relationship = Relationship
    def factory(*args_, **kwargs_):
        if BehaviorRelationshipListType.subclass:
            return BehaviorRelationshipListType.subclass(*args_, **kwargs_)
        else:
            return BehaviorRelationshipListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def add_Relationship(self, value): self.Relationship.append(value)
    def insert_Relationship(self, index, value): self.Relationship[index] = value
    def hasContent_(self):
        if (
            self.Relationship
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorRelationshipListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorRelationshipListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorRelationshipListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorRelationshipListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relationship_ in self.Relationship:
            Relationship_.export(outfile, level, namespace_, name_='Relationship', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehaviorRelationshipListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship=[\n')
        level += 1
        for Relationship_ in self.Relationship:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorRelationshipType(\n')
            Relationship_.exportLiteral(outfile, level, name_='BehaviorRelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship':
            obj_ = BehaviorRelationshipType.factory()
            obj_.build(child_)
            self.Relationship.append(obj_)
# end class BehaviorRelationshipListType


class BehavioralActionsType(GeneratedsSuper):
    """The BehavioralActionsType is intended to capture the Actions or
    Action Collections that make up a Behavior."""
    subclass = None
    superclass = None
    def __init__(self, Action_Collection=None, Action=None, Action_Reference=None, Action_Equivalence_Reference=None):
        if Action_Collection is None:
            self.Action_Collection = []
        else:
            self.Action_Collection = Action_Collection
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
        if Action_Reference is None:
            self.Action_Reference = []
        else:
            self.Action_Reference = Action_Reference
        if Action_Equivalence_Reference is None:
            self.Action_Equivalence_Reference = []
        else:
            self.Action_Equivalence_Reference = Action_Equivalence_Reference
    def factory(*args_, **kwargs_):
        if BehavioralActionsType.subclass:
            return BehavioralActionsType.subclass(*args_, **kwargs_)
        else:
            return BehavioralActionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Collection(self): return self.Action_Collection
    def set_Action_Collection(self, Action_Collection): self.Action_Collection = Action_Collection
    def add_Action_Collection(self, value): self.Action_Collection.append(value)
    def insert_Action_Collection(self, index, value): self.Action_Collection[index] = value
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def get_Action_Reference(self): return self.Action_Reference
    def set_Action_Reference(self, Action_Reference): self.Action_Reference = Action_Reference
    def add_Action_Reference(self, value): self.Action_Reference.append(value)
    def insert_Action_Reference(self, index, value): self.Action_Reference[index] = value
    def get_Action_Equivalence_Reference(self): return self.Action_Equivalence_Reference
    def set_Action_Equivalence_Reference(self, Action_Equivalence_Reference): self.Action_Equivalence_Reference = Action_Equivalence_Reference
    def add_Action_Equivalence_Reference(self, value): self.Action_Equivalence_Reference.append(value)
    def insert_Action_Equivalence_Reference(self, index, value): self.Action_Equivalence_Reference[index] = value
    def hasContent_(self):
        if (
            self.Action_Collection or
            self.Action or
            self.Action_Reference or
            self.Action_Equivalence_Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehavioralActionsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehavioralActionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehavioralActionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_Collection_ in self.Action_Collection:
            Action_Collection_.export(outfile, level, namespace_, name_='Action_Collection', pretty_print=pretty_print)
        for Action_ in self.Action:
            Action_.export(outfile, level, namespace_, name_='Action', pretty_print=pretty_print)
        for Action_Reference_ in self.Action_Reference:
            Action_Reference_.export(outfile, level, namespace_, name_='Action_Reference', pretty_print=pretty_print)
        for Action_Equivalence_Reference_ in self.Action_Equivalence_Reference:
            Action_Equivalence_Reference_.export(outfile, level, namespace_, name_='Action_Equivalence_Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehavioralActionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Collection=[\n')
        level += 1
        for Action_Collection_ in self.Action_Collection:
            showIndent(outfile, level)
            outfile.write('model_.ActionCollectionType(\n')
            Action_Collection_.exportLiteral(outfile, level, name_='ActionCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.BehavioralActionType(\n')
            Action_.exportLiteral(outfile, level, name_='BehavioralActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Action_Reference=[\n')
        level += 1
        for Action_Reference_ in self.Action_Reference:
            showIndent(outfile, level)
            outfile.write('model_.BehavioralActionReferenceType(\n')
            Action_Reference_.exportLiteral(outfile, level, name_='BehavioralActionReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Action_Equivalence_Reference=[\n')
        level += 1
        for Action_Equivalence_Reference_ in self.Action_Equivalence_Reference:
            showIndent(outfile, level)
            outfile.write('model_.BehavioralActionEquivalenceReferenceType(\n')
            Action_Equivalence_Reference_.exportLiteral(outfile, level, name_='BehavioralActionEquivalenceReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Collection':
            obj_ = ActionCollectionType.factory()
            obj_.build(child_)
            self.Action_Collection.append(obj_)
        elif nodeName_ == 'Action':
            obj_ = BehavioralActionType.factory()
            obj_.build(child_)
            self.Action.append(obj_)
        elif nodeName_ == 'Action_Reference':
            obj_ = BehavioralActionReferenceType.factory()
            obj_.build(child_)
            self.Action_Reference.append(obj_)
        elif nodeName_ == 'Action_Equivalence_Reference':
            obj_ = BehavioralActionEquivalenceReferenceType.factory()
            obj_.build(child_)
            self.Action_Equivalence_Reference.append(obj_)
# end class BehavioralActionsType


class BehaviorListType(GeneratedsSuper):
    """The BehaviorListType captures a list of Behaviors."""
    subclass = None
    superclass = None
    def __init__(self, Behavior=None):
        if Behavior is None:
            self.Behavior = []
        else:
            self.Behavior = Behavior
    def factory(*args_, **kwargs_):
        if BehaviorListType.subclass:
            return BehaviorListType.subclass(*args_, **kwargs_)
        else:
            return BehaviorListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior(self): return self.Behavior
    def set_Behavior(self, Behavior): self.Behavior = Behavior
    def add_Behavior(self, value): self.Behavior.append(value)
    def insert_Behavior(self, index, value): self.Behavior[index] = value
    def hasContent_(self):
        if (
            self.Behavior
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Behavior_ in self.Behavior:
            Behavior_.export(outfile, level, namespace_, name_='Behavior', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehaviorListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior=[\n')
        level += 1
        for Behavior_ in self.Behavior:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorType(\n')
            Behavior_.exportLiteral(outfile, level, name_='BehaviorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior':
            obj_ = BehaviorType.factory()
            obj_.build(child_)
            self.Behavior.append(obj_)
# end class BehaviorListType


class ActionListType(GeneratedsSuper):
    """The ActionListType captures a list of Actions."""
    subclass = None
    superclass = None
    def __init__(self, Action=None):
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
    def factory(*args_, **kwargs_):
        if ActionListType.subclass:
            return ActionListType.subclass(*args_, **kwargs_)
        else:
            return ActionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def hasContent_(self):
        if (
            self.Action
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_ in self.Action:
            Action_.export(outfile, level, namespace_, name_='Action', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.MalwareActionType(\n')
            Action_.exportLiteral(outfile, level, name_='MalwareActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            class_obj_ = self.get_class_obj_(child_, MalwareActionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Action.append(obj_)
# end class ActionListType


class ObjectListType(GeneratedsSuper):
    """The ObjectListType captures a list of CybOX Objects."""
    subclass = None
    superclass = None
    def __init__(self, Object=None):
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if ObjectListType.subclass:
            return ObjectListType.subclass(*args_, **kwargs_)
        else:
            return ObjectListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def hasContent_(self):
        if (
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_ in self.Object:
            Object_.export(outfile, level, namespace_, name_='Object', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_.ObjectType(\n')
            Object_.exportLiteral(outfile, level, name_='ObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Object.append(obj_)
# end class ObjectListType


class BehaviorReferenceType(GeneratedsSuper):
    """The BehaviorReferenceType serves as a method for referencing
    existing behaviors contained in the Bundle.The behavior_idref
    field specifies the id of the Behavior being referenced; this
    Behavior must be present in the current Bundle."""
    subclass = None
    superclass = None
    def __init__(self, behavior_idref=None):
        self.behavior_idref = _cast(None, behavior_idref)
        pass
    def factory(*args_, **kwargs_):
        if BehaviorReferenceType.subclass:
            return BehaviorReferenceType.subclass(*args_, **kwargs_)
        else:
            return BehaviorReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_behavior_idref(self): return self.behavior_idref
    def set_behavior_idref(self, behavior_idref): self.behavior_idref = behavior_idref
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorReferenceType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorReferenceType'):
        if self.behavior_idref is not None and 'behavior_idref' not in already_processed:
            already_processed.add('behavior_idref')
            outfile.write(' behavior_idref=%s' % (quote_attrib(self.behavior_idref), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BehaviorReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.behavior_idref is not None and 'behavior_idref' not in already_processed:
            already_processed.add('behavior_idref')
            showIndent(outfile, level)
            outfile.write('behavior_idref=%s,\n' % (self.behavior_idref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('behavior_idref', node)
        if value is not None and 'behavior_idref' not in already_processed:
            already_processed.add('behavior_idref')
            self.behavior_idref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BehaviorReferenceType


class ObjectReferenceType(GeneratedsSuper):
    """The ObjectReferenceType serves as a method for linking to CybOX
    Objects embedded in the MAEC Bundle.The object_idref field
    specifies the id of a CybOX Object being referenced in the
    current MAEC Bundle."""
    subclass = None
    superclass = None
    def __init__(self, object_idref=None):
        self.object_idref = _cast(None, object_idref)
        pass
    def factory(*args_, **kwargs_):
        if ObjectReferenceType.subclass:
            return ObjectReferenceType.subclass(*args_, **kwargs_)
        else:
            return ObjectReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_idref(self): return self.object_idref
    def set_object_idref(self, object_idref): self.object_idref = object_idref
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectReferenceType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectReferenceType'):
        if self.object_idref is not None and 'object_idref' not in already_processed:
            already_processed.add('object_idref')
            outfile.write(' object_idref=%s' % (quote_attrib(self.object_idref), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ObjectReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.object_idref is not None and 'object_idref' not in already_processed:
            already_processed.add('object_idref')
            showIndent(outfile, level)
            outfile.write('object_idref=%s,\n' % (self.object_idref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('object_idref', node)
        if value is not None and 'object_idref' not in already_processed:
            already_processed.add('object_idref')
            self.object_idref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ObjectReferenceType


class BehavioralActionEquivalenceReferenceType(GeneratedsSuper):
    """The BehavioralActionEquivalenceReferenceType defines an Action
    Equivalence reference that can be used as part of a Behavior.
    Since the Action Equivalency equates two or more actions to a
    single one, this can be thought of as specifying one of the
    aforementioned Actions as part of the composition of the
    Behavior.The action_equivalence_idref field specifies the ID of
    an Action Equivalence contained in the same MAEC document as the
    Behavior that utilizes it.The behavioral_ordering field defines
    the ordering of the Action Equivalency with respect to the other
    actions that make up the behavior. So an action with a
    behavioral_ordering of "1" would come before an action with a
    behavioral_ordering of "2", etc."""
    subclass = None
    superclass = None
    def __init__(self, action_equivalence_idref=None, behavioral_ordering=None):
        self.action_equivalence_idref = _cast(None, action_equivalence_idref)
        self.behavioral_ordering = _cast(int, behavioral_ordering)
        pass
    def factory(*args_, **kwargs_):
        if BehavioralActionEquivalenceReferenceType.subclass:
            return BehavioralActionEquivalenceReferenceType.subclass(*args_, **kwargs_)
        else:
            return BehavioralActionEquivalenceReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action_equivalence_idref(self): return self.action_equivalence_idref
    def set_action_equivalence_idref(self, action_equivalence_idref): self.action_equivalence_idref = action_equivalence_idref
    def get_behavioral_ordering(self): return self.behavioral_ordering
    def set_behavioral_ordering(self, behavioral_ordering): self.behavioral_ordering = behavioral_ordering
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehavioralActionEquivalenceReferenceType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionEquivalenceReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehavioralActionEquivalenceReferenceType'):
        if self.action_equivalence_idref is not None and 'action_equivalence_idref' not in already_processed:
            already_processed.add('action_equivalence_idref')
            outfile.write(' action_equivalence_idref=%s' % (quote_attrib(self.action_equivalence_idref), ))
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            outfile.write(' behavioral_ordering="%s"' % self.gds_format_integer(self.behavioral_ordering, input_name='behavioral_ordering'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehavioralActionEquivalenceReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BehavioralActionEquivalenceReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action_equivalence_idref is not None and 'action_equivalence_idref' not in already_processed:
            already_processed.add('action_equivalence_idref')
            showIndent(outfile, level)
            outfile.write('action_equivalence_idref=%s,\n' % (self.action_equivalence_idref,))
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            showIndent(outfile, level)
            outfile.write('behavioral_ordering=%d,\n' % (self.behavioral_ordering,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action_equivalence_idref', node)
        if value is not None and 'action_equivalence_idref' not in already_processed:
            already_processed.add('action_equivalence_idref')
            self.action_equivalence_idref = value
        value = find_attr_value_('behavioral_ordering', node)
        if value is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            try:
                self.behavioral_ordering = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.behavioral_ordering <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BehavioralActionEquivalenceReferenceType


class BehaviorReferenceListType(GeneratedsSuper):
    """The BehaviorReferenceListType captures a list of Behavior
    References."""
    subclass = None
    superclass = None
    def __init__(self, Behavior_Reference=None):
        if Behavior_Reference is None:
            self.Behavior_Reference = []
        else:
            self.Behavior_Reference = Behavior_Reference
    def factory(*args_, **kwargs_):
        if BehaviorReferenceListType.subclass:
            return BehaviorReferenceListType.subclass(*args_, **kwargs_)
        else:
            return BehaviorReferenceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Reference(self): return self.Behavior_Reference
    def set_Behavior_Reference(self, Behavior_Reference): self.Behavior_Reference = Behavior_Reference
    def add_Behavior_Reference(self, value): self.Behavior_Reference.append(value)
    def insert_Behavior_Reference(self, index, value): self.Behavior_Reference[index] = value
    def hasContent_(self):
        if (
            self.Behavior_Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorReferenceListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorReferenceListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorReferenceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorReferenceListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Behavior_Reference_ in self.Behavior_Reference:
            Behavior_Reference_.export(outfile, level, namespace_, name_='Behavior_Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehaviorReferenceListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior_Reference=[\n')
        level += 1
        for Behavior_Reference_ in self.Behavior_Reference:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorReferenceType(\n')
            Behavior_Reference_.exportLiteral(outfile, level, name_='BehaviorReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Reference':
            obj_ = BehaviorReferenceType.factory()
            obj_.build(child_)
            self.Behavior_Reference.append(obj_)
# end class BehaviorReferenceListType


class ActionReferenceListType(GeneratedsSuper):
    """The ActionReferenceListType captures a list of Action References."""
    subclass = None
    superclass = None
    def __init__(self, Action_Reference=None):
        if Action_Reference is None:
            self.Action_Reference = []
        else:
            self.Action_Reference = Action_Reference
    def factory(*args_, **kwargs_):
        if ActionReferenceListType.subclass:
            return ActionReferenceListType.subclass(*args_, **kwargs_)
        else:
            return ActionReferenceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Reference(self): return self.Action_Reference
    def set_Action_Reference(self, Action_Reference): self.Action_Reference = Action_Reference
    def add_Action_Reference(self, value): self.Action_Reference.append(value)
    def insert_Action_Reference(self, index, value): self.Action_Reference[index] = value
    def hasContent_(self):
        if (
            self.Action_Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionReferenceListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionReferenceListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionReferenceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionReferenceListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_Reference_ in self.Action_Reference:
            Action_Reference_.export(outfile, level, namespace_, name_='Action_Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionReferenceListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Reference=[\n')
        level += 1
        for Action_Reference_ in self.Action_Reference:
            showIndent(outfile, level)
            outfile.write('model_.ActionReferenceType(\n')
            Action_Reference_.exportLiteral(outfile, level, name_='ActionReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Reference':
            class_obj_ = self.get_class_obj_(child_, ActionReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Action_Reference.append(obj_)
# end class ActionReferenceListType


class ObjectReferenceListType(GeneratedsSuper):
    """The ObjectReferenceListType captures a list of references to CybOX
    Objects."""
    subclass = None
    superclass = None
    def __init__(self, Object_Reference=None):
        if Object_Reference is None:
            self.Object_Reference = []
        else:
            self.Object_Reference = Object_Reference
    def factory(*args_, **kwargs_):
        if ObjectReferenceListType.subclass:
            return ObjectReferenceListType.subclass(*args_, **kwargs_)
        else:
            return ObjectReferenceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object_Reference(self): return self.Object_Reference
    def set_Object_Reference(self, Object_Reference): self.Object_Reference = Object_Reference
    def add_Object_Reference(self, value): self.Object_Reference.append(value)
    def insert_Object_Reference(self, index, value): self.Object_Reference[index] = value
    def hasContent_(self):
        if (
            self.Object_Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectReferenceListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectReferenceListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectReferenceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectReferenceListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_Reference_ in self.Object_Reference:
            Object_Reference_.export(outfile, level, namespace_, name_='Object_Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectReferenceListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object_Reference=[\n')
        level += 1
        for Object_Reference_ in self.Object_Reference:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReferenceType(\n')
            Object_Reference_.exportLiteral(outfile, level, name_='ObjectReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object_Reference':
            obj_ = ObjectReferenceType.factory()
            obj_.build(child_)
            self.Object_Reference.append(obj_)
# end class ObjectReferenceListType


class CandidateIndicatorType(GeneratedsSuper):
    """The CandidateIndicatorType provides a way of defining a MAEC entity-
    based Candidate Indicator, which specifies the particular
    components that may signify the presence of the malware instance
    on a host system or network.The id field specifies a unique ID
    for this Candidate Indicator. The ID must follow the pattern
    defined in the CandidateIndicatorIDPattern simple type.The
    creation_datetime field specifies the date/time that the
    Candidate Indicator was created.The lastupdate_datetime field
    specifies the last date/time that the Candidate Indicator was
    updated.The version field specifies the version of the Candidate
    Indicator."""
    subclass = None
    superclass = None
    def __init__(self, version=None, creation_datetime=None, id=None, lastupdate_datetime=None, Importance=None, Numeric_Importance=None, Author=None, Description=None, Malware_Entity=None, Composition=None):
        self.version = _cast(None, version)
        if isinstance(creation_datetime, basestring):
            initvalue_ = datetime_.datetime.strptime(creation_datetime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creation_datetime
        self.creation_datetime = initvalue_
        self.id = _cast(None, id)
        if isinstance(lastupdate_datetime, basestring):
            initvalue_ = datetime_.datetime.strptime(lastupdate_datetime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = lastupdate_datetime
        self.lastupdate_datetime = initvalue_
        self.Importance = Importance
        self.Numeric_Importance = Numeric_Importance
        self.Author = Author
        self.Description = Description
        self.Malware_Entity = Malware_Entity
        self.Composition = Composition
    def factory(*args_, **kwargs_):
        if CandidateIndicatorType.subclass:
            return CandidateIndicatorType.subclass(*args_, **kwargs_)
        else:
            return CandidateIndicatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Importance(self): return self.Importance
    def set_Importance(self, Importance): self.Importance = Importance
    def get_Numeric_Importance(self): return self.Numeric_Importance
    def set_Numeric_Importance(self, Numeric_Importance): self.Numeric_Importance = Numeric_Importance
    def get_Author(self): return self.Author
    def set_Author(self, Author): self.Author = Author
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Malware_Entity(self): return self.Malware_Entity
    def set_Malware_Entity(self, Malware_Entity): self.Malware_Entity = Malware_Entity
    def get_Composition(self): return self.Composition
    def set_Composition(self, Composition): self.Composition = Composition
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_creation_datetime(self): return self.creation_datetime
    def set_creation_datetime(self, creation_datetime): self.creation_datetime = creation_datetime
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_lastupdate_datetime(self): return self.lastupdate_datetime
    def set_lastupdate_datetime(self, lastupdate_datetime): self.lastupdate_datetime = lastupdate_datetime
    def hasContent_(self):
        if (
            self.Importance is not None or
            self.Numeric_Importance is not None or
            self.Author is not None or
            self.Description is not None or
            self.Malware_Entity is not None or
            self.Composition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CandidateIndicatorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CandidateIndicatorType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.creation_datetime is not None and 'creation_datetime' not in already_processed:
            already_processed.add('creation_datetime')
            outfile.write(' creation_datetime="%s"' % self.gds_format_datetime(self.creation_datetime, input_name='creation_datetime'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.lastupdate_datetime is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.add('lastupdate_datetime')
            outfile.write(' lastupdate_datetime="%s"' % self.gds_format_datetime(self.lastupdate_datetime, input_name='lastupdate_datetime'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Importance is not None:
            self.Importance.export(outfile, level, namespace_, name_='Importance', pretty_print=pretty_print)
        if self.Numeric_Importance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumeric_Importance>%s</%sNumeric_Importance>%s' % (namespace_, self.gds_format_integer(self.Numeric_Importance, input_name='Numeric_Importance'), namespace_, eol_))
        if self.Author is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuthor>%s</%sAuthor>%s' % (namespace_, self.gds_format_string(quote_xml(self.Author).encode(ExternalEncoding), input_name='Author'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Malware_Entity is not None:
            self.Malware_Entity.export(outfile, level, namespace_, name_='Malware_Entity', pretty_print=pretty_print)
        if self.Composition is not None:
            self.Composition.export(outfile, level, namespace_, name_='Composition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CandidateIndicatorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.creation_datetime is not None and 'creation_datetime' not in already_processed:
            already_processed.add('creation_datetime')
            showIndent(outfile, level)
            outfile.write('creation_datetime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creation_datetime, input_name='creation_datetime'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.lastupdate_datetime is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.add('lastupdate_datetime')
            showIndent(outfile, level)
            outfile.write('lastupdate_datetime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.lastupdate_datetime, input_name='lastupdate_datetime'))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Importance is not None:
            showIndent(outfile, level)
            outfile.write('Importance=model_.ControlledVocabularyStringType(\n')
            self.Importance.exportLiteral(outfile, level, name_='Importance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Numeric_Importance is not None:
            showIndent(outfile, level)
            outfile.write('Numeric_Importance=%d,\n' % self.Numeric_Importance)
        if self.Author is not None:
            showIndent(outfile, level)
            outfile.write('Author=%s,\n' % quote_python(self.Author).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Malware_Entity is not None:
            showIndent(outfile, level)
            outfile.write('Malware_Entity=model_.MalwareEntityType(\n')
            self.Malware_Entity.exportLiteral(outfile, level, name_='Malware_Entity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Composition is not None:
            showIndent(outfile, level)
            outfile.write('Composition=model_.CandidateIndicatorCompositionType(\n')
            self.Composition.exportLiteral(outfile, level, name_='Composition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('creation_datetime', node)
        if value is not None and 'creation_datetime' not in already_processed:
            already_processed.add('creation_datetime')
            try:
                self.creation_datetime = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (creation_datetime): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('lastupdate_datetime', node)
        if value is not None and 'lastupdate_datetime' not in already_processed:
            already_processed.add('lastupdate_datetime')
            try:
                self.lastupdate_datetime = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (lastupdate_datetime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Importance':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Importance = obj_
        elif nodeName_ == 'Numeric_Importance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Numeric_Importance')
            self.Numeric_Importance = ival_
        elif nodeName_ == 'Author':
            Author_ = child_.text
            Author_ = self.gds_validate_string(Author_, node, 'Author')
            self.Author = Author_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Malware_Entity':
            obj_ = MalwareEntityType.factory()
            obj_.build(child_)
            self.Malware_Entity = obj_
        elif nodeName_ == 'Composition':
            obj_ = CandidateIndicatorCompositionType.factory()
            obj_.build(child_)
            self.Composition = obj_
# end class CandidateIndicatorType


class CandidateIndicatorListType(GeneratedsSuper):
    """The CandidateIndicatorListType captures a list of Candidate
    Indicators."""
    subclass = None
    superclass = None
    def __init__(self, Candidate_Indicator=None):
        if Candidate_Indicator is None:
            self.Candidate_Indicator = []
        else:
            self.Candidate_Indicator = Candidate_Indicator
    def factory(*args_, **kwargs_):
        if CandidateIndicatorListType.subclass:
            return CandidateIndicatorListType.subclass(*args_, **kwargs_)
        else:
            return CandidateIndicatorListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Candidate_Indicator(self): return self.Candidate_Indicator
    def set_Candidate_Indicator(self, Candidate_Indicator): self.Candidate_Indicator = Candidate_Indicator
    def add_Candidate_Indicator(self, value): self.Candidate_Indicator.append(value)
    def insert_Candidate_Indicator(self, index, value): self.Candidate_Indicator[index] = value
    def hasContent_(self):
        if (
            self.Candidate_Indicator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CandidateIndicatorListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CandidateIndicatorListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Candidate_Indicator_ in self.Candidate_Indicator:
            Candidate_Indicator_.export(outfile, level, namespace_, name_='Candidate_Indicator', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CandidateIndicatorListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Candidate_Indicator=[\n')
        level += 1
        for Candidate_Indicator_ in self.Candidate_Indicator:
            showIndent(outfile, level)
            outfile.write('model_.CandidateIndicatorType(\n')
            Candidate_Indicator_.exportLiteral(outfile, level, name_='CandidateIndicatorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Candidate_Indicator':
            obj_ = CandidateIndicatorType.factory()
            obj_.build(child_)
            self.Candidate_Indicator.append(obj_)
# end class CandidateIndicatorListType


class MalwareEntityType(GeneratedsSuper):
    """The MalwareEntityType provides a mechanism for characterizing the
    particular entity that an indicator or signature is written
    against, whether it is a particular malware instance, family,
    etc."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Name=None, Description=None):
        self.Type = Type
        self.Name = Name
        self.Description = Description
    def factory(*args_, **kwargs_):
        if MalwareEntityType.subclass:
            return MalwareEntityType.subclass(*args_, **kwargs_)
        else:
            return MalwareEntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Name is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='MalwareEntityType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MalwareEntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='MalwareEntityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='MalwareEntityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MalwareEntityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.ControlledVocabularyStringType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Type = obj_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class MalwareEntityType


class CollectionsType(GeneratedsSuper):
    """The CollectionsType captures the various types of MAEC entity
    collections."""
    subclass = None
    superclass = None
    def __init__(self, Behavior_Collections=None, Action_Collections=None, Object_Collections=None, Candidate_Indicator_Collections=None):
        self.Behavior_Collections = Behavior_Collections
        self.Action_Collections = Action_Collections
        self.Object_Collections = Object_Collections
        self.Candidate_Indicator_Collections = Candidate_Indicator_Collections
    def factory(*args_, **kwargs_):
        if CollectionsType.subclass:
            return CollectionsType.subclass(*args_, **kwargs_)
        else:
            return CollectionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Collections(self): return self.Behavior_Collections
    def set_Behavior_Collections(self, Behavior_Collections): self.Behavior_Collections = Behavior_Collections
    def get_Action_Collections(self): return self.Action_Collections
    def set_Action_Collections(self, Action_Collections): self.Action_Collections = Action_Collections
    def get_Object_Collections(self): return self.Object_Collections
    def set_Object_Collections(self, Object_Collections): self.Object_Collections = Object_Collections
    def get_Candidate_Indicator_Collections(self): return self.Candidate_Indicator_Collections
    def set_Candidate_Indicator_Collections(self, Candidate_Indicator_Collections): self.Candidate_Indicator_Collections = Candidate_Indicator_Collections
    def hasContent_(self):
        if (
            self.Behavior_Collections is not None or
            self.Action_Collections is not None or
            self.Object_Collections is not None or
            self.Candidate_Indicator_Collections is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CollectionsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CollectionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CollectionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CollectionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Behavior_Collections is not None:
            self.Behavior_Collections.export(outfile, level, namespace_, name_='Behavior_Collections', pretty_print=pretty_print)
        if self.Action_Collections is not None:
            self.Action_Collections.export(outfile, level, namespace_, name_='Action_Collections', pretty_print=pretty_print)
        if self.Object_Collections is not None:
            self.Object_Collections.export(outfile, level, namespace_, name_='Object_Collections', pretty_print=pretty_print)
        if self.Candidate_Indicator_Collections is not None:
            self.Candidate_Indicator_Collections.export(outfile, level, namespace_, name_='Candidate_Indicator_Collections', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CollectionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Behavior_Collections is not None:
            showIndent(outfile, level)
            outfile.write('Behavior_Collections=model_.BehaviorCollectionListType(\n')
            self.Behavior_Collections.exportLiteral(outfile, level, name_='Behavior_Collections')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Collections is not None:
            showIndent(outfile, level)
            outfile.write('Action_Collections=model_.ActionCollectionListType(\n')
            self.Action_Collections.exportLiteral(outfile, level, name_='Action_Collections')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Object_Collections is not None:
            showIndent(outfile, level)
            outfile.write('Object_Collections=model_.ObjectCollectionListType(\n')
            self.Object_Collections.exportLiteral(outfile, level, name_='Object_Collections')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Candidate_Indicator_Collections is not None:
            showIndent(outfile, level)
            outfile.write('Candidate_Indicator_Collections=model_.CandidateIndicatorCollectionListType(\n')
            self.Candidate_Indicator_Collections.exportLiteral(outfile, level, name_='Candidate_Indicator_Collections')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Collections':
            obj_ = BehaviorCollectionListType.factory()
            obj_.build(child_)
            self.Behavior_Collections = obj_
        elif nodeName_ == 'Action_Collections':
            obj_ = ActionCollectionListType.factory()
            obj_.build(child_)
            self.Action_Collections = obj_
        elif nodeName_ == 'Object_Collections':
            obj_ = ObjectCollectionListType.factory()
            obj_.build(child_)
            self.Object_Collections = obj_
        elif nodeName_ == 'Candidate_Indicator_Collections':
            obj_ = CandidateIndicatorCollectionListType.factory()
            obj_.build(child_)
            self.Candidate_Indicator_Collections = obj_
# end class CollectionsType


class BundleReferenceType(GeneratedsSuper):
    """The BundleReferenceType serves as a method for linking to Bundles
    embedded in other locations.The bundle_idref field references
    the ID of a Bundle contained inside the current MAEC document."""
    subclass = None
    superclass = None
    def __init__(self, bundle_idref=None):
        self.bundle_idref = _cast(None, bundle_idref)
        pass
    def factory(*args_, **kwargs_):
        if BundleReferenceType.subclass:
            return BundleReferenceType.subclass(*args_, **kwargs_)
        else:
            return BundleReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bundle_idref(self): return self.bundle_idref
    def set_bundle_idref(self, bundle_idref): self.bundle_idref = bundle_idref
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BundleReferenceType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BundleReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BundleReferenceType'):
        if self.bundle_idref is not None and 'bundle_idref' not in already_processed:
            already_processed.add('bundle_idref')
            outfile.write(' bundle_idref=%s' % (quote_attrib(self.bundle_idref), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BundleReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BundleReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.bundle_idref is not None and 'bundle_idref' not in already_processed:
            already_processed.add('bundle_idref')
            showIndent(outfile, level)
            outfile.write('bundle_idref=%s,\n' % (self.bundle_idref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bundle_idref', node)
        if value is not None and 'bundle_idref' not in already_processed:
            already_processed.add('bundle_idref')
            self.bundle_idref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BundleReferenceType


class ProcessTreeType(GeneratedsSuper):
    """The ProcessTreeType captures the process tree for the malware
    instance, including the parent process and processes spawned by
    it, along with any Actions initiated by each."""
    subclass = None
    superclass = None
    def __init__(self, Root_Process=None):
        self.Root_Process = Root_Process
    def factory(*args_, **kwargs_):
        if ProcessTreeType.subclass:
            return ProcessTreeType.subclass(*args_, **kwargs_)
        else:
            return ProcessTreeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Root_Process(self): return self.Root_Process
    def set_Root_Process(self, Root_Process): self.Root_Process = Root_Process
    def hasContent_(self):
        if (
            self.Root_Process is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ProcessTreeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessTreeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ProcessTreeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ProcessTreeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Root_Process is not None:
            self.Root_Process.export(outfile, level, namespace_, name_='Root_Process', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessTreeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Root_Process is not None:
            showIndent(outfile, level)
            outfile.write('Root_Process=model_.ProcessTreeNodeType(\n')
            self.Root_Process.exportLiteral(outfile, level, name_='Root_Process')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Root_Process':
            obj_ = ProcessTreeNodeType.factory()
            obj_.build(child_)
            self.Root_Process = obj_
# end class ProcessTreeType


class CandidateIndicatorCompositionType(GeneratedsSuper):
    """The CandidateIndicatorCompositionType captures the composition of a
    Candidate Indicator, via references to any corresponding MAEC
    entities contained in the Bundle.The operator field specifies
    the Boolean operator for this level of the Candidate Indicator's
    composition."""
    subclass = None
    superclass = None
    def __init__(self, operator=None, Behavior_Reference=None, Action_Reference=None, Object_Reference=None, Sub_Composition=None):
        self.operator = _cast(None, operator)
        if Behavior_Reference is None:
            self.Behavior_Reference = []
        else:
            self.Behavior_Reference = Behavior_Reference
        if Action_Reference is None:
            self.Action_Reference = []
        else:
            self.Action_Reference = Action_Reference
        if Object_Reference is None:
            self.Object_Reference = []
        else:
            self.Object_Reference = Object_Reference
        if Sub_Composition is None:
            self.Sub_Composition = []
        else:
            self.Sub_Composition = Sub_Composition
    def factory(*args_, **kwargs_):
        if CandidateIndicatorCompositionType.subclass:
            return CandidateIndicatorCompositionType.subclass(*args_, **kwargs_)
        else:
            return CandidateIndicatorCompositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Reference(self): return self.Behavior_Reference
    def set_Behavior_Reference(self, Behavior_Reference): self.Behavior_Reference = Behavior_Reference
    def add_Behavior_Reference(self, value): self.Behavior_Reference.append(value)
    def insert_Behavior_Reference(self, index, value): self.Behavior_Reference[index] = value
    def get_Action_Reference(self): return self.Action_Reference
    def set_Action_Reference(self, Action_Reference): self.Action_Reference = Action_Reference
    def add_Action_Reference(self, value): self.Action_Reference.append(value)
    def insert_Action_Reference(self, index, value): self.Action_Reference[index] = value
    def get_Object_Reference(self): return self.Object_Reference
    def set_Object_Reference(self, Object_Reference): self.Object_Reference = Object_Reference
    def add_Object_Reference(self, value): self.Object_Reference.append(value)
    def insert_Object_Reference(self, index, value): self.Object_Reference[index] = value
    def get_Sub_Composition(self): return self.Sub_Composition
    def set_Sub_Composition(self, Sub_Composition): self.Sub_Composition = Sub_Composition
    def add_Sub_Composition(self, value): self.Sub_Composition.append(value)
    def insert_Sub_Composition(self, index, value): self.Sub_Composition[index] = value
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def hasContent_(self):
        if (
            self.Behavior_Reference or
            self.Action_Reference or
            self.Object_Reference or
            self.Sub_Composition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorCompositionType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CandidateIndicatorCompositionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CandidateIndicatorCompositionType'):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorCompositionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Behavior_Reference_ in self.Behavior_Reference:
            Behavior_Reference_.export(outfile, level, namespace_, name_='Behavior_Reference', pretty_print=pretty_print)
        for Action_Reference_ in self.Action_Reference:
            Action_Reference_.export(outfile, level, namespace_, name_='Action_Reference', pretty_print=pretty_print)
        for Object_Reference_ in self.Object_Reference:
            Object_Reference_.export(outfile, level, namespace_, name_='Object_Reference', pretty_print=pretty_print)
        for Sub_Composition_ in self.Sub_Composition:
            Sub_Composition_.export(outfile, level, namespace_, name_='Sub_Composition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CandidateIndicatorCompositionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            showIndent(outfile, level)
            outfile.write('operator=%s,\n' % (self.operator,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior_Reference=[\n')
        level += 1
        for Behavior_Reference_ in self.Behavior_Reference:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorReferenceType(\n')
            Behavior_Reference_.exportLiteral(outfile, level, name_='BehaviorReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Action_Reference=[\n')
        level += 1
        for Action_Reference_ in self.Action_Reference:
            showIndent(outfile, level)
            outfile.write('model_.ActionReferenceType(\n')
            Action_Reference_.exportLiteral(outfile, level, name_='ActionReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Object_Reference=[\n')
        level += 1
        for Object_Reference_ in self.Object_Reference:
            showIndent(outfile, level)
            outfile.write('model_.ObjectReferenceType(\n')
            Object_Reference_.exportLiteral(outfile, level, name_='ObjectReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Sub_Composition=[\n')
        level += 1
        for Sub_Composition_ in self.Sub_Composition:
            showIndent(outfile, level)
            outfile.write('model_.CandidateIndicatorCompositionType(\n')
            Sub_Composition_.exportLiteral(outfile, level, name_='CandidateIndicatorCompositionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Reference':
            obj_ = BehaviorReferenceType.factory()
            obj_.build(child_)
            self.Behavior_Reference.append(obj_)
        elif nodeName_ == 'Action_Reference':
            class_obj_ = self.get_class_obj_(child_, ActionReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Action_Reference.append(obj_)
        elif nodeName_ == 'Object_Reference':
            obj_ = ObjectReferenceType.factory()
            obj_.build(child_)
            self.Object_Reference.append(obj_)
        elif nodeName_ == 'Sub_Composition':
            obj_ = CandidateIndicatorCompositionType.factory()
            obj_.build(child_)
            self.Sub_Composition.append(obj_)
# end class CandidateIndicatorCompositionType


class CandidateIndicatorCollectionType(BaseCollectionType):
    """The CandidateIndicatorCollectionType provides a mechanism for
    characterizing collections of Candidate Indicators.The id field
    specifies a unique ID for this Candidate Indicator Collection.
    The ID must follow the pattern defined in the
    CandidateIndicatorCollIDPattern simple type."""
    subclass = None
    superclass = BaseCollectionType
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, id=None, Candidate_Indicator_List=None):
        super(CandidateIndicatorCollectionType, self).__init__(name, Affinity_Type, Affinity_Degree, Description, )
        self.id = _cast(None, id)
        self.Candidate_Indicator_List = Candidate_Indicator_List
    def factory(*args_, **kwargs_):
        if CandidateIndicatorCollectionType.subclass:
            return CandidateIndicatorCollectionType.subclass(*args_, **kwargs_)
        else:
            return CandidateIndicatorCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Candidate_Indicator_List(self): return self.Candidate_Indicator_List
    def set_Candidate_Indicator_List(self, Candidate_Indicator_List): self.Candidate_Indicator_List = Candidate_Indicator_List
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Candidate_Indicator_List is not None or
            super(CandidateIndicatorCollectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorCollectionType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CandidateIndicatorCollectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CandidateIndicatorCollectionType'):
        super(CandidateIndicatorCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CandidateIndicatorCollectionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorCollectionType', fromsubclass_=False, pretty_print=True):
        super(CandidateIndicatorCollectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Candidate_Indicator_List is not None:
            self.Candidate_Indicator_List.export(outfile, level, namespace_, name_='Candidate_Indicator_List', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CandidateIndicatorCollectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        super(CandidateIndicatorCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CandidateIndicatorCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Candidate_Indicator_List is not None:
            showIndent(outfile, level)
            outfile.write('Candidate_Indicator_List=model_.CandidateIndicatorListType(\n')
            self.Candidate_Indicator_List.exportLiteral(outfile, level, name_='Candidate_Indicator_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(CandidateIndicatorCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Candidate_Indicator_List':
            obj_ = CandidateIndicatorListType.factory()
            obj_.build(child_)
            self.Candidate_Indicator_List = obj_
        super(CandidateIndicatorCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class CandidateIndicatorCollectionType


class CandidateIndicatorCollectionListType(GeneratedsSuper):
    """The CandidateIndicatorCollectionListType captures a list of
    Candidate Indicators."""
    subclass = None
    superclass = None
    def __init__(self, Candidate_Indicator_Collection=None):
        if Candidate_Indicator_Collection is None:
            self.Candidate_Indicator_Collection = []
        else:
            self.Candidate_Indicator_Collection = Candidate_Indicator_Collection
    def factory(*args_, **kwargs_):
        if CandidateIndicatorCollectionListType.subclass:
            return CandidateIndicatorCollectionListType.subclass(*args_, **kwargs_)
        else:
            return CandidateIndicatorCollectionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Candidate_Indicator_Collection(self): return self.Candidate_Indicator_Collection
    def set_Candidate_Indicator_Collection(self, Candidate_Indicator_Collection): self.Candidate_Indicator_Collection = Candidate_Indicator_Collection
    def add_Candidate_Indicator_Collection(self, value): self.Candidate_Indicator_Collection.append(value)
    def insert_Candidate_Indicator_Collection(self, index, value): self.Candidate_Indicator_Collection[index] = value
    def hasContent_(self):
        if (
            self.Candidate_Indicator_Collection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorCollectionListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CandidateIndicatorCollectionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CandidateIndicatorCollectionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CandidateIndicatorCollectionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Candidate_Indicator_Collection_ in self.Candidate_Indicator_Collection:
            Candidate_Indicator_Collection_.export(outfile, level, namespace_, name_='Candidate_Indicator_Collection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CandidateIndicatorCollectionListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Candidate_Indicator_Collection=[\n')
        level += 1
        for Candidate_Indicator_Collection_ in self.Candidate_Indicator_Collection:
            showIndent(outfile, level)
            outfile.write('model_.CandidateIndicatorCollectionType(\n')
            Candidate_Indicator_Collection_.exportLiteral(outfile, level, name_='CandidateIndicatorCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Candidate_Indicator_Collection':
            obj_ = CandidateIndicatorCollectionType.factory()
            obj_.build(child_)
            self.Candidate_Indicator_Collection.append(obj_)
# end class CandidateIndicatorCollectionListType


class BehaviorCollectionListType(GeneratedsSuper):
    """The BehaviorCollectionListType captures a list of Behaviors
    Collections."""
    subclass = None
    superclass = None
    def __init__(self, Behavior_Collection=None):
        if Behavior_Collection is None:
            self.Behavior_Collection = []
        else:
            self.Behavior_Collection = Behavior_Collection
    def factory(*args_, **kwargs_):
        if BehaviorCollectionListType.subclass:
            return BehaviorCollectionListType.subclass(*args_, **kwargs_)
        else:
            return BehaviorCollectionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Behavior_Collection(self): return self.Behavior_Collection
    def set_Behavior_Collection(self, Behavior_Collection): self.Behavior_Collection = Behavior_Collection
    def add_Behavior_Collection(self, value): self.Behavior_Collection.append(value)
    def insert_Behavior_Collection(self, index, value): self.Behavior_Collection[index] = value
    def hasContent_(self):
        if (
            self.Behavior_Collection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorCollectionListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorCollectionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorCollectionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorCollectionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Behavior_Collection_ in self.Behavior_Collection:
            Behavior_Collection_.export(outfile, level, namespace_, name_='Behavior_Collection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehaviorCollectionListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Behavior_Collection=[\n')
        level += 1
        for Behavior_Collection_ in self.Behavior_Collection:
            showIndent(outfile, level)
            outfile.write('model_.BehaviorCollectionType(\n')
            Behavior_Collection_.exportLiteral(outfile, level, name_='BehaviorCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Behavior_Collection':
            obj_ = BehaviorCollectionType.factory()
            obj_.build(child_)
            self.Behavior_Collection.append(obj_)
# end class BehaviorCollectionListType


class ActionCollectionListType(GeneratedsSuper):
    """The ActionCollectionListType captures a list of Actions Collections."""
    subclass = None
    superclass = None
    def __init__(self, Action_Collection=None):
        if Action_Collection is None:
            self.Action_Collection = []
        else:
            self.Action_Collection = Action_Collection
    def factory(*args_, **kwargs_):
        if ActionCollectionListType.subclass:
            return ActionCollectionListType.subclass(*args_, **kwargs_)
        else:
            return ActionCollectionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Collection(self): return self.Action_Collection
    def set_Action_Collection(self, Action_Collection): self.Action_Collection = Action_Collection
    def add_Action_Collection(self, value): self.Action_Collection.append(value)
    def insert_Action_Collection(self, index, value): self.Action_Collection[index] = value
    def hasContent_(self):
        if (
            self.Action_Collection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionCollectionListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionCollectionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionCollectionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionCollectionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_Collection_ in self.Action_Collection:
            Action_Collection_.export(outfile, level, namespace_, name_='Action_Collection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionCollectionListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Collection=[\n')
        level += 1
        for Action_Collection_ in self.Action_Collection:
            showIndent(outfile, level)
            outfile.write('model_.ActionCollectionType(\n')
            Action_Collection_.exportLiteral(outfile, level, name_='ActionCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Collection':
            obj_ = ActionCollectionType.factory()
            obj_.build(child_)
            self.Action_Collection.append(obj_)
# end class ActionCollectionListType


class ObjectCollectionListType(GeneratedsSuper):
    """The ObjectCollectionListType captures a list of Object Collections."""
    subclass = None
    superclass = None
    def __init__(self, Object_Collection=None):
        if Object_Collection is None:
            self.Object_Collection = []
        else:
            self.Object_Collection = Object_Collection
    def factory(*args_, **kwargs_):
        if ObjectCollectionListType.subclass:
            return ObjectCollectionListType.subclass(*args_, **kwargs_)
        else:
            return ObjectCollectionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object_Collection(self): return self.Object_Collection
    def set_Object_Collection(self, Object_Collection): self.Object_Collection = Object_Collection
    def add_Object_Collection(self, value): self.Object_Collection.append(value)
    def insert_Object_Collection(self, index, value): self.Object_Collection[index] = value
    def hasContent_(self):
        if (
            self.Object_Collection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectCollectionListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectCollectionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectCollectionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectCollectionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_Collection_ in self.Object_Collection:
            Object_Collection_.export(outfile, level, namespace_, name_='Object_Collection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectCollectionListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object_Collection=[\n')
        level += 1
        for Object_Collection_ in self.Object_Collection:
            showIndent(outfile, level)
            outfile.write('model_.ObjectCollectionType(\n')
            Object_Collection_.exportLiteral(outfile, level, name_='ObjectCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object_Collection':
            obj_ = ObjectCollectionType.factory()
            obj_.build(child_)
            self.Object_Collection.append(obj_)
# end class ObjectCollectionListType


class ObservablesType(GeneratedsSuper):
    """The ObservablesType is a type representing a collection of cyber
    observables.The major_version field specifies the major version
    of the CybOX language utlized for this set of Observables.The
    minor_version field specifies the minor version of the CybOX
    language utlized for this set of Observables."""
    subclass = None
    superclass = None
    def __init__(self, cybox_minor_version=None, cybox_major_version=None, Observable_Package_Source=None, Observable=None, Pools=None):
        self.cybox_minor_version = _cast(None, cybox_minor_version)
        self.cybox_major_version = _cast(None, cybox_major_version)
        self.Observable_Package_Source = Observable_Package_Source
        if Observable is None:
            self.Observable = []
        else:
            self.Observable = Observable
        self.Pools = Pools
    def factory(*args_, **kwargs_):
        if ObservablesType.subclass:
            return ObservablesType.subclass(*args_, **kwargs_)
        else:
            return ObservablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Observable_Package_Source(self): return self.Observable_Package_Source
    def set_Observable_Package_Source(self, Observable_Package_Source): self.Observable_Package_Source = Observable_Package_Source
    def get_Observable(self): return self.Observable
    def set_Observable(self, Observable): self.Observable = Observable
    def add_Observable(self, value): self.Observable.append(value)
    def insert_Observable(self, index, value): self.Observable[index] = value
    def get_Pools(self): return self.Pools
    def set_Pools(self, Pools): self.Pools = Pools
    def get_cybox_minor_version(self): return self.cybox_minor_version
    def set_cybox_minor_version(self, cybox_minor_version): self.cybox_minor_version = cybox_minor_version
    def get_cybox_major_version(self): return self.cybox_major_version
    def set_cybox_major_version(self, cybox_major_version): self.cybox_major_version = cybox_major_version
    def hasContent_(self):
        if (
            self.Observable_Package_Source is not None or
            self.Observable or
            self.Pools is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObservablesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObservablesType'):
        if self.cybox_minor_version is not None and 'cybox_minor_version' not in already_processed:
            already_processed.add('cybox_minor_version')
            outfile.write(' cybox_minor_version=%s' % (self.gds_format_string(quote_attrib(self.cybox_minor_version).encode(ExternalEncoding), input_name='cybox_minor_version'), ))
        if self.cybox_major_version is not None and 'cybox_major_version' not in already_processed:
            already_processed.add('cybox_major_version')
            outfile.write(' cybox_major_version=%s' % (self.gds_format_string(quote_attrib(self.cybox_major_version).encode(ExternalEncoding), input_name='cybox_major_version'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObservablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Observable_Package_Source is not None:
            self.Observable_Package_Source.export(outfile, level, namespace_, name_='Observable_Package_Source', pretty_print=pretty_print)
        for Observable_ in self.Observable:
            Observable_.export(outfile, level, namespace_='cybox:', name_='Observable', pretty_print=pretty_print)
        if self.Pools is not None:
            self.Pools.export(outfile, level, namespace_, name_='Pools', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObservablesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cybox_minor_version is not None and 'cybox_minor_version' not in already_processed:
            already_processed.add('cybox_minor_version')
            showIndent(outfile, level)
            outfile.write('cybox_minor_version="%s",\n' % (self.cybox_minor_version,))
        if self.cybox_major_version is not None and 'cybox_major_version' not in already_processed:
            already_processed.add('cybox_major_version')
            showIndent(outfile, level)
            outfile.write('cybox_major_version="%s",\n' % (self.cybox_major_version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Observable_Package_Source is not None:
            showIndent(outfile, level)
            outfile.write('Observable_Package_Source=model_.MeasureSourceType(\n')
            self.Observable_Package_Source.exportLiteral(outfile, level, name_='Observable_Package_Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Observable=[\n')
        level += 1
        for Observable_ in self.Observable:
            showIndent(outfile, level)
            outfile.write('model_.Observable(\n')
            Observable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Pools is not None:
            showIndent(outfile, level)
            outfile.write('Pools=model_.PoolsType(\n')
            self.Pools.exportLiteral(outfile, level, name_='Pools')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cybox_minor_version', node)
        if value is not None and 'cybox_minor_version' not in already_processed:
            already_processed.add('cybox_minor_version')
            self.cybox_minor_version = value
        value = find_attr_value_('cybox_major_version', node)
        if value is not None and 'cybox_major_version' not in already_processed:
            already_processed.add('cybox_major_version')
            self.cybox_major_version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Observable_Package_Source':
            obj_ = MeasureSourceType.factory()
            obj_.build(child_)
            self.Observable_Package_Source = obj_
        elif nodeName_ == 'Observable':
            obj_ = ObservableType.factory()
            obj_.build(child_)
            self.Observable.append(obj_)
        elif nodeName_ == 'Pools':
            obj_ = PoolsType.factory()
            obj_.build(child_)
            self.Pools = obj_
# end class ObservablesType


class ObservableType(GeneratedsSuper):
    """The ObservableType is a type representing a description of a single
    cyber observable.The id field specifies a unique id for this
    Observable.The idref field specifies a unique id reference to an
    Observable defined elsewhere.The negate field, when set to true,
    indicates the absence (rather than the presence) of the given
    Observable in a CybOX pattern."""
    subclass = None
    superclass = None
    def __init__(self, negate=False, idref=None, id=None, Title=None, Description=None, Keywords=None, Observable_Source=None, Object=None, Event=None, Observable_Composition=None, Pattern_Fidelity=None):
        self.negate = _cast(bool, negate)
        self.idref = _cast(None, idref)
        self.id = _cast(None, id)
        self.Title = Title
        self.Description = Description
        self.Keywords = Keywords
        self.Observable_Source = Observable_Source
        self.Object = Object
        self.Event = Event
        self.Observable_Composition = Observable_Composition
        self.Pattern_Fidelity = Pattern_Fidelity
    def factory(*args_, **kwargs_):
        if ObservableType.subclass:
            return ObservableType.subclass(*args_, **kwargs_)
        else:
            return ObservableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Keywords(self): return self.Keywords
    def set_Keywords(self, Keywords): self.Keywords = Keywords
    def get_Observable_Source(self): return self.Observable_Source
    def set_Observable_Source(self, Observable_Source): self.Observable_Source = Observable_Source
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def get_Observable_Composition(self): return self.Observable_Composition
    def set_Observable_Composition(self, Observable_Composition): self.Observable_Composition = Observable_Composition
    def get_Pattern_Fidelity(self): return self.Pattern_Fidelity
    def set_Pattern_Fidelity(self, Pattern_Fidelity): self.Pattern_Fidelity = Pattern_Fidelity
    def get_negate(self): return self.negate
    def set_negate(self, negate): self.negate = negate
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Description is not None or
            self.Keywords is not None or
            self.Observable_Source is not None or
            self.Object is not None or
            self.Event is not None or
            self.Observable_Composition is not None or
            self.Pattern_Fidelity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObservableType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObservableType'):
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate="%s"' % self.gds_format_boolean(self.negate, input_name='negate'))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObservableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_, eol_))
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Keywords is not None:
            self.Keywords.export(outfile, level, namespace_, name_='Keywords', pretty_print=pretty_print)
        if self.Observable_Source is not None:
            self.Observable_Source.export(outfile, level, namespace_, name_='Observable_Source', pretty_print=pretty_print)
        if self.Object is not None:
            self.Object.export(outfile, level, namespace_='cybox:', name_='Object', pretty_print=pretty_print)
        if self.Event is not None:
            self.Event.export(outfile, level, namespace_='cybox:', name_='Event', pretty_print=pretty_print)
        if self.Observable_Composition is not None:
            self.Observable_Composition.export(outfile, level, namespace_, name_='Observable_Composition', pretty_print=pretty_print)
        if self.Pattern_Fidelity is not None:
            self.Pattern_Fidelity.export(outfile, level, namespace_, name_='Pattern_Fidelity', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObservableType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            showIndent(outfile, level)
            outfile.write('negate=%s,\n' % (self.negate,))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            showIndent(outfile, level)
            outfile.write('idref=%s,\n' % (self.idref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Keywords is not None:
            showIndent(outfile, level)
            outfile.write('Keywords=model_.KeywordsType(\n')
            self.Keywords.exportLiteral(outfile, level, name_='Keywords')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observable_Source is not None:
            showIndent(outfile, level)
            outfile.write('Observable_Source=model_.MeasureSourceType(\n')
            self.Observable_Source.exportLiteral(outfile, level, name_='Observable_Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Object is not None:
            showIndent(outfile, level)
            outfile.write('Object=model_.Object(\n')
            self.Object.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Event is not None:
            showIndent(outfile, level)
            outfile.write('Event=model_.Event(\n')
            self.Event.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observable_Composition is not None:
            showIndent(outfile, level)
            outfile.write('Observable_Composition=model_.ObservableCompositionType(\n')
            self.Observable_Composition.exportLiteral(outfile, level, name_='Observable_Composition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Pattern_Fidelity is not None:
            showIndent(outfile, level)
            outfile.write('Pattern_Fidelity=model_.PatternFidelityType(\n')
            self.Pattern_Fidelity.exportLiteral(outfile, level, name_='Pattern_Fidelity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            if value in ('true', '1'):
                self.negate = True
            elif value in ('false', '0'):
                self.negate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Keywords':
            obj_ = KeywordsType.factory()
            obj_.build(child_)
            self.Keywords = obj_
        elif nodeName_ == 'Observable_Source':
            obj_ = MeasureSourceType.factory()
            obj_.build(child_)
            self.Observable_Source = obj_
        elif nodeName_ == 'Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Object = obj_
        elif nodeName_ == 'Event':
            obj_ = EventType.factory()
            obj_.build(child_)
            self.Event = obj_
        elif nodeName_ == 'Observable_Composition':
            obj_ = ObservableCompositionType.factory()
            obj_.build(child_)
            self.Observable_Composition = obj_
        elif nodeName_ == 'Pattern_Fidelity':
            obj_ = PatternFidelityType.factory()
            obj_.build(child_)
            self.Pattern_Fidelity = obj_
# end class ObservableType


class EventType(GeneratedsSuper):
    """The EventType is a complex type representing a cyber observable
    event that is dynamic in nature with specific action(s) taken
    against specific cyber relevant objects (e.g. a file is deleted,
    a registry key is created or an HTTP Get Request is
    received).The id field specifies a unique id for this Event.The
    idref field specifies a unique id reference to an Event defined
    elsewhere."""
    subclass = None
    superclass = None
    def __init__(self, idref=None, id=None, Type=None, Description=None, Observation_Method=None, Actions=None, Frequency=None, Event=None):
        self.idref = _cast(None, idref)
        self.id = _cast(None, id)
        self.Type = Type
        self.Description = Description
        self.Observation_Method = Observation_Method
        self.Actions = Actions
        self.Frequency = Frequency
        self.Event = Event
    def factory(*args_, **kwargs_):
        if EventType.subclass:
            return EventType.subclass(*args_, **kwargs_)
        else:
            return EventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Observation_Method(self): return self.Observation_Method
    def set_Observation_Method(self, Observation_Method): self.Observation_Method = Observation_Method
    def get_Actions(self): return self.Actions
    def set_Actions(self, Actions): self.Actions = Actions
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Description is not None or
            self.Observation_Method is not None or
            self.Actions is not None or
            self.Frequency is not None or
            self.Event is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='EventType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='EventType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='EventType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Observation_Method is not None:
            self.Observation_Method.export(outfile, level, namespace_, name_='Observation_Method', pretty_print=pretty_print)
        if self.Actions is not None:
            self.Actions.export(outfile, level, namespace_, name_='Actions', pretty_print=pretty_print)
        if self.Frequency is not None:
            self.Frequency.export(outfile, level, namespace_, name_='Frequency', pretty_print=pretty_print)
        if self.Event is not None:
            self.Event.export(outfile, level, namespace_, name_='Event', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EventType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            showIndent(outfile, level)
            outfile.write('idref=%s,\n' % (self.idref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.ControlledVocabularyStringType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observation_Method is not None:
            showIndent(outfile, level)
            outfile.write('Observation_Method=model_.MeasureSourceType(\n')
            self.Observation_Method.exportLiteral(outfile, level, name_='Observation_Method')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Actions is not None:
            showIndent(outfile, level)
            outfile.write('Actions=model_.ActionsType(\n')
            self.Actions.exportLiteral(outfile, level, name_='Actions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('Frequency=model_.FrequencyType(\n')
            self.Frequency.exportLiteral(outfile, level, name_='Frequency')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Event is not None:
            showIndent(outfile, level)
            outfile.write('Event=model_.EventType(\n')
            self.Event.exportLiteral(outfile, level, name_='Event')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Type = obj_
        elif nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Observation_Method':
            obj_ = MeasureSourceType.factory()
            obj_.build(child_)
            self.Observation_Method = obj_
        elif nodeName_ == 'Actions':
            obj_ = ActionsType.factory()
            obj_.build(child_)
            self.Actions = obj_
        elif nodeName_ == 'Frequency':
            obj_ = FrequencyType.factory()
            obj_.build(child_)
            self.Frequency = obj_
        elif nodeName_ == 'Event':
            obj_ = EventType.factory()
            obj_.build(child_)
            self.Event = obj_
# end class EventType


class FrequencyType(GeneratedsSuper):
    """The FrequencyType is a type representing the specification of a
    frequency for a given action or event.This field specifies the
    rate for this defined frequency.This field specifies the units
    for this defined frequency.This field specifies the time scale
    for this defined frequency.This field is optional and conveys a
    targeted observation pattern of the nature of any trend in the
    frequency of the associated event or action. This field would be
    leveraged within an event or action pattern observable
    triggering on the matching of a specified trend in the frequency
    of an event or action."""
    subclass = None
    superclass = None
    def __init__(self, units=None, trend=None, rate=None, scale=None):
        self.units = _cast(None, units)
        self.trend = _cast(None, trend)
        self.rate = _cast(float, rate)
        self.scale = _cast(None, scale)
        pass
    def factory(*args_, **kwargs_):
        if FrequencyType.subclass:
            return FrequencyType.subclass(*args_, **kwargs_)
        else:
            return FrequencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_trend(self): return self.trend
    def set_trend(self, trend): self.trend = trend
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def get_scale(self): return self.scale
    def set_scale(self, scale): self.scale = scale
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='FrequencyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='FrequencyType'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
        if self.trend is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            outfile.write(' trend=%s' % (quote_attrib(self.trend), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            outfile.write(' rate="%s"' % self.gds_format_float(self.rate, input_name='rate'))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale=%s' % (self.gds_format_string(quote_attrib(self.scale).encode(ExternalEncoding), input_name='scale'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='FrequencyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FrequencyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units="%s",\n' % (self.units,))
        if self.trend is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            showIndent(outfile, level)
            outfile.write('trend=%s,\n' % (self.trend,))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            showIndent(outfile, level)
            outfile.write('rate=%f,\n' % (self.rate,))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            showIndent(outfile, level)
            outfile.write('scale="%s",\n' % (self.scale,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
        value = find_attr_value_('trend', node)
        if value is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            self.trend = value
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            try:
                self.rate = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (rate): %s' % exp)
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            self.scale = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrequencyType


class ActionsType(GeneratedsSuper):
    """The ActionsType is a complex type representing a set of cyber
    observable actions."""
    subclass = None
    superclass = None
    def __init__(self, Action=None):
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
    def factory(*args_, **kwargs_):
        if ActionsType.subclass:
            return ActionsType.subclass(*args_, **kwargs_)
        else:
            return ActionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def hasContent_(self):
        if (
            self.Action
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_ in self.Action:
            Action_.export(outfile, level, namespace_='cybox:', name_='Action', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.Action(\n')
            Action_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            class_obj_ = self.get_class_obj_(child_, ActionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Action.append(obj_)
# end class ActionsType


class ActionType(GeneratedsSuper):
    """The ActionType is a complex type representing a single cyber
    observable action.The id field specifies a unique id for this
    Action.The idref field specifies a unique id reference to an
    Action defined elsewhere.The ordinal_position field is intended
    to reference the ordinal position of the action with within a
    series of actions.The action_status field enables description of
    the status of the action being described.The context field is
    optional and enables simple characterization of the broad
    operational context in which the Action is relevantThe timestamp
    field represents the local or relative time at which the action
    occurred or was observed."""
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, action_status=None, ordinal_position=None, context=None, idref=None, id=None, Type=None, Name=None, Description=None, Action_Aliases=None, Action_Arguments=None, Discovery_Method=None, Associated_Objects=None, Relationships=None, Frequency=None, extensiontype_=None):
        if isinstance(timestamp, basestring):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.action_status = _cast(None, action_status)
        self.ordinal_position = _cast(int, ordinal_position)
        self.context = _cast(None, context)
        self.idref = _cast(None, idref)
        self.id = _cast(None, id)
        self.Type = Type
        self.Name = Name
        self.Description = Description
        self.Action_Aliases = Action_Aliases
        self.Action_Arguments = Action_Arguments
        self.Discovery_Method = Discovery_Method
        self.Associated_Objects = Associated_Objects
        self.Relationships = Relationships
        self.Frequency = Frequency
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ActionType.subclass:
            return ActionType.subclass(*args_, **kwargs_)
        else:
            return ActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Action_Aliases(self): return self.Action_Aliases
    def set_Action_Aliases(self, Action_Aliases): self.Action_Aliases = Action_Aliases
    def get_Action_Arguments(self): return self.Action_Arguments
    def set_Action_Arguments(self, Action_Arguments): self.Action_Arguments = Action_Arguments
    def get_Discovery_Method(self): return self.Discovery_Method
    def set_Discovery_Method(self, Discovery_Method): self.Discovery_Method = Discovery_Method
    def get_Associated_Objects(self): return self.Associated_Objects
    def set_Associated_Objects(self, Associated_Objects): self.Associated_Objects = Associated_Objects
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_action_status(self): return self.action_status
    def set_action_status(self, action_status): self.action_status = action_status
    def get_ordinal_position(self): return self.ordinal_position
    def set_ordinal_position(self, ordinal_position): self.ordinal_position = ordinal_position
    def get_context(self): return self.context
    def set_context(self, context): self.context = context
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Name is not None or
            self.Description is not None or
            self.Action_Aliases is not None or
            self.Action_Arguments is not None or
            self.Discovery_Method is not None or
            self.Associated_Objects is not None or
            self.Relationships is not None or
            self.Frequency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionType'):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
        if self.action_status is not None and 'action_status' not in already_processed:
            already_processed.add('action_status')
            outfile.write(' action_status=%s' % (quote_attrib(self.action_status), ))
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            outfile.write(' ordinal_position="%s"' % self.gds_format_integer(self.ordinal_position, input_name='ordinal_position'))
        if self.context is not None and 'context' not in already_processed:
            already_processed.add('context')
            outfile.write(' context=%s' % (quote_attrib(self.context), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Action_Aliases is not None:
            self.Action_Aliases.export(outfile, level, namespace_, name_='Action_Aliases', pretty_print=pretty_print)
        if self.Action_Arguments is not None:
            self.Action_Arguments.export(outfile, level, namespace_, name_='Action_Arguments', pretty_print=pretty_print)
        if self.Discovery_Method is not None:
            self.Discovery_Method.export(outfile, level, namespace_, name_='Discovery_Method', pretty_print=pretty_print)
        if self.Associated_Objects is not None:
            self.Associated_Objects.export(outfile, level, namespace_, name_='Associated_Objects', pretty_print=pretty_print)
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, namespace_, name_='Relationships', pretty_print=pretty_print)
        if self.Frequency is not None:
            self.Frequency.export(outfile, level, namespace_, name_='Frequency', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
        if self.action_status is not None and 'action_status' not in already_processed:
            already_processed.add('action_status')
            showIndent(outfile, level)
            outfile.write('action_status=%s,\n' % (self.action_status,))
        if self.ordinal_position is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            showIndent(outfile, level)
            outfile.write('ordinal_position=%d,\n' % (self.ordinal_position,))
        if self.context is not None and 'context' not in already_processed:
            already_processed.add('context')
            showIndent(outfile, level)
            outfile.write('context=%s,\n' % (self.context,))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            showIndent(outfile, level)
            outfile.write('idref=%s,\n' % (self.idref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.ControlledVocabularyStringType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.ControlledVocabularyStringType(\n')
            self.Name.exportLiteral(outfile, level, name_='Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Aliases is not None:
            showIndent(outfile, level)
            outfile.write('Action_Aliases=model_.ActionAliasesType(\n')
            self.Action_Aliases.exportLiteral(outfile, level, name_='Action_Aliases')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Arguments is not None:
            showIndent(outfile, level)
            outfile.write('Action_Arguments=model_.ActionArgumentsType(\n')
            self.Action_Arguments.exportLiteral(outfile, level, name_='Action_Arguments')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('Discovery_Method=model_.MeasureSourceType(\n')
            self.Discovery_Method.exportLiteral(outfile, level, name_='Discovery_Method')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Associated_Objects is not None:
            showIndent(outfile, level)
            outfile.write('Associated_Objects=model_.AssociatedObjectsType(\n')
            self.Associated_Objects.exportLiteral(outfile, level, name_='Associated_Objects')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.RelationshipsType(\n')
            self.Relationships.exportLiteral(outfile, level, name_='Relationships')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('Frequency=model_.FrequencyType(\n')
            self.Frequency.exportLiteral(outfile, level, name_='Frequency')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
        value = find_attr_value_('action_status', node)
        if value is not None and 'action_status' not in already_processed:
            already_processed.add('action_status')
            self.action_status = value
        value = find_attr_value_('ordinal_position', node)
        if value is not None and 'ordinal_position' not in already_processed:
            already_processed.add('ordinal_position')
            try:
                self.ordinal_position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ordinal_position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('context', node)
        if value is not None and 'context' not in already_processed:
            already_processed.add('context')
            self.context = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Type = obj_
        elif nodeName_ == 'Name':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Name = obj_
        elif nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Action_Aliases':
            obj_ = ActionAliasesType.factory()
            obj_.build(child_)
            self.Action_Aliases = obj_
        elif nodeName_ == 'Action_Arguments':
            obj_ = ActionArgumentsType.factory()
            obj_.build(child_)
            self.Action_Arguments = obj_
        elif nodeName_ == 'Discovery_Method':
            obj_ = MeasureSourceType.factory()
            obj_.build(child_)
            self.Discovery_Method = obj_
        elif nodeName_ == 'Associated_Objects':
            obj_ = AssociatedObjectsType.factory()
            obj_.build(child_)
            self.Associated_Objects = obj_
        elif nodeName_ == 'Relationships':
            obj_ = RelationshipsType.factory()
            obj_.build(child_)
            self.Relationships = obj_
        elif nodeName_ == 'Frequency':
            obj_ = FrequencyType.factory()
            obj_.build(child_)
            self.Frequency = obj_
# end class ActionType


class ActionAliasesType(GeneratedsSuper):
    """The ActionAliasesType enables identification of other potentially
    used names for this Action."""
    subclass = None
    superclass = None
    def __init__(self, Action_Alias=None):
        if Action_Alias is None:
            self.Action_Alias = []
        else:
            self.Action_Alias = Action_Alias
    def factory(*args_, **kwargs_):
        if ActionAliasesType.subclass:
            return ActionAliasesType.subclass(*args_, **kwargs_)
        else:
            return ActionAliasesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Alias(self): return self.Action_Alias
    def set_Action_Alias(self, Action_Alias): self.Action_Alias = Action_Alias
    def add_Action_Alias(self, value): self.Action_Alias.append(value)
    def insert_Action_Alias(self, index, value): self.Action_Alias[index] = value
    def hasContent_(self):
        if (
            self.Action_Alias
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionAliasesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionAliasesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionAliasesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionAliasesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_Alias_ in self.Action_Alias:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAction_Alias>%s</%sAction_Alias>%s' % (namespace_, self.gds_format_string(quote_xml(Action_Alias_).encode(ExternalEncoding), input_name='Action_Alias'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ActionAliasesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Alias=[\n')
        level += 1
        for Action_Alias_ in self.Action_Alias:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Action_Alias_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Alias':
            Action_Alias_ = child_.text
            Action_Alias_ = self.gds_validate_string(Action_Alias_, node, 'Action_Alias')
            self.Action_Alias.append(Action_Alias_)
# end class ActionAliasesType


class ActionArgumentsType(GeneratedsSuper):
    """The ActionArgumentsType enables the specification of relevant
    arguments/parameters for this Action."""
    subclass = None
    superclass = None
    def __init__(self, Action_Argument=None):
        if Action_Argument is None:
            self.Action_Argument = []
        else:
            self.Action_Argument = Action_Argument
    def factory(*args_, **kwargs_):
        if ActionArgumentsType.subclass:
            return ActionArgumentsType.subclass(*args_, **kwargs_)
        else:
            return ActionArgumentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_Argument(self): return self.Action_Argument
    def set_Action_Argument(self, Action_Argument): self.Action_Argument = Action_Argument
    def add_Action_Argument(self, value): self.Action_Argument.append(value)
    def insert_Action_Argument(self, index, value): self.Action_Argument[index] = value
    def hasContent_(self):
        if (
            self.Action_Argument
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionArgumentsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionArgumentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionArgumentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionArgumentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_Argument_ in self.Action_Argument:
            Action_Argument_.export(outfile, level, namespace_, name_='Action_Argument', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionArgumentsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action_Argument=[\n')
        level += 1
        for Action_Argument_ in self.Action_Argument:
            showIndent(outfile, level)
            outfile.write('model_.ActionArgumentType(\n')
            Action_Argument_.exportLiteral(outfile, level, name_='ActionArgumentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_Argument':
            obj_ = ActionArgumentType.factory()
            obj_.build(child_)
            self.Action_Argument.append(obj_)
# end class ActionArgumentsType


class ActionArgumentType(GeneratedsSuper):
    """The ActionArgumentType enables the specification of a single
    relevant argument/parameter for this Action."""
    subclass = None
    superclass = None
    def __init__(self, Argument_Name=None, Argument_Value=None):
        self.Argument_Name = Argument_Name
        self.Argument_Value = Argument_Value
    def factory(*args_, **kwargs_):
        if ActionArgumentType.subclass:
            return ActionArgumentType.subclass(*args_, **kwargs_)
        else:
            return ActionArgumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Argument_Name(self): return self.Argument_Name
    def set_Argument_Name(self, Argument_Name): self.Argument_Name = Argument_Name
    def get_Argument_Value(self): return self.Argument_Value
    def set_Argument_Value(self, Argument_Value): self.Argument_Value = Argument_Value
    def hasContent_(self):
        if (
            self.Argument_Name is not None or
            self.Argument_Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionArgumentType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionArgumentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionArgumentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Argument_Name is not None:
            self.Argument_Name.export(outfile, level, namespace_, name_='Argument_Name', pretty_print=pretty_print)
        if self.Argument_Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sArgument_Value>%s</%sArgument_Value>%s' % (namespace_, self.gds_format_string(quote_xml(self.Argument_Value).encode(ExternalEncoding), input_name='Argument_Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ActionArgumentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Argument_Name is not None:
            showIndent(outfile, level)
            outfile.write('Argument_Name=model_.ControlledVocabularyStringType(\n')
            self.Argument_Name.exportLiteral(outfile, level, name_='Argument_Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Argument_Value is not None:
            showIndent(outfile, level)
            outfile.write('Argument_Value=%s,\n' % quote_python(self.Argument_Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Argument_Name':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Argument_Name = obj_
        elif nodeName_ == 'Argument_Value':
            Argument_Value_ = child_.text
            Argument_Value_ = self.gds_validate_string(Argument_Value_, node, 'Argument_Value')
            self.Argument_Value = Argument_Value_
# end class ActionArgumentType


class AssociatedObjectsType(GeneratedsSuper):
    """The AssociatedObjectsType enables the description/specification of
    cyber Objects relevant to an Action."""
    subclass = None
    superclass = None
    def __init__(self, Associated_Object=None):
        if Associated_Object is None:
            self.Associated_Object = []
        else:
            self.Associated_Object = Associated_Object
    def factory(*args_, **kwargs_):
        if AssociatedObjectsType.subclass:
            return AssociatedObjectsType.subclass(*args_, **kwargs_)
        else:
            return AssociatedObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Associated_Object(self): return self.Associated_Object
    def set_Associated_Object(self, Associated_Object): self.Associated_Object = Associated_Object
    def add_Associated_Object(self, value): self.Associated_Object.append(value)
    def insert_Associated_Object(self, index, value): self.Associated_Object[index] = value
    def hasContent_(self):
        if (
            self.Associated_Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='AssociatedObjectsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedObjectsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='AssociatedObjectsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='AssociatedObjectsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Associated_Object_ in self.Associated_Object:
            Associated_Object_.export(outfile, level, namespace_, name_='Associated_Object', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AssociatedObjectsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Associated_Object=[\n')
        level += 1
        for Associated_Object_ in self.Associated_Object:
            showIndent(outfile, level)
            outfile.write('model_.AssociatedObjectType(\n')
            Associated_Object_.exportLiteral(outfile, level, name_='AssociatedObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Associated_Object':
            obj_ = AssociatedObjectType.factory()
            obj_.build(child_)
            self.Associated_Object.append(obj_)
# end class AssociatedObjectsType


class ActionPertinentObjectPropertiesType(GeneratedsSuper):
    """The ActionPertinentObjectPropertiesType identifies which of the
    Properties of this Object are specifically pertinent to this
    Action."""
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if ActionPertinentObjectPropertiesType.subclass:
            return ActionPertinentObjectPropertiesType.subclass(*args_, **kwargs_)
        else:
            return ActionPertinentObjectPropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionPertinentObjectPropertiesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionPertinentObjectPropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionPertinentObjectPropertiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionPertinentObjectPropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionPertinentObjectPropertiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.ActionPertinentObjectPropertyType(\n')
            Property_.exportLiteral(outfile, level, name_='ActionPertinentObjectPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = ActionPertinentObjectPropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
# end class ActionPertinentObjectPropertiesType


class ActionPertinentObjectPropertyType(GeneratedsSuper):
    """The ActionPertinentObjectPropertyType identifies one of the
    Properties of an Object that specifically pertinent to an
    Action.The name field specifies the field name for the pertinent
    Object Property.The xpath field specifies the XPath 1.0
    expression identifying the pertinent property within the
    Properties schema for this object type."""
    subclass = None
    superclass = None
    def __init__(self, xpath=None, name=None):
        self.xpath = _cast(None, xpath)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if ActionPertinentObjectPropertyType.subclass:
            return ActionPertinentObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return ActionPertinentObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xpath(self): return self.xpath
    def set_xpath(self, xpath): self.xpath = xpath
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionPertinentObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionPertinentObjectPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionPertinentObjectPropertyType'):
        if self.xpath is not None and 'xpath' not in already_processed:
            already_processed.add('xpath')
            outfile.write(' xpath=%s' % (self.gds_format_string(quote_attrib(self.xpath).encode(ExternalEncoding), input_name='xpath'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionPertinentObjectPropertyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ActionPertinentObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.xpath is not None and 'xpath' not in already_processed:
            already_processed.add('xpath')
            showIndent(outfile, level)
            outfile.write('xpath="%s",\n' % (self.xpath,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xpath', node)
        if value is not None and 'xpath' not in already_processed:
            already_processed.add('xpath')
            self.xpath = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionPertinentObjectPropertyType


class RelationshipsType(GeneratedsSuper):
    """The RelationshipsType enables description of other cyber observable
    actions that are related to this Action."""
    subclass = None
    superclass = None
    def __init__(self, Relationship=None):
        if Relationship is None:
            self.Relationship = []
        else:
            self.Relationship = Relationship
    def factory(*args_, **kwargs_):
        if RelationshipsType.subclass:
            return RelationshipsType.subclass(*args_, **kwargs_)
        else:
            return RelationshipsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def add_Relationship(self, value): self.Relationship.append(value)
    def insert_Relationship(self, index, value): self.Relationship[index] = value
    def hasContent_(self):
        if (
            self.Relationship
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='RelationshipsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationshipsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='RelationshipsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='RelationshipsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relationship_ in self.Relationship:
            Relationship_.export(outfile, level, namespace_, name_='Relationship', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelationshipsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship=[\n')
        level += 1
        for Relationship_ in self.Relationship:
            showIndent(outfile, level)
            outfile.write('model_.ActionRelationshipType(\n')
            Relationship_.exportLiteral(outfile, level, name_='ActionRelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship':
            obj_ = ActionRelationshipType.factory()
            obj_.build(child_)
            self.Relationship.append(obj_)
# end class RelationshipsType


class ActionRelationshipType(GeneratedsSuper):
    """The ActionRelationshipType characterizes a relationship between a
    specified cyber observable action and another cyber observable
    action."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Action_Reference=None):
        self.Type = Type
        if Action_Reference is None:
            self.Action_Reference = []
        else:
            self.Action_Reference = Action_Reference
    def factory(*args_, **kwargs_):
        if ActionRelationshipType.subclass:
            return ActionRelationshipType.subclass(*args_, **kwargs_)
        else:
            return ActionRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Action_Reference(self): return self.Action_Reference
    def set_Action_Reference(self, Action_Reference): self.Action_Reference = Action_Reference
    def add_Action_Reference(self, value): self.Action_Reference.append(value)
    def insert_Action_Reference(self, index, value): self.Action_Reference[index] = value
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Action_Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionRelationshipType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionRelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionRelationshipType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionRelationshipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        for Action_Reference_ in self.Action_Reference:
            Action_Reference_.export(outfile, level, namespace_, name_='Action_Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionRelationshipType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.ControlledVocabularyStringType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Action_Reference=[\n')
        level += 1
        for Action_Reference_ in self.Action_Reference:
            showIndent(outfile, level)
            outfile.write('model_.ActionReferenceType(\n')
            Action_Reference_.exportLiteral(outfile, level, name_='ActionReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Type = obj_
        elif nodeName_ == 'Action_Reference':
            class_obj_ = self.get_class_obj_(child_, ActionReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Action_Reference.append(obj_)
# end class ActionRelationshipType


class ActionReferenceType(GeneratedsSuper):
    """ActionReferenceType is intended to serve as a method for linking to
    actions.The action_id field refers to the id of the action being
    referenced."""
    subclass = None
    superclass = None
    def __init__(self, action_id=None, extensiontype_=None):
        self.action_id = _cast(None, action_id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ActionReferenceType.subclass:
            return ActionReferenceType.subclass(*args_, **kwargs_)
        else:
            return ActionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action_id(self): return self.action_id
    def set_action_id(self, action_id): self.action_id = action_id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionReferenceType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionReferenceType'):
        if self.action_id is not None and 'action_id' not in already_processed:
            already_processed.add('action_id')
            outfile.write(' action_id=%s' % (quote_attrib(self.action_id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ActionReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action_id is not None and 'action_id' not in already_processed:
            already_processed.add('action_id')
            showIndent(outfile, level)
            outfile.write('action_id=%s,\n' % (self.action_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action_id', node)
        if value is not None and 'action_id' not in already_processed:
            already_processed.add('action_id')
            self.action_id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionReferenceType


class ObjectType(GeneratedsSuper):
    """The ObjectType is a complex type representing the characteristics of
    a specific cyber-relevant object (e.g. a file, a registry key or
    a process). The id field specifies a unique id for this
    Object.The idref field specifies a unique id reference to an
    Object defined elsewhere.The has_changed field is optional and
    conveys a targeted observation pattern of whether the associated
    object specified has changed. This field would be leveraged
    within a pattern observable triggering on whether the value of
    an object specification has changed."""
    subclass = None
    superclass = None
    def __init__(self, has_changed=None, idref=None, id=None, State=None, Description=None, Properties=None, Domain_Specific_Object_Properties=None, Related_Objects=None, Defined_Effect=None, Discovery_Method=None, extensiontype_=None):
        self.has_changed = _cast(bool, has_changed)
        self.idref = _cast(None, idref)
        self.id = _cast(None, id)
        self.State = State
        self.Description = Description
        self.Properties = Properties
        self.Domain_Specific_Object_Properties = Domain_Specific_Object_Properties
        self.Related_Objects = Related_Objects
        self.Defined_Effect = Defined_Effect
        self.Discovery_Method = Discovery_Method
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_State(self): return self.State
    def set_State(self, State): self.State = State
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    def get_Domain_Specific_Object_Properties(self): return self.Domain_Specific_Object_Properties
    def set_Domain_Specific_Object_Properties(self, Domain_Specific_Object_Properties): self.Domain_Specific_Object_Properties = Domain_Specific_Object_Properties
    def get_Related_Objects(self): return self.Related_Objects
    def set_Related_Objects(self, Related_Objects): self.Related_Objects = Related_Objects
    def get_Defined_Effect(self): return self.Defined_Effect
    def set_Defined_Effect(self, Defined_Effect): self.Defined_Effect = Defined_Effect
    def get_Discovery_Method(self): return self.Discovery_Method
    def set_Discovery_Method(self, Discovery_Method): self.Discovery_Method = Discovery_Method
    def get_has_changed(self): return self.has_changed
    def set_has_changed(self, has_changed): self.has_changed = has_changed
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.State is not None or
            self.Description is not None or
            self.Properties is not None or
            self.Domain_Specific_Object_Properties is not None or
            self.Related_Objects is not None or
            self.Defined_Effect is not None or
            self.Discovery_Method is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectType'):
        if self.has_changed is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            outfile.write(' has_changed="%s"' % self.gds_format_boolean(self.has_changed, input_name='has_changed'))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.State is not None:
            self.State.export(outfile, level, namespace_, name_='State', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', pretty_print=pretty_print)
        if self.Domain_Specific_Object_Properties is not None:
            self.Domain_Specific_Object_Properties.export(outfile, level, namespace_, name_='Domain_Specific_Object_Properties', pretty_print=pretty_print)
        if self.Related_Objects is not None:
            self.Related_Objects.export(outfile, level, namespace_, name_='Related_Objects', pretty_print=pretty_print)
        if self.Defined_Effect is not None:
            self.Defined_Effect.export(outfile, level, namespace_, name_='Defined_Effect', pretty_print=pretty_print)
        if self.Discovery_Method is not None:
            self.Discovery_Method.export(outfile, level, namespace_, name_='Discovery_Method', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.has_changed is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            showIndent(outfile, level)
            outfile.write('has_changed=%s,\n' % (self.has_changed,))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            showIndent(outfile, level)
            outfile.write('idref=%s,\n' % (self.idref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.State is not None:
            showIndent(outfile, level)
            outfile.write('State=model_.ControlledVocabularyStringType(\n')
            self.State.exportLiteral(outfile, level, name_='State')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectPropertiesType is not None:
            showIndent(outfile, level)
            outfile.write('ObjectPropertiesType=model_.ObjectPropertiesType(\n')
            self.ObjectPropertiesType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DomainSpecificObjectPropertiesType is not None:
            showIndent(outfile, level)
            outfile.write('DomainSpecificObjectPropertiesType=model_.DomainSpecificObjectPropertiesType(\n')
            self.DomainSpecificObjectPropertiesType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Objects is not None:
            showIndent(outfile, level)
            outfile.write('Related_Objects=model_.RelatedObjectsType(\n')
            self.Related_Objects.exportLiteral(outfile, level, name_='Related_Objects')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DefinedEffectType is not None:
            showIndent(outfile, level)
            outfile.write('DefinedEffectType=model_.DefinedEffectType(\n')
            self.DefinedEffectType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('Discovery_Method=model_.MeasureSourceType(\n')
            self.Discovery_Method.exportLiteral(outfile, level, name_='Discovery_Method')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('has_changed', node)
        if value is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            if value in ('true', '1'):
                self.has_changed = True
            elif value in ('false', '0'):
                self.has_changed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'State':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.State = obj_
        elif nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Properties':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Properties> element')
            self.Properties = obj_
        elif nodeName_ == 'Domain_Specific_Object_Properties':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Domain_Specific_Object_Properties> element')
            self.Domain_Specific_Object_Properties = obj_
        elif nodeName_ == 'Related_Objects':
            obj_ = RelatedObjectsType.factory()
            obj_.build(child_)
            self.Related_Objects = obj_
        elif nodeName_ == 'Defined_Effect':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Defined_Effect> element')
            self.Defined_Effect = obj_
        elif nodeName_ == 'Discovery_Method':
            obj_ = MeasureSourceType.factory()
            obj_.build(child_)
            self.Discovery_Method = obj_
# end class ObjectType


class DomainSpecificObjectPropertiesType(GeneratedsSuper):
    """The DomainSpecificObjectPropertiesType is an abstract type
    placeholder within the CybOX schema enabling the inclusion of
    domain-specific metadata for an object through the use of a
    custom type defined as an extension of this base Abstract type.
    This enables domains utilizing CybOX such as malware analysis or
    forensics to incorporate non-generalized object metadata from
    their domains into CybOX objects."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DomainSpecificObjectPropertiesType.subclass:
            return DomainSpecificObjectPropertiesType.subclass(*args_, **kwargs_)
        else:
            return DomainSpecificObjectPropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DomainSpecificObjectPropertiesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomainSpecificObjectPropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DomainSpecificObjectPropertiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DomainSpecificObjectPropertiesType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DomainSpecificObjectPropertiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DomainSpecificObjectPropertiesType


class RelatedObjectsType(GeneratedsSuper):
    """The RelatedObjectsType enables the identification and/or
    specification of Objects with relevant relationships with this
    Object."""
    subclass = None
    superclass = None
    def __init__(self, Related_Object=None):
        if Related_Object is None:
            self.Related_Object = []
        else:
            self.Related_Object = Related_Object
    def factory(*args_, **kwargs_):
        if RelatedObjectsType.subclass:
            return RelatedObjectsType.subclass(*args_, **kwargs_)
        else:
            return RelatedObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Object(self): return self.Related_Object
    def set_Related_Object(self, Related_Object): self.Related_Object = Related_Object
    def add_Related_Object(self, value): self.Related_Object.append(value)
    def insert_Related_Object(self, index, value): self.Related_Object[index] = value
    def hasContent_(self):
        if (
            self.Related_Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='RelatedObjectsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedObjectsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='RelatedObjectsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='RelatedObjectsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Related_Object_ in self.Related_Object:
            Related_Object_.export(outfile, level, namespace_, name_='Related_Object', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelatedObjectsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Related_Object=[\n')
        level += 1
        for Related_Object_ in self.Related_Object:
            showIndent(outfile, level)
            outfile.write('model_.RelatedObjectType(\n')
            Related_Object_.exportLiteral(outfile, level, name_='RelatedObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Object':
            obj_ = RelatedObjectType.factory()
            obj_.build(child_)
            self.Related_Object.append(obj_)
# end class RelatedObjectsType


class RelatedObjectType(ObjectType):
    """The RelatedObjectType enables the identification and/or
    specification of an Object with a relevant relationship with
    this Object."""
    subclass = None
    superclass = ObjectType
    def __init__(self, has_changed=None, idref=None, id=None, State=None, Description=None, Properties=None, Domain_Specific_Object_Properties=None, Related_Objects=None, Defined_Effect=None, Discovery_Method=None, Relationship=None):
        super(RelatedObjectType, self).__init__(has_changed, idref, id, State, Description, Properties, Domain_Specific_Object_Properties, Related_Objects, Defined_Effect, Discovery_Method, )
        self.Relationship = Relationship
    def factory(*args_, **kwargs_):
        if RelatedObjectType.subclass:
            return RelatedObjectType.subclass(*args_, **kwargs_)
        else:
            return RelatedObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def hasContent_(self):
        if (
            self.Relationship is not None or
            super(RelatedObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='RelatedObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='RelatedObjectType'):
        super(RelatedObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedObjectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='RelatedObjectType', fromsubclass_=False, pretty_print=True):
        super(RelatedObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Relationship is not None:
            self.Relationship.export(outfile, level, namespace_, name_='Relationship', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelatedObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RelatedObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RelatedObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Relationship is not None:
            showIndent(outfile, level)
            outfile.write('Relationship=model_.ControlledVocabularyStringType(\n')
            self.Relationship.exportLiteral(outfile, level, name_='Relationship')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RelatedObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Relationship = obj_
        super(RelatedObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class RelatedObjectType


class DefinedEffectType(GeneratedsSuper):
    """The DefinedEffectType is an abstract placeholder for various
    predefined Object Effect types (e.g. DataReadEffect,
    ValuesEnumeratedEffect or StateChangeEffect) that can be
    instantiated in its place through extension of the
    DefinedEffectType. This mechanism enables the specification of a
    broad range of types of potential complex action effects on
    Objects. The set of Defined_Effect types (extending the
    DefinedEffectType) are maintained as part of the core CybOX
    schema.The effect_type field specifies the nature of the Defined
    Effect instantiated in the place of the Defined_Effect element."""
    subclass = None
    superclass = None
    def __init__(self, effect_type=None, extensiontype_=None):
        self.effect_type = _cast(None, effect_type)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DefinedEffectType.subclass:
            return DefinedEffectType.subclass(*args_, **kwargs_)
        else:
            return DefinedEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_effect_type(self): return self.effect_type
    def set_effect_type(self, effect_type): self.effect_type = effect_type
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DefinedEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinedEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DefinedEffectType'):
        if self.effect_type is not None and 'effect_type' not in already_processed:
            already_processed.add('effect_type')
            outfile.write(' effect_type=%s' % (quote_attrib(self.effect_type), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DefinedEffectType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DefinedEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.effect_type is not None and 'effect_type' not in already_processed:
            already_processed.add('effect_type')
            showIndent(outfile, level)
            outfile.write('effect_type=%s,\n' % (self.effect_type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('effect_type', node)
        if value is not None and 'effect_type' not in already_processed:
            already_processed.add('effect_type')
            self.effect_type = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DefinedEffectType


class StateChangeEffectType(DefinedEffectType):
    """The StateChangeEffectType is intended as a generic way of
    characterizing the effects of actions upon objects where the
    some state of the object is changed."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Old_Object=None, New_Object=None):
        super(StateChangeEffectType, self).__init__(effect_type, )
        self.Old_Object = Old_Object
        self.New_Object = New_Object
    def factory(*args_, **kwargs_):
        if StateChangeEffectType.subclass:
            return StateChangeEffectType.subclass(*args_, **kwargs_)
        else:
            return StateChangeEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Old_Object(self): return self.Old_Object
    def set_Old_Object(self, Old_Object): self.Old_Object = Old_Object
    def get_New_Object(self): return self.New_Object
    def set_New_Object(self, New_Object): self.New_Object = New_Object
    def hasContent_(self):
        if (
            self.Old_Object is not None or
            self.New_Object is not None or
            super(StateChangeEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='StateChangeEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateChangeEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='StateChangeEffectType'):
        super(StateChangeEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StateChangeEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='StateChangeEffectType', fromsubclass_=False, pretty_print=True):
        super(StateChangeEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Old_Object is not None:
            self.Old_Object.export(outfile, level, namespace_, name_='Old_Object', pretty_print=pretty_print)
        if self.New_Object is not None:
            self.New_Object.export(outfile, level, namespace_, name_='New_Object', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StateChangeEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StateChangeEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StateChangeEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Old_Object is not None:
            showIndent(outfile, level)
            outfile.write('Old_Object=model_.ObjectType(\n')
            self.Old_Object.exportLiteral(outfile, level, name_='Old_Object')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.New_Object is not None:
            showIndent(outfile, level)
            outfile.write('New_Object=model_.ObjectType(\n')
            self.New_Object.exportLiteral(outfile, level, name_='New_Object')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StateChangeEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Old_Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Old_Object = obj_
        elif nodeName_ == 'New_Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.New_Object = obj_
        super(StateChangeEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class StateChangeEffectType


class DataReadEffectType(DefinedEffectType):
    """The DataReadEffectType type is intended to characterize the effects
    of actions upon objects where some data is read, such as from a
    file or a pipe."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Data=None):
        super(DataReadEffectType, self).__init__(effect_type, )
        self.Data = Data
    def factory(*args_, **kwargs_):
        if DataReadEffectType.subclass:
            return DataReadEffectType.subclass(*args_, **kwargs_)
        else:
            return DataReadEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def hasContent_(self):
        if (
            self.Data is not None or
            super(DataReadEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DataReadEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataReadEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DataReadEffectType'):
        super(DataReadEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataReadEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DataReadEffectType', fromsubclass_=False, pretty_print=True):
        super(DataReadEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Data is not None:
            self.Data.export(outfile, level, namespace_, name_='Data', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataReadEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DataReadEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataReadEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=model_.DataSegmentType(\n')
            self.Data.exportLiteral(outfile, level, name_='Data')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataReadEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            obj_ = DataSegmentType.factory()
            obj_.build(child_)
            self.Data = obj_
        super(DataReadEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class DataReadEffectType


class DataWrittenEffectType(DefinedEffectType):
    """The DataWrittenEffectType type is intended to characterize the
    effects of actions upon objects where some data is written, such
    as to a file or a pipe."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Data=None):
        super(DataWrittenEffectType, self).__init__(effect_type, )
        self.Data = Data
    def factory(*args_, **kwargs_):
        if DataWrittenEffectType.subclass:
            return DataWrittenEffectType.subclass(*args_, **kwargs_)
        else:
            return DataWrittenEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def hasContent_(self):
        if (
            self.Data is not None or
            super(DataWrittenEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DataWrittenEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataWrittenEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DataWrittenEffectType'):
        super(DataWrittenEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataWrittenEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DataWrittenEffectType', fromsubclass_=False, pretty_print=True):
        super(DataWrittenEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Data is not None:
            self.Data.export(outfile, level, namespace_, name_='Data', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataWrittenEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DataWrittenEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataWrittenEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=model_.DataSegmentType(\n')
            self.Data.exportLiteral(outfile, level, name_='Data')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataWrittenEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            obj_ = DataSegmentType.factory()
            obj_.build(child_)
            self.Data = obj_
        super(DataWrittenEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class DataWrittenEffectType


class DataSentEffectType(DefinedEffectType):
    """The DataSentEffectType type is intended to characterize the effects
    of actions upon objects where some data is sent, such as a byte
    sequence on a socket."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Data=None):
        super(DataSentEffectType, self).__init__(effect_type, )
        self.Data = Data
    def factory(*args_, **kwargs_):
        if DataSentEffectType.subclass:
            return DataSentEffectType.subclass(*args_, **kwargs_)
        else:
            return DataSentEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def hasContent_(self):
        if (
            self.Data is not None or
            super(DataSentEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DataSentEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSentEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DataSentEffectType'):
        super(DataSentEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataSentEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DataSentEffectType', fromsubclass_=False, pretty_print=True):
        super(DataSentEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Data is not None:
            self.Data.export(outfile, level, namespace_, name_='Data', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataSentEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DataSentEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataSentEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=model_.DataSegmentType(\n')
            self.Data.exportLiteral(outfile, level, name_='Data')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataSentEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            obj_ = DataSegmentType.factory()
            obj_.build(child_)
            self.Data = obj_
        super(DataSentEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class DataSentEffectType


class DataReceivedEffectType(DefinedEffectType):
    """The DataReceivedEffectType type is intended to characterize the
    effects of actions upon objects where some data is received,
    such as a byte sequence on a socket."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Data=None):
        super(DataReceivedEffectType, self).__init__(effect_type, )
        self.Data = Data
    def factory(*args_, **kwargs_):
        if DataReceivedEffectType.subclass:
            return DataReceivedEffectType.subclass(*args_, **kwargs_)
        else:
            return DataReceivedEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data(self): return self.Data
    def set_Data(self, Data): self.Data = Data
    def hasContent_(self):
        if (
            self.Data is not None or
            super(DataReceivedEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DataReceivedEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataReceivedEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DataReceivedEffectType'):
        super(DataReceivedEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataReceivedEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DataReceivedEffectType', fromsubclass_=False, pretty_print=True):
        super(DataReceivedEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Data is not None:
            self.Data.export(outfile, level, namespace_, name_='Data', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataReceivedEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DataReceivedEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataReceivedEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Data is not None:
            showIndent(outfile, level)
            outfile.write('Data=model_.DataSegmentType(\n')
            self.Data.exportLiteral(outfile, level, name_='Data')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataReceivedEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data':
            obj_ = DataSegmentType.factory()
            obj_.build(child_)
            self.Data = obj_
        super(DataReceivedEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class DataReceivedEffectType


class PropertyReadEffectType(DefinedEffectType):
    """The PropertyReadEffectType type is intended to characterize the
    effects of actions upon objects where some specific property is
    read from an object, such as the current running state of a
    process."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Name=None, Value=None):
        super(PropertyReadEffectType, self).__init__(effect_type, )
        self.Name = Name
        self.Value = Value
    def factory(*args_, **kwargs_):
        if PropertyReadEffectType.subclass:
            return PropertyReadEffectType.subclass(*args_, **kwargs_)
        else:
            return PropertyReadEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Value is not None or
            super(PropertyReadEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PropertyReadEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyReadEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PropertyReadEffectType'):
        super(PropertyReadEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyReadEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PropertyReadEffectType', fromsubclass_=False, pretty_print=True):
        super(PropertyReadEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PropertyReadEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PropertyReadEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PropertyReadEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PropertyReadEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(PropertyReadEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class PropertyReadEffectType


class PropertiesEnumeratedEffectType(DefinedEffectType):
    """The PropertiesEnumeratedEffectType type is intended to characterize
    the effects of actions upon objects where some properties of the
    object are enumerated, such as the startup parameters for a
    process."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Properties=None):
        super(PropertiesEnumeratedEffectType, self).__init__(effect_type, )
        self.Properties = Properties
    def factory(*args_, **kwargs_):
        if PropertiesEnumeratedEffectType.subclass:
            return PropertiesEnumeratedEffectType.subclass(*args_, **kwargs_)
        else:
            return PropertiesEnumeratedEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Properties(self): return self.Properties
    def set_Properties(self, Properties): self.Properties = Properties
    def hasContent_(self):
        if (
            self.Properties is not None or
            super(PropertiesEnumeratedEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PropertiesEnumeratedEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertiesEnumeratedEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PropertiesEnumeratedEffectType'):
        super(PropertiesEnumeratedEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertiesEnumeratedEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PropertiesEnumeratedEffectType', fromsubclass_=False, pretty_print=True):
        super(PropertiesEnumeratedEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Properties is not None:
            self.Properties.export(outfile, level, namespace_, name_='Properties', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertiesEnumeratedEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PropertiesEnumeratedEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PropertiesEnumeratedEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Properties is not None:
            showIndent(outfile, level)
            outfile.write('Properties=model_.PropertiesType(\n')
            self.Properties.exportLiteral(outfile, level, name_='Properties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PropertiesEnumeratedEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Properties':
            obj_ = PropertiesType.factory()
            obj_.build(child_)
            self.Properties = obj_
        super(PropertiesEnumeratedEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class PropertiesEnumeratedEffectType


class PropertiesType(GeneratedsSuper):
    """The PropertiesType specifies the properties that were enumerated as
    a result of the action on the object."""
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if PropertiesType.subclass:
            return PropertiesType.subclass(*args_, **kwargs_)
        else:
            return PropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PropertiesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PropertiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProperty>%s</%sProperty>%s' % (namespace_, self.gds_format_string(quote_xml(Property_).encode(ExternalEncoding), input_name='Property'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PropertiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Property_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            Property_ = child_.text
            Property_ = self.gds_validate_string(Property_, node, 'Property')
            self.Property.append(Property_)
# end class PropertiesType


class ValuesEnumeratedEffectType(DefinedEffectType):
    """The ValuesEnumeratedEffectType type is intended to characterize the
    effects of actions upon objects where some values of the object
    are enumerated, such as the values of a registry key."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Values=None):
        super(ValuesEnumeratedEffectType, self).__init__(effect_type, )
        self.Values = Values
    def factory(*args_, **kwargs_):
        if ValuesEnumeratedEffectType.subclass:
            return ValuesEnumeratedEffectType.subclass(*args_, **kwargs_)
        else:
            return ValuesEnumeratedEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Values(self): return self.Values
    def set_Values(self, Values): self.Values = Values
    def hasContent_(self):
        if (
            self.Values is not None or
            super(ValuesEnumeratedEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ValuesEnumeratedEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuesEnumeratedEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ValuesEnumeratedEffectType'):
        super(ValuesEnumeratedEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ValuesEnumeratedEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ValuesEnumeratedEffectType', fromsubclass_=False, pretty_print=True):
        super(ValuesEnumeratedEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Values is not None:
            self.Values.export(outfile, level, namespace_, name_='Values', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ValuesEnumeratedEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ValuesEnumeratedEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ValuesEnumeratedEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Values is not None:
            showIndent(outfile, level)
            outfile.write('Values=model_.ValuesType(\n')
            self.Values.exportLiteral(outfile, level, name_='Values')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ValuesEnumeratedEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Values':
            obj_ = ValuesType.factory()
            obj_.build(child_)
            self.Values = obj_
        super(ValuesEnumeratedEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class ValuesEnumeratedEffectType


class ValuesType(GeneratedsSuper):
    """The ValuesType specifies the values that were enumerated as a result
    of the action on the object."""
    subclass = None
    superclass = None
    def __init__(self, Value=None):
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if ValuesType.subclass:
            return ValuesType.subclass(*args_, **kwargs_)
        else:
            return ValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def hasContent_(self):
        if (
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ValuesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Value_ in self.Value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ValuesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
# end class ValuesType


class SendControlCodeEffectType(DefinedEffectType):
    """The SendControlCodeEffectType is intended to characterize the
    effects of actions upon objects where some control code, or
    other control-oriented communication signal, is sent to the
    object. For example, an action may send a control code to change
    the running state of a process."""
    subclass = None
    superclass = DefinedEffectType
    def __init__(self, effect_type=None, Control_Code=None):
        super(SendControlCodeEffectType, self).__init__(effect_type, )
        self.Control_Code = Control_Code
    def factory(*args_, **kwargs_):
        if SendControlCodeEffectType.subclass:
            return SendControlCodeEffectType.subclass(*args_, **kwargs_)
        else:
            return SendControlCodeEffectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Control_Code(self): return self.Control_Code
    def set_Control_Code(self, Control_Code): self.Control_Code = Control_Code
    def hasContent_(self):
        if (
            self.Control_Code is not None or
            super(SendControlCodeEffectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='SendControlCodeEffectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SendControlCodeEffectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='SendControlCodeEffectType'):
        super(SendControlCodeEffectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SendControlCodeEffectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='SendControlCodeEffectType', fromsubclass_=False, pretty_print=True):
        super(SendControlCodeEffectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Control_Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControl_Code>%s</%sControl_Code>%s' % (namespace_, self.gds_format_string(quote_xml(self.Control_Code).encode(ExternalEncoding), input_name='Control_Code'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SendControlCodeEffectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SendControlCodeEffectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SendControlCodeEffectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Control_Code is not None:
            showIndent(outfile, level)
            outfile.write('Control_Code=%s,\n' % quote_python(self.Control_Code).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SendControlCodeEffectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Control_Code':
            Control_Code_ = child_.text
            Control_Code_ = self.gds_validate_string(Control_Code_, node, 'Control_Code')
            self.Control_Code = Control_Code_
        super(SendControlCodeEffectType, self).buildChildren(child_, node, nodeName_, True)
# end class SendControlCodeEffectType


class ObservableCompositionType(GeneratedsSuper):
    """The ObservablesCompositionType enables the specification of higher-
    order composite observables composed of logical combinations of
    other observables.The operator field enables the specification
    of complex compositional cyber observables by providing logical
    operators for defining interrelationships between constituent
    cyber observables defined utilizing the recursive Observable
    element."""
    subclass = None
    superclass = None
    def __init__(self, operator=None, Observable=None):
        self.operator = _cast(None, operator)
        if Observable is None:
            self.Observable = []
        else:
            self.Observable = Observable
    def factory(*args_, **kwargs_):
        if ObservableCompositionType.subclass:
            return ObservableCompositionType.subclass(*args_, **kwargs_)
        else:
            return ObservableCompositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Observable(self): return self.Observable
    def set_Observable(self, Observable): self.Observable = Observable
    def add_Observable(self, value): self.Observable.append(value)
    def insert_Observable(self, index, value): self.Observable[index] = value
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def hasContent_(self):
        if (
            self.Observable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObservableCompositionType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservableCompositionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObservableCompositionType'):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObservableCompositionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Observable_ in self.Observable:
            Observable_.export(outfile, level, namespace_, name_='Observable', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObservableCompositionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            showIndent(outfile, level)
            outfile.write('operator=%s,\n' % (self.operator,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Observable=[\n')
        level += 1
        for Observable_ in self.Observable:
            showIndent(outfile, level)
            outfile.write('model_.ObservableType(\n')
            Observable_.exportLiteral(outfile, level, name_='ObservableType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Observable':
            obj_ = ObservableType.factory()
            obj_.build(child_)
            self.Observable.append(obj_)
# end class ObservableCompositionType


class PoolsType(GeneratedsSuper):
    """The PoolsType enables the description of Events, Actions, Objects
    and Properties in a space-efficient pooled manner with the
    actual Observable structures defined in the CybOX schema
    containing references to the pooled elements. This reduces
    redundancy caused when identical observable elements occur
    multiple times within a set of defined Observables."""
    subclass = None
    superclass = None
    def __init__(self, Event_Pool=None, Action_Pool=None, Object_Pool=None, Property_Pool=None):
        self.Event_Pool = Event_Pool
        self.Action_Pool = Action_Pool
        self.Object_Pool = Object_Pool
        self.Property_Pool = Property_Pool
    def factory(*args_, **kwargs_):
        if PoolsType.subclass:
            return PoolsType.subclass(*args_, **kwargs_)
        else:
            return PoolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Event_Pool(self): return self.Event_Pool
    def set_Event_Pool(self, Event_Pool): self.Event_Pool = Event_Pool
    def get_Action_Pool(self): return self.Action_Pool
    def set_Action_Pool(self, Action_Pool): self.Action_Pool = Action_Pool
    def get_Object_Pool(self): return self.Object_Pool
    def set_Object_Pool(self, Object_Pool): self.Object_Pool = Object_Pool
    def get_Property_Pool(self): return self.Property_Pool
    def set_Property_Pool(self, Property_Pool): self.Property_Pool = Property_Pool
    def hasContent_(self):
        if (
            self.Event_Pool is not None or
            self.Action_Pool is not None or
            self.Object_Pool is not None or
            self.Property_Pool is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PoolsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PoolsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PoolsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Event_Pool is not None:
            self.Event_Pool.export(outfile, level, namespace_, name_='Event_Pool', pretty_print=pretty_print)
        if self.Action_Pool is not None:
            self.Action_Pool.export(outfile, level, namespace_, name_='Action_Pool', pretty_print=pretty_print)
        if self.Object_Pool is not None:
            self.Object_Pool.export(outfile, level, namespace_, name_='Object_Pool', pretty_print=pretty_print)
        if self.Property_Pool is not None:
            self.Property_Pool.export(outfile, level, namespace_, name_='Property_Pool', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PoolsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Event_Pool is not None:
            showIndent(outfile, level)
            outfile.write('Event_Pool=model_.EventPoolType(\n')
            self.Event_Pool.exportLiteral(outfile, level, name_='Event_Pool')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Pool is not None:
            showIndent(outfile, level)
            outfile.write('Action_Pool=model_.ActionPoolType(\n')
            self.Action_Pool.exportLiteral(outfile, level, name_='Action_Pool')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Object_Pool is not None:
            showIndent(outfile, level)
            outfile.write('Object_Pool=model_.ObjectPoolType(\n')
            self.Object_Pool.exportLiteral(outfile, level, name_='Object_Pool')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Property_Pool is not None:
            showIndent(outfile, level)
            outfile.write('Property_Pool=model_.PropertyPoolType(\n')
            self.Property_Pool.exportLiteral(outfile, level, name_='Property_Pool')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Event_Pool':
            obj_ = EventPoolType.factory()
            obj_.build(child_)
            self.Event_Pool = obj_
        elif nodeName_ == 'Action_Pool':
            obj_ = ActionPoolType.factory()
            obj_.build(child_)
            self.Action_Pool = obj_
        elif nodeName_ == 'Object_Pool':
            obj_ = ObjectPoolType.factory()
            obj_.build(child_)
            self.Object_Pool = obj_
        elif nodeName_ == 'Property_Pool':
            obj_ = PropertyPoolType.factory()
            obj_.build(child_)
            self.Property_Pool = obj_
# end class PoolsType


class EventPoolType(GeneratedsSuper):
    """The EventPoolType enables the description of CybOX Events in a
    space-efficient pooled manner with the actual Observable
    structures defined in the CybOX schema containing references to
    the pooled Event elements. This reduces redundancy caused when
    identical Events occur multiple times within a set of defined
    Observables."""
    subclass = None
    superclass = None
    def __init__(self, Event=None):
        if Event is None:
            self.Event = []
        else:
            self.Event = Event
    def factory(*args_, **kwargs_):
        if EventPoolType.subclass:
            return EventPoolType.subclass(*args_, **kwargs_)
        else:
            return EventPoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def add_Event(self, value): self.Event.append(value)
    def insert_Event(self, index, value): self.Event[index] = value
    def hasContent_(self):
        if (
            self.Event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='EventPoolType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventPoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='EventPoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='EventPoolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Event_ in self.Event:
            Event_.export(outfile, level, namespace_, name_='Event', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EventPoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Event=[\n')
        level += 1
        for Event_ in self.Event:
            showIndent(outfile, level)
            outfile.write('model_.EventType(\n')
            Event_.exportLiteral(outfile, level, name_='EventType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Event':
            obj_ = EventType.factory()
            obj_.build(child_)
            self.Event.append(obj_)
# end class EventPoolType


class ActionPoolType(GeneratedsSuper):
    """The ActionPoolType enables the description of CybOX Actions in a
    space-efficient pooled manner with the actual Observable
    structures defined in the CybOX schema containing references to
    the pooled Action elements. This reduces redundancy caused when
    identical Actions occur multiple times within a set of defined
    Observables."""
    subclass = None
    superclass = None
    def __init__(self, Action=None):
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
    def factory(*args_, **kwargs_):
        if ActionPoolType.subclass:
            return ActionPoolType.subclass(*args_, **kwargs_)
        else:
            return ActionPoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def hasContent_(self):
        if (
            self.Action
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionPoolType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionPoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionPoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionPoolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_ in self.Action:
            Action_.export(outfile, level, namespace_, name_='Action', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionPoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.ActionType(\n')
            Action_.exportLiteral(outfile, level, name_='ActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            class_obj_ = self.get_class_obj_(child_, ActionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Action.append(obj_)
# end class ActionPoolType


class ObjectPoolType(GeneratedsSuper):
    """The ObjectPoolType enables the description of CybOX Objects in a
    space-efficient pooled manner with the actual Observable
    structures defined in the CybOX schema containing references to
    the pooled Object elements. This reduces redundancy caused when
    identical Objects occur multiple times within a set of defined
    Observables."""
    subclass = None
    superclass = None
    def __init__(self, Object=None):
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if ObjectPoolType.subclass:
            return ObjectPoolType.subclass(*args_, **kwargs_)
        else:
            return ObjectPoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def hasContent_(self):
        if (
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectPoolType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectPoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectPoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectPoolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_ in self.Object:
            Object_.export(outfile, level, namespace_, name_='Object', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectPoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_.ObjectType(\n')
            Object_.exportLiteral(outfile, level, name_='ObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            class_obj_ = self.get_class_obj_(child_, ObjectType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Object.append(obj_)
# end class ObjectPoolType


class PropertyPoolType(GeneratedsSuper):
    """The PropertyPoolType enables the description of CybOX Properties in
    a space-efficient pooled manner with the actual Observable
    structures defined in the CybOX schema containing references to
    the pooled Properties elements. This reduces redundancy caused
    when identical Properties occur multiple times within a set of
    defined Observables."""
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if PropertyPoolType.subclass:
            return PropertyPoolType.subclass(*args_, **kwargs_)
        else:
            return PropertyPoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PropertyPoolType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyPoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PropertyPoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PropertyPoolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyPoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
# end class PropertyPoolType


class ObfuscationTechniquesType(GeneratedsSuper):
    """The ObfuscationTechniquesType enables the description of a set of
    potential techniques an attacker could leverage to obfuscate the
    observability of this Observable."""
    subclass = None
    superclass = None
    def __init__(self, Obfuscation_Technique=None):
        if Obfuscation_Technique is None:
            self.Obfuscation_Technique = []
        else:
            self.Obfuscation_Technique = Obfuscation_Technique
    def factory(*args_, **kwargs_):
        if ObfuscationTechniquesType.subclass:
            return ObfuscationTechniquesType.subclass(*args_, **kwargs_)
        else:
            return ObfuscationTechniquesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Obfuscation_Technique(self): return self.Obfuscation_Technique
    def set_Obfuscation_Technique(self, Obfuscation_Technique): self.Obfuscation_Technique = Obfuscation_Technique
    def add_Obfuscation_Technique(self, value): self.Obfuscation_Technique.append(value)
    def insert_Obfuscation_Technique(self, index, value): self.Obfuscation_Technique[index] = value
    def hasContent_(self):
        if (
            self.Obfuscation_Technique
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObfuscationTechniquesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObfuscationTechniquesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObfuscationTechniquesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObfuscationTechniquesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Obfuscation_Technique_ in self.Obfuscation_Technique:
            Obfuscation_Technique_.export(outfile, level, namespace_, name_='Obfuscation_Technique', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObfuscationTechniquesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Obfuscation_Technique=[\n')
        level += 1
        for Obfuscation_Technique_ in self.Obfuscation_Technique:
            showIndent(outfile, level)
            outfile.write('model_.ObfuscationTechniqueType(\n')
            Obfuscation_Technique_.exportLiteral(outfile, level, name_='ObfuscationTechniqueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Obfuscation_Technique':
            obj_ = ObfuscationTechniqueType.factory()
            obj_.build(child_)
            self.Obfuscation_Technique.append(obj_)
# end class ObfuscationTechniquesType


class ObfuscationTechniqueType(GeneratedsSuper):
    """The ObfuscationTechniqueType enables the description of a single
    potential technique an attacker could leverage to obfuscate the
    observability of this Observable."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Observables=None):
        self.Description = Description
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if ObfuscationTechniqueType.subclass:
            return ObfuscationTechniqueType.subclass(*args_, **kwargs_)
        else:
            return ObfuscationTechniqueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Observables is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObfuscationTechniqueType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObfuscationTechniqueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObfuscationTechniqueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObfuscationTechniqueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObfuscationTechniqueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Observables':
            obj_ = ObservablesType.factory()
            obj_.build(child_)
            self.Observables = obj_
# end class ObfuscationTechniqueType


class KeywordsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Keyword=None):
        if Keyword is None:
            self.Keyword = []
        else:
            self.Keyword = Keyword
    def factory(*args_, **kwargs_):
        if KeywordsType.subclass:
            return KeywordsType.subclass(*args_, **kwargs_)
        else:
            return KeywordsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Keyword(self): return self.Keyword
    def set_Keyword(self, Keyword): self.Keyword = Keyword
    def add_Keyword(self, value): self.Keyword.append(value)
    def insert_Keyword(self, index, value): self.Keyword[index] = value
    def hasContent_(self):
        if (
            self.Keyword
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='KeywordsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeywordsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='KeywordsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='KeywordsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Keyword_ in self.Keyword:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyword>%s</%sKeyword>%s' % (namespace_, self.gds_format_string(quote_xml(Keyword_).encode(ExternalEncoding), input_name='Keyword'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='KeywordsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Keyword=[\n')
        level += 1
        for Keyword_ in self.Keyword:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Keyword_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Keyword':
            Keyword_ = child_.text
            Keyword_ = self.gds_validate_string(Keyword_, node, 'Keyword')
            self.Keyword.append(Keyword_)
# end class KeywordsType


class PatternFidelityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Noisiness=None, Ease_of_Evasion=None, Evasion_Techniques=None):
        self.Noisiness = Noisiness
        self.Ease_of_Evasion = Ease_of_Evasion
        self.Evasion_Techniques = Evasion_Techniques
    def factory(*args_, **kwargs_):
        if PatternFidelityType.subclass:
            return PatternFidelityType.subclass(*args_, **kwargs_)
        else:
            return PatternFidelityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Noisiness(self): return self.Noisiness
    def set_Noisiness(self, Noisiness): self.Noisiness = Noisiness
    def get_Ease_of_Evasion(self): return self.Ease_of_Evasion
    def set_Ease_of_Evasion(self, Ease_of_Evasion): self.Ease_of_Evasion = Ease_of_Evasion
    def get_Evasion_Techniques(self): return self.Evasion_Techniques
    def set_Evasion_Techniques(self, Evasion_Techniques): self.Evasion_Techniques = Evasion_Techniques
    def validate_NoisinessEnum(self, value):
        # Validate type NoisinessEnum, a restriction on xs:string.
        pass
    def validate_EaseOfObfuscationEnum(self, value):
        # Validate type EaseOfObfuscationEnum, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Noisiness is not None or
            self.Ease_of_Evasion is not None or
            self.Evasion_Techniques is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PatternFidelityType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cybox="http://cybox.mitre.org/cybox-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PatternFidelityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PatternFidelityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PatternFidelityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Noisiness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNoisiness>%s</%sNoisiness>%s' % (namespace_, self.gds_format_string(quote_xml(self.Noisiness).encode(ExternalEncoding), input_name='Noisiness'), namespace_, eol_))
        if self.Ease_of_Evasion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEase_of_Evasion>%s</%sEase_of_Evasion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Ease_of_Evasion).encode(ExternalEncoding), input_name='Ease_of_Evasion'), namespace_, eol_))
        if self.Evasion_Techniques is not None:
            self.Evasion_Techniques.export(outfile, level, namespace_, name_='Evasion_Techniques', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PatternFidelityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Noisiness is not None:
            showIndent(outfile, level)
            outfile.write('Noisiness=%s,\n' % quote_python(self.Noisiness).encode(ExternalEncoding))
        if self.Ease_of_Evasion is not None:
            showIndent(outfile, level)
            outfile.write('Ease_of_Evasion=%s,\n' % quote_python(self.Ease_of_Evasion).encode(ExternalEncoding))
        if self.Evasion_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Evasion_Techniques=model_.ObfuscationTechniquesType(\n')
            self.Evasion_Techniques.exportLiteral(outfile, level, name_='Evasion_Techniques')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Noisiness':
            Noisiness_ = child_.text
            Noisiness_ = self.gds_validate_string(Noisiness_, node, 'Noisiness')
            self.Noisiness = Noisiness_
            self.validate_NoisinessEnum(self.Noisiness)    # validate type NoisinessEnum
        elif nodeName_ == 'Ease_of_Evasion':
            Ease_of_Evasion_ = child_.text
            Ease_of_Evasion_ = self.gds_validate_string(Ease_of_Evasion_, node, 'Ease_of_Evasion')
            self.Ease_of_Evasion = Ease_of_Evasion_
            self.validate_EaseOfObfuscationEnum(self.Ease_of_Evasion)    # validate type EaseOfObfuscationEnum
        elif nodeName_ == 'Evasion_Techniques':
            obj_ = ObfuscationTechniquesType.factory()
            obj_.build(child_)
            self.Evasion_Techniques = obj_
# end class PatternFidelityType


class MeasureSourceType(GeneratedsSuper):
    """The MeasureSourceType is a type representing a description of a
    single cyber observation source.The class field is optional and
    enables identification of the high-level class of this cyber
    observation source.The source_type field is optional and enables
    identification of the broad type of this cyber observation
    source.The name field is optional and enables the assignment of
    a relevant name to a this Discovery Method."""
    subclass = None
    superclass = None
    def __init__(self, source_type=None, class_=None, name=None, Information_Source_Type=None, Tool_Type=None, Description=None, Contributors=None, Time=None, Tools=None, Platform=None, System=None, Instance=None):
        self.source_type = _cast(None, source_type)
        self.class_ = _cast(None, class_)
        self.name = _cast(None, name)
        self.Information_Source_Type = Information_Source_Type
        self.Tool_Type = Tool_Type
        self.Description = Description
        self.Contributors = Contributors
        self.Time = Time
        self.Tools = Tools
        self.Platform = Platform
        self.System = System
        self.Instance = Instance
    def factory(*args_, **kwargs_):
        if MeasureSourceType.subclass:
            return MeasureSourceType.subclass(*args_, **kwargs_)
        else:
            return MeasureSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Information_Source_Type(self): return self.Information_Source_Type
    def set_Information_Source_Type(self, Information_Source_Type): self.Information_Source_Type = Information_Source_Type
    def get_Tool_Type(self): return self.Tool_Type
    def set_Tool_Type(self, Tool_Type): self.Tool_Type = Tool_Type
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Contributors(self): return self.Contributors
    def set_Contributors(self, Contributors): self.Contributors = Contributors
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Tools(self): return self.Tools
    def set_Tools(self, Tools): self.Tools = Tools
    def get_Platform(self): return self.Platform
    def set_Platform(self, Platform): self.Platform = Platform
    def get_System(self): return self.System
    def set_System(self, System): self.System = System
    def get_Instance(self): return self.Instance
    def set_Instance(self, Instance): self.Instance = Instance
    def get_source_type(self): return self.source_type
    def set_source_type(self, source_type): self.source_type = source_type
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.Information_Source_Type is not None or
            self.Tool_Type is not None or
            self.Description is not None or
            self.Contributors is not None or
            self.Time is not None or
            self.Tools is not None or
            self.Platform is not None or
            self.System is not None or
            self.Instance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='MeasureSourceType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureSourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='MeasureSourceType'):
        if self.source_type is not None and 'source_type' not in already_processed:
            already_processed.add('source_type')
            outfile.write(' source_type=%s' % (quote_attrib(self.source_type), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (quote_attrib(self.class_), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='MeasureSourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Information_Source_Type is not None:
            self.Information_Source_Type.export(outfile, level, namespace_, name_='Information_Source_Type', pretty_print=pretty_print)
        if self.Tool_Type is not None:
            self.Tool_Type.export(outfile, level, namespace_, name_='Tool_Type', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Contributors is not None:
            self.Contributors.export(outfile, level, namespace_, name_='Contributors', pretty_print=pretty_print)
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
        if self.Tools is not None:
            self.Tools.export(outfile, level, namespace_, name_='Tools', pretty_print=pretty_print)
        if self.Platform is not None:
            self.Platform.export(outfile, level, namespace_, name_='Platform', pretty_print=pretty_print)
        if self.System is not None:
            self.System.export(outfile, level, namespace_, name_='System', pretty_print=pretty_print)
        if self.Instance is not None:
            self.Instance.export(outfile, level, namespace_, name_='Instance', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MeasureSourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.source_type is not None and 'source_type' not in already_processed:
            already_processed.add('source_type')
            showIndent(outfile, level)
            outfile.write('source_type=%s,\n' % (self.source_type,))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            showIndent(outfile, level)
            outfile.write('class_=%s,\n' % (self.class_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Information_Source_Type is not None:
            showIndent(outfile, level)
            outfile.write('Information_Source_Type=model_.ControlledVocabularyStringType(\n')
            self.Information_Source_Type.exportLiteral(outfile, level, name_='Information_Source_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tool_Type is not None:
            showIndent(outfile, level)
            outfile.write('Tool_Type=model_.ControlledVocabularyStringType(\n')
            self.Tool_Type.exportLiteral(outfile, level, name_='Tool_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Contributors is not None:
            showIndent(outfile, level)
            outfile.write('Contributors=model_.PersonnelType(\n')
            self.Contributors.exportLiteral(outfile, level, name_='Contributors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.TimeType(\n')
            self.Time.exportLiteral(outfile, level, name_='Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tools is not None:
            showIndent(outfile, level)
            outfile.write('Tools=model_.ToolsInformationType(\n')
            self.Tools.exportLiteral(outfile, level, name_='Tools')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Platform is not None:
            showIndent(outfile, level)
            outfile.write('Platform=model_.PlatformSpecificationType(\n')
            self.Platform.exportLiteral(outfile, level, name_='Platform')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectPropertiesType is not None:
            showIndent(outfile, level)
            outfile.write('ObjectPropertiesType=model_.ObjectPropertiesType(\n')
            self.ObjectPropertiesType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectPropertiesType is not None:
            showIndent(outfile, level)
            outfile.write('ObjectPropertiesType=model_.ObjectPropertiesType(\n')
            self.ObjectPropertiesType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source_type', node)
        if value is not None and 'source_type' not in already_processed:
            already_processed.add('source_type')
            self.source_type = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Information_Source_Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Information_Source_Type = obj_
        elif nodeName_ == 'Tool_Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Tool_Type = obj_
        elif nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Contributors':
            obj_ = PersonnelType.factory()
            obj_.build(child_)
            self.Contributors = obj_
        elif nodeName_ == 'Time':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.Time = obj_
        elif nodeName_ == 'Tools':
            obj_ = ToolsInformationType.factory()
            obj_.build(child_)
            self.Tools = obj_
        elif nodeName_ == 'Platform':
            obj_ = PlatformSpecificationType.factory()
            obj_.build(child_)
            self.Platform = obj_
        elif nodeName_ == 'System':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <System> element')
            self.System = obj_
        elif nodeName_ == 'Instance':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Instance> element')
            self.Instance = obj_
# end class MeasureSourceType


class ContributorType(GeneratedsSuper):
    """The ContributorType represents a description of an individual who
    contributed as a source of cyber observation data."""
    subclass = None
    superclass = None
    def __init__(self, Role=None, Name=None, Email=None, Phone=None, Organization=None, Date=None, Contribution_Location=None):
        self.Role = Role
        self.Name = Name
        self.Email = Email
        self.Phone = Phone
        self.Organization = Organization
        self.Date = Date
        self.Contribution_Location = Contribution_Location
    def factory(*args_, **kwargs_):
        if ContributorType.subclass:
            return ContributorType.subclass(*args_, **kwargs_)
        else:
            return ContributorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Email(self): return self.Email
    def set_Email(self, Email): self.Email = Email
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_Organization(self): return self.Organization
    def set_Organization(self, Organization): self.Organization = Organization
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Contribution_Location(self): return self.Contribution_Location
    def set_Contribution_Location(self, Contribution_Location): self.Contribution_Location = Contribution_Location
    def hasContent_(self):
        if (
            self.Role is not None or
            self.Name is not None or
            self.Email is not None or
            self.Phone is not None or
            self.Organization is not None or
            self.Date is not None or
            self.Contribution_Location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ContributorType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContributorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ContributorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ContributorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Role is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRole>%s</%sRole>%s' % (namespace_, self.gds_format_string(quote_xml(self.Role).encode(ExternalEncoding), input_name='Role'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmail>%s</%sEmail>%s' % (namespace_, self.gds_format_string(quote_xml(self.Email).encode(ExternalEncoding), input_name='Email'), namespace_, eol_))
        if self.Phone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhone>%s</%sPhone>%s' % (namespace_, self.gds_format_string(quote_xml(self.Phone).encode(ExternalEncoding), input_name='Phone'), namespace_, eol_))
        if self.Organization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganization>%s</%sOrganization>%s' % (namespace_, self.gds_format_string(quote_xml(self.Organization).encode(ExternalEncoding), input_name='Organization'), namespace_, eol_))
        if self.Date is not None:
            self.Date.export(outfile, level, namespace_, name_='Date', pretty_print=pretty_print)
        if self.Contribution_Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContribution_Location>%s</%sContribution_Location>%s' % (namespace_, self.gds_format_string(quote_xml(self.Contribution_Location).encode(ExternalEncoding), input_name='Contribution_Location'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ContributorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Role is not None:
            showIndent(outfile, level)
            outfile.write('Role=%s,\n' % quote_python(self.Role).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Email is not None:
            showIndent(outfile, level)
            outfile.write('Email=%s,\n' % quote_python(self.Email).encode(ExternalEncoding))
        if self.Phone is not None:
            showIndent(outfile, level)
            outfile.write('Phone=%s,\n' % quote_python(self.Phone).encode(ExternalEncoding))
        if self.Organization is not None:
            showIndent(outfile, level)
            outfile.write('Organization=%s,\n' % quote_python(self.Organization).encode(ExternalEncoding))
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=model_.DateRangeType(\n')
            self.Date.exportLiteral(outfile, level, name_='Date')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Contribution_Location is not None:
            showIndent(outfile, level)
            outfile.write('Contribution_Location=%s,\n' % quote_python(self.Contribution_Location).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Role':
            Role_ = child_.text
            Role_ = self.gds_validate_string(Role_, node, 'Role')
            self.Role = Role_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Email':
            Email_ = child_.text
            Email_ = self.gds_validate_string(Email_, node, 'Email')
            self.Email = Email_
        elif nodeName_ == 'Phone':
            Phone_ = child_.text
            Phone_ = self.gds_validate_string(Phone_, node, 'Phone')
            self.Phone = Phone_
        elif nodeName_ == 'Organization':
            Organization_ = child_.text
            Organization_ = self.gds_validate_string(Organization_, node, 'Organization')
            self.Organization = Organization_
        elif nodeName_ == 'Date':
            obj_ = DateRangeType.factory()
            obj_.build(child_)
            self.Date = obj_
        elif nodeName_ == 'Contribution_Location':
            Contribution_Location_ = child_.text
            Contribution_Location_ = self.gds_validate_string(Contribution_Location_, node, 'Contribution_Location')
            self.Contribution_Location = Contribution_Location_
# end class ContributorType


class DateRangeType(GeneratedsSuper):
    """The DateRangeType specifies a range of dates."""
    subclass = None
    superclass = None
    def __init__(self, Start_Date=None, End_Date=None):
        if isinstance(Start_Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Start_Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Start_Date
        self.Start_Date = initvalue_
        if isinstance(End_Date, basestring):
            initvalue_ = datetime_.datetime.strptime(End_Date, '%Y-%m-%d').date()
        else:
            initvalue_ = End_Date
        self.End_Date = initvalue_
    def factory(*args_, **kwargs_):
        if DateRangeType.subclass:
            return DateRangeType.subclass(*args_, **kwargs_)
        else:
            return DateRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Start_Date(self): return self.Start_Date
    def set_Start_Date(self, Start_Date): self.Start_Date = Start_Date
    def get_End_Date(self): return self.End_Date
    def set_End_Date(self, End_Date): self.End_Date = End_Date
    def hasContent_(self):
        if (
            self.Start_Date is not None or
            self.End_Date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DateRangeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DateRangeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DateRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Start_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStart_Date>%s</%sStart_Date>%s' % (namespace_, self.gds_format_date(self.Start_Date, input_name='Start_Date'), namespace_, eol_))
        if self.End_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnd_Date>%s</%sEnd_Date>%s' % (namespace_, self.gds_format_date(self.End_Date, input_name='End_Date'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DateRangeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Start_Date is not None:
            showIndent(outfile, level)
            outfile.write('Start_Date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.Start_Date, input_name='Start_Date'))
        if self.End_Date is not None:
            showIndent(outfile, level)
            outfile.write('End_Date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.End_Date, input_name='End_Date'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Start_Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Start_Date = dval_
        elif nodeName_ == 'End_Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.End_Date = dval_
# end class DateRangeType


class PersonnelType(GeneratedsSuper):
    """The PersonnelType is an abstracted data type to standardize the
    description of sets of personnel."""
    subclass = None
    superclass = None
    def __init__(self, Contributor=None):
        if Contributor is None:
            self.Contributor = []
        else:
            self.Contributor = Contributor
    def factory(*args_, **kwargs_):
        if PersonnelType.subclass:
            return PersonnelType.subclass(*args_, **kwargs_)
        else:
            return PersonnelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Contributor(self): return self.Contributor
    def set_Contributor(self, Contributor): self.Contributor = Contributor
    def add_Contributor(self, value): self.Contributor.append(value)
    def insert_Contributor(self, index, value): self.Contributor[index] = value
    def hasContent_(self):
        if (
            self.Contributor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PersonnelType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PersonnelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PersonnelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Contributor_ in self.Contributor:
            Contributor_.export(outfile, level, namespace_, name_='Contributor', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PersonnelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Contributor=[\n')
        level += 1
        for Contributor_ in self.Contributor:
            showIndent(outfile, level)
            outfile.write('model_.ContributorType(\n')
            Contributor_.exportLiteral(outfile, level, name_='ContributorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Contributor':
            obj_ = ContributorType.factory()
            obj_.build(child_)
            self.Contributor.append(obj_)
# end class PersonnelType


class TimeType(GeneratedsSuper):
    """The TimeType specifies various time properties for a cyber
    observation source."""
    subclass = None
    superclass = None
    def __init__(self, Start_Time=None, End_Time=None, Produced_Time=None, Received_Time=None):
        if isinstance(Start_Time, basestring):
            initvalue_ = datetime_.datetime.strptime(Start_Time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Start_Time
        self.Start_Time = initvalue_
        if isinstance(End_Time, basestring):
            initvalue_ = datetime_.datetime.strptime(End_Time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = End_Time
        self.End_Time = initvalue_
        if isinstance(Produced_Time, basestring):
            initvalue_ = datetime_.datetime.strptime(Produced_Time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Produced_Time
        self.Produced_Time = initvalue_
        if isinstance(Received_Time, basestring):
            initvalue_ = datetime_.datetime.strptime(Received_Time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Received_Time
        self.Received_Time = initvalue_
    def factory(*args_, **kwargs_):
        if TimeType.subclass:
            return TimeType.subclass(*args_, **kwargs_)
        else:
            return TimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Start_Time(self): return self.Start_Time
    def set_Start_Time(self, Start_Time): self.Start_Time = Start_Time
    def get_End_Time(self): return self.End_Time
    def set_End_Time(self, End_Time): self.End_Time = End_Time
    def get_Produced_Time(self): return self.Produced_Time
    def set_Produced_Time(self, Produced_Time): self.Produced_Time = Produced_Time
    def get_Received_Time(self): return self.Received_Time
    def set_Received_Time(self, Received_Time): self.Received_Time = Received_Time
    def hasContent_(self):
        if (
            self.Start_Time is not None or
            self.End_Time is not None or
            self.Produced_Time is not None or
            self.Received_Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='TimeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='TimeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='TimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Start_Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStart_Time>%s</%sStart_Time>%s' % (namespace_, self.gds_format_datetime(self.Start_Time, input_name='Start_Time'), namespace_, eol_))
        if self.End_Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnd_Time>%s</%sEnd_Time>%s' % (namespace_, self.gds_format_datetime(self.End_Time, input_name='End_Time'), namespace_, eol_))
        if self.Produced_Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProduced_Time>%s</%sProduced_Time>%s' % (namespace_, self.gds_format_datetime(self.Produced_Time, input_name='Produced_Time'), namespace_, eol_))
        if self.Received_Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReceived_Time>%s</%sReceived_Time>%s' % (namespace_, self.gds_format_datetime(self.Received_Time, input_name='Received_Time'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Start_Time is not None:
            showIndent(outfile, level)
            outfile.write('Start_Time=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Start_Time, input_name='Start_Time'))
        if self.End_Time is not None:
            showIndent(outfile, level)
            outfile.write('End_Time=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.End_Time, input_name='End_Time'))
        if self.Produced_Time is not None:
            showIndent(outfile, level)
            outfile.write('Produced_Time=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Produced_Time, input_name='Produced_Time'))
        if self.Received_Time is not None:
            showIndent(outfile, level)
            outfile.write('Received_Time=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Received_Time, input_name='Received_Time'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Start_Time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Start_Time = dval_
        elif nodeName_ == 'End_Time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.End_Time = dval_
        elif nodeName_ == 'Produced_Time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Produced_Time = dval_
        elif nodeName_ == 'Received_Time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Received_Time = dval_
# end class TimeType


class ToolSpecificDataType(GeneratedsSuper):
    """The ToolSpecificDataType is an Abstract type placeholder within the
    CybOX schema enabling the inclusion of metadata for a specific
    type of tool through the use of a custom type defined as an
    extension of this base Abstract type."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ToolSpecificDataType.subclass:
            return ToolSpecificDataType.subclass(*args_, **kwargs_)
        else:
            return ToolSpecificDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ToolSpecificDataType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToolSpecificDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ToolSpecificDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ToolSpecificDataType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ToolSpecificDataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ToolSpecificDataType


class ToolsInformationType(GeneratedsSuper):
    """The ToolsInformationType represents a description of a set of
    automated tools."""
    subclass = None
    superclass = None
    def __init__(self, Tool=None):
        if Tool is None:
            self.Tool = []
        else:
            self.Tool = Tool
    def factory(*args_, **kwargs_):
        if ToolsInformationType.subclass:
            return ToolsInformationType.subclass(*args_, **kwargs_)
        else:
            return ToolsInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tool(self): return self.Tool
    def set_Tool(self, Tool): self.Tool = Tool
    def add_Tool(self, value): self.Tool.append(value)
    def insert_Tool(self, index, value): self.Tool[index] = value
    def hasContent_(self):
        if (
            self.Tool
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ToolsInformationType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToolsInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ToolsInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ToolsInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tool_ in self.Tool:
            Tool_.export(outfile, level, namespace_, name_='Tool', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ToolsInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Tool=[\n')
        level += 1
        for Tool_ in self.Tool:
            showIndent(outfile, level)
            outfile.write('model_.ToolInformationType(\n')
            Tool_.exportLiteral(outfile, level, name_='ToolInformationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tool':
            class_obj_ = self.get_class_obj_(child_, ToolInformationType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Tool.append(obj_)
# end class ToolsInformationType


class ToolInformationType(GeneratedsSuper):
    """The ToolInformationType represens a description of a single
    automated tool.The id field specifies a unique ID for this
    Tool.The idref field specifies reference to a unique ID for this
    Tool."""
    subclass = None
    superclass = None
    def __init__(self, idref=None, id=None, Name=None, Type=None, Description=None, References=None, Vendor=None, Version=None, Service_Pack=None, Tool_Specific_Data=None, Tool_Hashes=None, Tool_Configuration=None, Execution_Environment=None, Errors=None, Metadata=None, extensiontype_=None):
        self.idref = _cast(None, idref)
        self.id = _cast(None, id)
        self.Name = Name
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        self.Description = Description
        self.References = References
        self.Vendor = Vendor
        self.Version = Version
        self.Service_Pack = Service_Pack
        self.Tool_Specific_Data = Tool_Specific_Data
        self.Tool_Hashes = Tool_Hashes
        self.Tool_Configuration = Tool_Configuration
        self.Execution_Environment = Execution_Environment
        self.Errors = Errors
        if Metadata is None:
            self.Metadata = []
        else:
            self.Metadata = Metadata
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ToolInformationType.subclass:
            return ToolInformationType.subclass(*args_, **kwargs_)
        else:
            return ToolInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type(self, index, value): self.Type[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Vendor(self): return self.Vendor
    def set_Vendor(self, Vendor): self.Vendor = Vendor
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Service_Pack(self): return self.Service_Pack
    def set_Service_Pack(self, Service_Pack): self.Service_Pack = Service_Pack
    def get_Tool_Specific_Data(self): return self.Tool_Specific_Data
    def set_Tool_Specific_Data(self, Tool_Specific_Data): self.Tool_Specific_Data = Tool_Specific_Data
    def get_Tool_Hashes(self): return self.Tool_Hashes
    def set_Tool_Hashes(self, Tool_Hashes): self.Tool_Hashes = Tool_Hashes
    def get_Tool_Configuration(self): return self.Tool_Configuration
    def set_Tool_Configuration(self, Tool_Configuration): self.Tool_Configuration = Tool_Configuration
    def get_Execution_Environment(self): return self.Execution_Environment
    def set_Execution_Environment(self, Execution_Environment): self.Execution_Environment = Execution_Environment
    def get_Errors(self): return self.Errors
    def set_Errors(self, Errors): self.Errors = Errors
    def get_Metadata(self): return self.Metadata
    def set_Metadata(self, Metadata): self.Metadata = Metadata
    def add_Metadata(self, value): self.Metadata.append(value)
    def insert_Metadata(self, index, value): self.Metadata[index] = value
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Type or
            self.Description is not None or
            self.References is not None or
            self.Vendor is not None or
            self.Version is not None or
            self.Service_Pack is not None or
            self.Tool_Specific_Data is not None or
            self.Tool_Hashes is not None or
            self.Tool_Configuration is not None or
            self.Execution_Environment is not None or
            self.Errors is not None or
            self.Metadata
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ToolInformationType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToolInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ToolInformationType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ToolInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        for Type_ in self.Type:
            Type_.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.References is not None:
            self.References.export(outfile, level, namespace_, name_='References', pretty_print=pretty_print)
        if self.Vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVendor>%s</%sVendor>%s' % (namespace_, self.gds_format_string(quote_xml(self.Vendor).encode(ExternalEncoding), input_name='Vendor'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Service_Pack is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sService_Pack>%s</%sService_Pack>%s' % (namespace_, self.gds_format_string(quote_xml(self.Service_Pack).encode(ExternalEncoding), input_name='Service_Pack'), namespace_, eol_))
        if self.Tool_Specific_Data is not None:
            self.Tool_Specific_Data.export(outfile, level, namespace_, name_='Tool_Specific_Data', pretty_print=pretty_print)
        if self.Tool_Hashes is not None:
            self.Tool_Hashes.export(outfile, level, namespace_, name_='Tool_Hashes', pretty_print=pretty_print)
        if self.Tool_Configuration is not None:
            self.Tool_Configuration.export(outfile, level, namespace_, name_='Tool_Configuration', pretty_print=pretty_print)
        if self.Execution_Environment is not None:
            self.Execution_Environment.export(outfile, level, namespace_, name_='Execution_Environment', pretty_print=pretty_print)
        if self.Errors is not None:
            self.Errors.export(outfile, level, namespace_, name_='Errors', pretty_print=pretty_print)
        for Metadata_ in self.Metadata:
            Metadata_.export(outfile, level, namespace_, name_='Metadata', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ToolInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            showIndent(outfile, level)
            outfile.write('idref=%s,\n' % (self.idref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('model_.ControlledVocabularyStringType(\n')
            Type_.exportLiteral(outfile, level, name_='ControlledVocabularyStringType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.References is not None:
            showIndent(outfile, level)
            outfile.write('References=model_.ToolReferencesType(\n')
            self.References.exportLiteral(outfile, level, name_='References')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vendor is not None:
            showIndent(outfile, level)
            outfile.write('Vendor=%s,\n' % quote_python(self.Vendor).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Service_Pack is not None:
            showIndent(outfile, level)
            outfile.write('Service_Pack=%s,\n' % quote_python(self.Service_Pack).encode(ExternalEncoding))
        if self.ToolSpecificDataType is not None:
            showIndent(outfile, level)
            outfile.write('ToolSpecificDataType=model_.ToolSpecificDataType(\n')
            self.ToolSpecificDataType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tool_Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Tool_Hashes=model_.HashListType(\n')
            self.Tool_Hashes.exportLiteral(outfile, level, name_='Tool_Hashes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tool_Configuration is not None:
            showIndent(outfile, level)
            outfile.write('Tool_Configuration=model_.ToolConfigurationType(\n')
            self.Tool_Configuration.exportLiteral(outfile, level, name_='Tool_Configuration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Execution_Environment is not None:
            showIndent(outfile, level)
            outfile.write('Execution_Environment=model_.ExecutionEnvironmentType(\n')
            self.Execution_Environment.exportLiteral(outfile, level, name_='Execution_Environment')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Errors is not None:
            showIndent(outfile, level)
            outfile.write('Errors=model_.ErrorsType(\n')
            self.Errors.exportLiteral(outfile, level, name_='Errors')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Metadata=[\n')
        level += 1
        for Metadata_ in self.Metadata:
            showIndent(outfile, level)
            outfile.write('model_.MetadataType(\n')
            Metadata_.exportLiteral(outfile, level, name_='MetadataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Type.append(obj_)
        elif nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'References':
            obj_ = ToolReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
        elif nodeName_ == 'Vendor':
            Vendor_ = child_.text
            Vendor_ = self.gds_validate_string(Vendor_, node, 'Vendor')
            self.Vendor = Vendor_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Service_Pack':
            Service_Pack_ = child_.text
            Service_Pack_ = self.gds_validate_string(Service_Pack_, node, 'Service_Pack')
            self.Service_Pack = Service_Pack_
        elif nodeName_ == 'Tool_Specific_Data':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Tool_Specific_Data> element')
            self.Tool_Specific_Data = obj_
        elif nodeName_ == 'Tool_Hashes':
            obj_ = HashListType.factory()
            obj_.build(child_)
            self.Tool_Hashes = obj_
        elif nodeName_ == 'Tool_Configuration':
            obj_ = ToolConfigurationType.factory()
            obj_.build(child_)
            self.Tool_Configuration = obj_
        elif nodeName_ == 'Execution_Environment':
            obj_ = ExecutionEnvironmentType.factory()
            obj_.build(child_)
            self.Execution_Environment = obj_
        elif nodeName_ == 'Errors':
            obj_ = ErrorsType.factory()
            obj_.build(child_)
            self.Errors = obj_
        elif nodeName_ == 'Metadata':
            obj_ = MetadataType.factory()
            obj_.build(child_)
            self.Metadata.append(obj_)
# end class ToolInformationType


class ToolReferencesType(GeneratedsSuper):
    """Used to indicate one or more references to tool instances and
    information"""
    subclass = None
    superclass = None
    def __init__(self, Reference=None):
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if ToolReferencesType.subclass:
            return ToolReferencesType.subclass(*args_, **kwargs_)
        else:
            return ToolReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference(self, index, value): self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ToolReferencesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToolReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ToolReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ToolReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ToolReferencesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.ToolReferenceType(\n')
            Reference_.exportLiteral(outfile, level, name_='ToolReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = ToolReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
# end class ToolReferencesType


class ToolReferenceType(GeneratedsSuper):
    """Contains one reference to information or instances of a given
    toolIndicates the nature of the referenced material
    (documentation, source, executable, etc.)"""
    subclass = None
    superclass = None
    def __init__(self, reference_type=None, valueOf_=None):
        self.reference_type = _cast(None, reference_type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ToolReferenceType.subclass:
            return ToolReferenceType.subclass(*args_, **kwargs_)
        else:
            return ToolReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference_type(self): return self.reference_type
    def set_reference_type(self, reference_type): self.reference_type = reference_type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ToolReferenceType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToolReferenceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ToolReferenceType'):
        if self.reference_type is not None and 'reference_type' not in already_processed:
            already_processed.add('reference_type')
            outfile.write(' reference_type=%s' % (quote_attrib(self.reference_type), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ToolReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ToolReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reference_type is not None and 'reference_type' not in already_processed:
            already_processed.add('reference_type')
            showIndent(outfile, level)
            outfile.write('reference_type=%s,\n' % (self.reference_type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference_type', node)
        if value is not None and 'reference_type' not in already_processed:
            already_processed.add('reference_type')
            self.reference_type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ToolReferenceType


class ToolConfigurationType(GeneratedsSuper):
    """The ToolConfigurationType characterizes the configuration for a tool
    used as a cyber observation source."""
    subclass = None
    superclass = None
    def __init__(self, Configuration_Settings=None, Dependencies=None, Usage_Context_Assumptions=None, Internationalization_Settings=None, Build_Information=None):
        self.Configuration_Settings = Configuration_Settings
        self.Dependencies = Dependencies
        self.Usage_Context_Assumptions = Usage_Context_Assumptions
        self.Internationalization_Settings = Internationalization_Settings
        self.Build_Information = Build_Information
    def factory(*args_, **kwargs_):
        if ToolConfigurationType.subclass:
            return ToolConfigurationType.subclass(*args_, **kwargs_)
        else:
            return ToolConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration_Settings(self): return self.Configuration_Settings
    def set_Configuration_Settings(self, Configuration_Settings): self.Configuration_Settings = Configuration_Settings
    def get_Dependencies(self): return self.Dependencies
    def set_Dependencies(self, Dependencies): self.Dependencies = Dependencies
    def get_Usage_Context_Assumptions(self): return self.Usage_Context_Assumptions
    def set_Usage_Context_Assumptions(self, Usage_Context_Assumptions): self.Usage_Context_Assumptions = Usage_Context_Assumptions
    def get_Internationalization_Settings(self): return self.Internationalization_Settings
    def set_Internationalization_Settings(self, Internationalization_Settings): self.Internationalization_Settings = Internationalization_Settings
    def get_Build_Information(self): return self.Build_Information
    def set_Build_Information(self, Build_Information): self.Build_Information = Build_Information
    def hasContent_(self):
        if (
            self.Configuration_Settings is not None or
            self.Dependencies is not None or
            self.Usage_Context_Assumptions is not None or
            self.Internationalization_Settings is not None or
            self.Build_Information is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ToolConfigurationType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToolConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ToolConfigurationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ToolConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Configuration_Settings is not None:
            self.Configuration_Settings.export(outfile, level, namespace_, name_='Configuration_Settings', pretty_print=pretty_print)
        if self.Dependencies is not None:
            self.Dependencies.export(outfile, level, namespace_, name_='Dependencies', pretty_print=pretty_print)
        if self.Usage_Context_Assumptions is not None:
            self.Usage_Context_Assumptions.export(outfile, level, namespace_, name_='Usage_Context_Assumptions', pretty_print=pretty_print)
        if self.Internationalization_Settings is not None:
            self.Internationalization_Settings.export(outfile, level, namespace_, name_='Internationalization_Settings', pretty_print=pretty_print)
        if self.Build_Information is not None:
            self.Build_Information.export(outfile, level, namespace_, name_='Build_Information', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ToolConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Configuration_Settings is not None:
            showIndent(outfile, level)
            outfile.write('Configuration_Settings=model_.ConfigurationSettingsType(\n')
            self.Configuration_Settings.exportLiteral(outfile, level, name_='Configuration_Settings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dependencies is not None:
            showIndent(outfile, level)
            outfile.write('Dependencies=model_.DependenciesType(\n')
            self.Dependencies.exportLiteral(outfile, level, name_='Dependencies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Usage_Context_Assumptions is not None:
            showIndent(outfile, level)
            outfile.write('Usage_Context_Assumptions=model_.UsageContextAssumptionsType(\n')
            self.Usage_Context_Assumptions.exportLiteral(outfile, level, name_='Usage_Context_Assumptions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Internationalization_Settings is not None:
            showIndent(outfile, level)
            outfile.write('Internationalization_Settings=model_.InternationalizationSettingsType(\n')
            self.Internationalization_Settings.exportLiteral(outfile, level, name_='Internationalization_Settings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Build_Information is not None:
            showIndent(outfile, level)
            outfile.write('Build_Information=model_.BuildInformationType(\n')
            self.Build_Information.exportLiteral(outfile, level, name_='Build_Information')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration_Settings':
            obj_ = ConfigurationSettingsType.factory()
            obj_.build(child_)
            self.Configuration_Settings = obj_
        elif nodeName_ == 'Dependencies':
            obj_ = DependenciesType.factory()
            obj_.build(child_)
            self.Dependencies = obj_
        elif nodeName_ == 'Usage_Context_Assumptions':
            obj_ = UsageContextAssumptionsType.factory()
            obj_.build(child_)
            self.Usage_Context_Assumptions = obj_
        elif nodeName_ == 'Internationalization_Settings':
            obj_ = InternationalizationSettingsType.factory()
            obj_.build(child_)
            self.Internationalization_Settings = obj_
        elif nodeName_ == 'Build_Information':
            obj_ = BuildInformationType.factory()
            obj_.build(child_)
            self.Build_Information = obj_
# end class ToolConfigurationType


class ConfigurationSettingsType(GeneratedsSuper):
    """The ConfigurationSettingsType is a modularized data type used to
    provide a consistent approach to describing configuration
    settings for a tool, application or other cyber object"""
    subclass = None
    superclass = None
    def __init__(self, Configuration_Setting=None):
        if Configuration_Setting is None:
            self.Configuration_Setting = []
        else:
            self.Configuration_Setting = Configuration_Setting
    def factory(*args_, **kwargs_):
        if ConfigurationSettingsType.subclass:
            return ConfigurationSettingsType.subclass(*args_, **kwargs_)
        else:
            return ConfigurationSettingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration_Setting(self): return self.Configuration_Setting
    def set_Configuration_Setting(self, Configuration_Setting): self.Configuration_Setting = Configuration_Setting
    def add_Configuration_Setting(self, value): self.Configuration_Setting.append(value)
    def insert_Configuration_Setting(self, index, value): self.Configuration_Setting[index] = value
    def hasContent_(self):
        if (
            self.Configuration_Setting
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ConfigurationSettingsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigurationSettingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ConfigurationSettingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ConfigurationSettingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Configuration_Setting_ in self.Configuration_Setting:
            Configuration_Setting_.export(outfile, level, namespace_, name_='Configuration_Setting', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConfigurationSettingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Configuration_Setting=[\n')
        level += 1
        for Configuration_Setting_ in self.Configuration_Setting:
            showIndent(outfile, level)
            outfile.write('model_.ConfigurationSettingType(\n')
            Configuration_Setting_.exportLiteral(outfile, level, name_='ConfigurationSettingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration_Setting':
            obj_ = ConfigurationSettingType.factory()
            obj_.build(child_)
            self.Configuration_Setting.append(obj_)
# end class ConfigurationSettingsType


class ConfigurationSettingType(GeneratedsSuper):
    """The ConfigurationSettingType is a modularized data type used to
    provide a consistent approach to describing a particular
    configuration setting for a tool, application or other cyber
    object"""
    subclass = None
    superclass = None
    def __init__(self, Item_Name=None, Item_Value=None, Item_Type=None, Item_Description=None):
        self.Item_Name = Item_Name
        self.Item_Value = Item_Value
        self.Item_Type = Item_Type
        self.Item_Description = Item_Description
    def factory(*args_, **kwargs_):
        if ConfigurationSettingType.subclass:
            return ConfigurationSettingType.subclass(*args_, **kwargs_)
        else:
            return ConfigurationSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Item_Name(self): return self.Item_Name
    def set_Item_Name(self, Item_Name): self.Item_Name = Item_Name
    def get_Item_Value(self): return self.Item_Value
    def set_Item_Value(self, Item_Value): self.Item_Value = Item_Value
    def get_Item_Type(self): return self.Item_Type
    def set_Item_Type(self, Item_Type): self.Item_Type = Item_Type
    def get_Item_Description(self): return self.Item_Description
    def set_Item_Description(self, Item_Description): self.Item_Description = Item_Description
    def hasContent_(self):
        if (
            self.Item_Name is not None or
            self.Item_Value is not None or
            self.Item_Type is not None or
            self.Item_Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ConfigurationSettingType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigurationSettingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ConfigurationSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ConfigurationSettingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Item_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sItem_Name>%s</%sItem_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.Item_Name).encode(ExternalEncoding), input_name='Item_Name'), namespace_, eol_))
        if self.Item_Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sItem_Value>%s</%sItem_Value>%s' % (namespace_, self.gds_format_string(quote_xml(self.Item_Value).encode(ExternalEncoding), input_name='Item_Value'), namespace_, eol_))
        if self.Item_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sItem_Type>%s</%sItem_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.Item_Type).encode(ExternalEncoding), input_name='Item_Type'), namespace_, eol_))
        if self.Item_Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sItem_Description>%s</%sItem_Description>%s' % (namespace_, self.gds_format_string(quote_xml(self.Item_Description).encode(ExternalEncoding), input_name='Item_Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ConfigurationSettingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Item_Name is not None:
            showIndent(outfile, level)
            outfile.write('Item_Name=%s,\n' % quote_python(self.Item_Name).encode(ExternalEncoding))
        if self.Item_Value is not None:
            showIndent(outfile, level)
            outfile.write('Item_Value=%s,\n' % quote_python(self.Item_Value).encode(ExternalEncoding))
        if self.Item_Type is not None:
            showIndent(outfile, level)
            outfile.write('Item_Type=%s,\n' % quote_python(self.Item_Type).encode(ExternalEncoding))
        if self.Item_Description is not None:
            showIndent(outfile, level)
            outfile.write('Item_Description=%s,\n' % quote_python(self.Item_Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Item_Name':
            Item_Name_ = child_.text
            Item_Name_ = self.gds_validate_string(Item_Name_, node, 'Item_Name')
            self.Item_Name = Item_Name_
        elif nodeName_ == 'Item_Value':
            Item_Value_ = child_.text
            Item_Value_ = self.gds_validate_string(Item_Value_, node, 'Item_Value')
            self.Item_Value = Item_Value_
        elif nodeName_ == 'Item_Type':
            Item_Type_ = child_.text
            Item_Type_ = self.gds_validate_string(Item_Type_, node, 'Item_Type')
            self.Item_Type = Item_Type_
        elif nodeName_ == 'Item_Description':
            Item_Description_ = child_.text
            Item_Description_ = self.gds_validate_string(Item_Description_, node, 'Item_Description')
            self.Item_Description = Item_Description_
# end class ConfigurationSettingType


class DependenciesType(GeneratedsSuper):
    """The DependenciesType contains information describing a set of
    dependencies for this tool."""
    subclass = None
    superclass = None
    def __init__(self, Dependency=None):
        if Dependency is None:
            self.Dependency = []
        else:
            self.Dependency = Dependency
    def factory(*args_, **kwargs_):
        if DependenciesType.subclass:
            return DependenciesType.subclass(*args_, **kwargs_)
        else:
            return DependenciesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dependency(self): return self.Dependency
    def set_Dependency(self, Dependency): self.Dependency = Dependency
    def add_Dependency(self, value): self.Dependency.append(value)
    def insert_Dependency(self, index, value): self.Dependency[index] = value
    def hasContent_(self):
        if (
            self.Dependency
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DependenciesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DependenciesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DependenciesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DependenciesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dependency_ in self.Dependency:
            Dependency_.export(outfile, level, namespace_, name_='Dependency', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DependenciesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Dependency=[\n')
        level += 1
        for Dependency_ in self.Dependency:
            showIndent(outfile, level)
            outfile.write('model_.DependencyType(\n')
            Dependency_.exportLiteral(outfile, level, name_='DependencyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dependency':
            obj_ = DependencyType.factory()
            obj_.build(child_)
            self.Dependency.append(obj_)
# end class DependenciesType


class DependencyType(GeneratedsSuper):
    """The DependencyType contains information describing a single
    dependency for this tool."""
    subclass = None
    superclass = None
    def __init__(self, Dependency_Type=None, Dependency_Description=None):
        self.Dependency_Type = Dependency_Type
        self.Dependency_Description = Dependency_Description
    def factory(*args_, **kwargs_):
        if DependencyType.subclass:
            return DependencyType.subclass(*args_, **kwargs_)
        else:
            return DependencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dependency_Type(self): return self.Dependency_Type
    def set_Dependency_Type(self, Dependency_Type): self.Dependency_Type = Dependency_Type
    def get_Dependency_Description(self): return self.Dependency_Description
    def set_Dependency_Description(self, Dependency_Description): self.Dependency_Description = Dependency_Description
    def hasContent_(self):
        if (
            self.Dependency_Type is not None or
            self.Dependency_Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DependencyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DependencyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DependencyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DependencyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Dependency_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDependency_Type>%s</%sDependency_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.Dependency_Type).encode(ExternalEncoding), input_name='Dependency_Type'), namespace_, eol_))
        if self.Dependency_Description is not None:
            self.Dependency_Description.export(outfile, level, namespace_, name_='Dependency_Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DependencyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Dependency_Type is not None:
            showIndent(outfile, level)
            outfile.write('Dependency_Type=%s,\n' % quote_python(self.Dependency_Type).encode(ExternalEncoding))
        if self.Dependency_Description is not None:
            showIndent(outfile, level)
            outfile.write('Dependency_Description=model_.StructuredTextType(\n')
            self.Dependency_Description.exportLiteral(outfile, level, name_='Dependency_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dependency_Type':
            Dependency_Type_ = child_.text
            Dependency_Type_ = self.gds_validate_string(Dependency_Type_, node, 'Dependency_Type')
            self.Dependency_Type = Dependency_Type_
        elif nodeName_ == 'Dependency_Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Dependency_Description = obj_
# end class DependencyType


class UsageContextAssumptionsType(GeneratedsSuper):
    """The UsageContextAssumptionsType contains descriptions of the various
    relevant usage context assumptions for this tool"""
    subclass = None
    superclass = None
    def __init__(self, Usage_Context_Assumption=None):
        if Usage_Context_Assumption is None:
            self.Usage_Context_Assumption = []
        else:
            self.Usage_Context_Assumption = Usage_Context_Assumption
    def factory(*args_, **kwargs_):
        if UsageContextAssumptionsType.subclass:
            return UsageContextAssumptionsType.subclass(*args_, **kwargs_)
        else:
            return UsageContextAssumptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Usage_Context_Assumption(self): return self.Usage_Context_Assumption
    def set_Usage_Context_Assumption(self, Usage_Context_Assumption): self.Usage_Context_Assumption = Usage_Context_Assumption
    def add_Usage_Context_Assumption(self, value): self.Usage_Context_Assumption.append(value)
    def insert_Usage_Context_Assumption(self, index, value): self.Usage_Context_Assumption[index] = value
    def hasContent_(self):
        if (
            self.Usage_Context_Assumption
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='UsageContextAssumptionsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UsageContextAssumptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='UsageContextAssumptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='UsageContextAssumptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Usage_Context_Assumption_ in self.Usage_Context_Assumption:
            Usage_Context_Assumption_.export(outfile, level, namespace_, name_='Usage_Context_Assumption', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UsageContextAssumptionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Usage_Context_Assumption=[\n')
        level += 1
        for Usage_Context_Assumption_ in self.Usage_Context_Assumption:
            showIndent(outfile, level)
            outfile.write('model_.StructuredTextType(\n')
            Usage_Context_Assumption_.exportLiteral(outfile, level, name_='StructuredTextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Usage_Context_Assumption':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Usage_Context_Assumption.append(obj_)
# end class UsageContextAssumptionsType


class InternationalizationSettingsType(GeneratedsSuper):
    """The InternationalizationSettingsType contains information describing
    relevant internationalization setting for this tool"""
    subclass = None
    superclass = None
    def __init__(self, Internal_Strings=None):
        if Internal_Strings is None:
            self.Internal_Strings = []
        else:
            self.Internal_Strings = Internal_Strings
    def factory(*args_, **kwargs_):
        if InternationalizationSettingsType.subclass:
            return InternationalizationSettingsType.subclass(*args_, **kwargs_)
        else:
            return InternationalizationSettingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Internal_Strings(self): return self.Internal_Strings
    def set_Internal_Strings(self, Internal_Strings): self.Internal_Strings = Internal_Strings
    def add_Internal_Strings(self, value): self.Internal_Strings.append(value)
    def insert_Internal_Strings(self, index, value): self.Internal_Strings[index] = value
    def hasContent_(self):
        if (
            self.Internal_Strings
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='InternationalizationSettingsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InternationalizationSettingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='InternationalizationSettingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='InternationalizationSettingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Internal_Strings_ in self.Internal_Strings:
            Internal_Strings_.export(outfile, level, namespace_, name_='Internal_Strings', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InternationalizationSettingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Internal_Strings=[\n')
        level += 1
        for Internal_Strings_ in self.Internal_Strings:
            showIndent(outfile, level)
            outfile.write('model_.InternalStringsType(\n')
            Internal_Strings_.exportLiteral(outfile, level, name_='InternalStringsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Internal_Strings':
            obj_ = InternalStringsType.factory()
            obj_.build(child_)
            self.Internal_Strings.append(obj_)
# end class InternationalizationSettingsType


class InternalStringsType(GeneratedsSuper):
    """The InternalStringsType contains a single internal string instance
    for this internationalization setting instance."""
    subclass = None
    superclass = None
    def __init__(self, Key=None, Content=None):
        self.Key = Key
        self.Content = Content
    def factory(*args_, **kwargs_):
        if InternalStringsType.subclass:
            return InternalStringsType.subclass(*args_, **kwargs_)
        else:
            return InternalStringsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Content(self): return self.Content
    def set_Content(self, Content): self.Content = Content
    def hasContent_(self):
        if (
            self.Key is not None or
            self.Content is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='InternalStringsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InternalStringsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='InternalStringsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='InternalStringsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKey>%s</%sKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.Key).encode(ExternalEncoding), input_name='Key'), namespace_, eol_))
        if self.Content is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContent>%s</%sContent>%s' % (namespace_, self.gds_format_string(quote_xml(self.Content).encode(ExternalEncoding), input_name='Content'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InternalStringsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Key is not None:
            showIndent(outfile, level)
            outfile.write('Key=%s,\n' % quote_python(self.Key).encode(ExternalEncoding))
        if self.Content is not None:
            showIndent(outfile, level)
            outfile.write('Content=%s,\n' % quote_python(self.Content).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Key':
            Key_ = child_.text
            Key_ = self.gds_validate_string(Key_, node, 'Key')
            self.Key = Key_
        elif nodeName_ == 'Content':
            Content_ = child_.text
            Content_ = self.gds_validate_string(Content_, node, 'Content')
            self.Content = Content_
# end class InternalStringsType


class BuildInformationType(GeneratedsSuper):
    """The BuildInformationType contains information describing how this
    tool was built."""
    subclass = None
    superclass = None
    def __init__(self, Build_ID=None, Build_Project=None, Build_Utility=None, Build_Version=None, Build_Label=None, Compilers=None, Compilation_Date=None, Build_Configuration=None, Build_Script=None, Libraries=None, Build_Output_Log=None):
        self.Build_ID = Build_ID
        self.Build_Project = Build_Project
        self.Build_Utility = Build_Utility
        self.Build_Version = Build_Version
        self.Build_Label = Build_Label
        self.Compilers = Compilers
        if isinstance(Compilation_Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Compilation_Date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Compilation_Date
        self.Compilation_Date = initvalue_
        self.Build_Configuration = Build_Configuration
        self.Build_Script = Build_Script
        self.Libraries = Libraries
        self.Build_Output_Log = Build_Output_Log
    def factory(*args_, **kwargs_):
        if BuildInformationType.subclass:
            return BuildInformationType.subclass(*args_, **kwargs_)
        else:
            return BuildInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Build_ID(self): return self.Build_ID
    def set_Build_ID(self, Build_ID): self.Build_ID = Build_ID
    def get_Build_Project(self): return self.Build_Project
    def set_Build_Project(self, Build_Project): self.Build_Project = Build_Project
    def get_Build_Utility(self): return self.Build_Utility
    def set_Build_Utility(self, Build_Utility): self.Build_Utility = Build_Utility
    def get_Build_Version(self): return self.Build_Version
    def set_Build_Version(self, Build_Version): self.Build_Version = Build_Version
    def get_Build_Label(self): return self.Build_Label
    def set_Build_Label(self, Build_Label): self.Build_Label = Build_Label
    def get_Compilers(self): return self.Compilers
    def set_Compilers(self, Compilers): self.Compilers = Compilers
    def get_Compilation_Date(self): return self.Compilation_Date
    def set_Compilation_Date(self, Compilation_Date): self.Compilation_Date = Compilation_Date
    def get_Build_Configuration(self): return self.Build_Configuration
    def set_Build_Configuration(self, Build_Configuration): self.Build_Configuration = Build_Configuration
    def get_Build_Script(self): return self.Build_Script
    def set_Build_Script(self, Build_Script): self.Build_Script = Build_Script
    def get_Libraries(self): return self.Libraries
    def set_Libraries(self, Libraries): self.Libraries = Libraries
    def get_Build_Output_Log(self): return self.Build_Output_Log
    def set_Build_Output_Log(self, Build_Output_Log): self.Build_Output_Log = Build_Output_Log
    def hasContent_(self):
        if (
            self.Build_ID is not None or
            self.Build_Project is not None or
            self.Build_Utility is not None or
            self.Build_Version is not None or
            self.Build_Label is not None or
            self.Compilers is not None or
            self.Compilation_Date is not None or
            self.Build_Configuration is not None or
            self.Build_Script is not None or
            self.Libraries is not None or
            self.Build_Output_Log is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BuildInformationType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BuildInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BuildInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BuildInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Build_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuild_ID>%s</%sBuild_ID>%s' % (namespace_, self.gds_format_string(quote_xml(self.Build_ID).encode(ExternalEncoding), input_name='Build_ID'), namespace_, eol_))
        if self.Build_Project is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuild_Project>%s</%sBuild_Project>%s' % (namespace_, self.gds_format_string(quote_xml(self.Build_Project).encode(ExternalEncoding), input_name='Build_Project'), namespace_, eol_))
        if self.Build_Utility is not None:
            self.Build_Utility.export(outfile, level, namespace_, name_='Build_Utility', pretty_print=pretty_print)
        if self.Build_Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuild_Version>%s</%sBuild_Version>%s' % (namespace_, self.gds_format_string(quote_xml(self.Build_Version).encode(ExternalEncoding), input_name='Build_Version'), namespace_, eol_))
        if self.Build_Label is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuild_Label>%s</%sBuild_Label>%s' % (namespace_, self.gds_format_string(quote_xml(self.Build_Label).encode(ExternalEncoding), input_name='Build_Label'), namespace_, eol_))
        if self.Compilers is not None:
            self.Compilers.export(outfile, level, namespace_, name_='Compilers', pretty_print=pretty_print)
        if self.Compilation_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompilation_Date>%s</%sCompilation_Date>%s' % (namespace_, self.gds_format_datetime(self.Compilation_Date, input_name='Compilation_Date'), namespace_, eol_))
        if self.Build_Configuration is not None:
            self.Build_Configuration.export(outfile, level, namespace_, name_='Build_Configuration', pretty_print=pretty_print)
        if self.Build_Script is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuild_Script>%s</%sBuild_Script>%s' % (namespace_, self.gds_format_string(quote_xml(self.Build_Script).encode(ExternalEncoding), input_name='Build_Script'), namespace_, eol_))
        if self.Libraries is not None:
            self.Libraries.export(outfile, level, namespace_, name_='Libraries', pretty_print=pretty_print)
        if self.Build_Output_Log is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuild_Output_Log>%s</%sBuild_Output_Log>%s' % (namespace_, self.gds_format_string(quote_xml(self.Build_Output_Log).encode(ExternalEncoding), input_name='Build_Output_Log'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='BuildInformationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Build_ID is not None:
            showIndent(outfile, level)
            outfile.write('Build_ID=%s,\n' % quote_python(self.Build_ID).encode(ExternalEncoding))
        if self.Build_Project is not None:
            showIndent(outfile, level)
            outfile.write('Build_Project=%s,\n' % quote_python(self.Build_Project).encode(ExternalEncoding))
        if self.Build_Utility is not None:
            showIndent(outfile, level)
            outfile.write('Build_Utility=model_.BuildUtilityType(\n')
            self.Build_Utility.exportLiteral(outfile, level, name_='Build_Utility')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Build_Version is not None:
            showIndent(outfile, level)
            outfile.write('Build_Version=%s,\n' % quote_python(self.Build_Version).encode(ExternalEncoding))
        if self.Build_Label is not None:
            showIndent(outfile, level)
            outfile.write('Build_Label=%s,\n' % quote_python(self.Build_Label).encode(ExternalEncoding))
        if self.Compilers is not None:
            showIndent(outfile, level)
            outfile.write('Compilers=model_.CompilersType(\n')
            self.Compilers.exportLiteral(outfile, level, name_='Compilers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Compilation_Date is not None:
            showIndent(outfile, level)
            outfile.write('Compilation_Date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Compilation_Date, input_name='Compilation_Date'))
        if self.Build_Configuration is not None:
            showIndent(outfile, level)
            outfile.write('Build_Configuration=model_.BuildConfigurationType(\n')
            self.Build_Configuration.exportLiteral(outfile, level, name_='Build_Configuration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Build_Script is not None:
            showIndent(outfile, level)
            outfile.write('Build_Script=%s,\n' % quote_python(self.Build_Script).encode(ExternalEncoding))
        if self.Libraries is not None:
            showIndent(outfile, level)
            outfile.write('Libraries=model_.LibrariesType(\n')
            self.Libraries.exportLiteral(outfile, level, name_='Libraries')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Build_Output_Log is not None:
            showIndent(outfile, level)
            outfile.write('Build_Output_Log=%s,\n' % quote_python(self.Build_Output_Log).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Build_ID':
            Build_ID_ = child_.text
            Build_ID_ = self.gds_validate_string(Build_ID_, node, 'Build_ID')
            self.Build_ID = Build_ID_
        elif nodeName_ == 'Build_Project':
            Build_Project_ = child_.text
            Build_Project_ = self.gds_validate_string(Build_Project_, node, 'Build_Project')
            self.Build_Project = Build_Project_
        elif nodeName_ == 'Build_Utility':
            obj_ = BuildUtilityType.factory()
            obj_.build(child_)
            self.Build_Utility = obj_
        elif nodeName_ == 'Build_Version':
            Build_Version_ = child_.text
            Build_Version_ = self.gds_validate_string(Build_Version_, node, 'Build_Version')
            self.Build_Version = Build_Version_
        elif nodeName_ == 'Build_Label':
            Build_Label_ = child_.text
            Build_Label_ = self.gds_validate_string(Build_Label_, node, 'Build_Label')
            self.Build_Label = Build_Label_
        elif nodeName_ == 'Compilers':
            obj_ = CompilersType.factory()
            obj_.build(child_)
            self.Compilers = obj_
        elif nodeName_ == 'Compilation_Date':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Compilation_Date = dval_
        elif nodeName_ == 'Build_Configuration':
            obj_ = BuildConfigurationType.factory()
            obj_.build(child_)
            self.Build_Configuration = obj_
        elif nodeName_ == 'Build_Script':
            Build_Script_ = child_.text
            Build_Script_ = self.gds_validate_string(Build_Script_, node, 'Build_Script')
            self.Build_Script = Build_Script_
        elif nodeName_ == 'Libraries':
            obj_ = LibrariesType.factory()
            obj_.build(child_)
            self.Libraries = obj_
        elif nodeName_ == 'Build_Output_Log':
            Build_Output_Log_ = child_.text
            Build_Output_Log_ = self.gds_validate_string(Build_Output_Log_, node, 'Build_Output_Log')
            self.Build_Output_Log = Build_Output_Log_
# end class BuildInformationType


class BuildUtilityType(GeneratedsSuper):
    """The BuildUtilityType contains information identifying the utility
    used to build this application."""
    subclass = None
    superclass = None
    def __init__(self, Build_Utility_Name=None, Build_Utility_Platform_Specification=None):
        self.Build_Utility_Name = Build_Utility_Name
        self.Build_Utility_Platform_Specification = Build_Utility_Platform_Specification
    def factory(*args_, **kwargs_):
        if BuildUtilityType.subclass:
            return BuildUtilityType.subclass(*args_, **kwargs_)
        else:
            return BuildUtilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Build_Utility_Name(self): return self.Build_Utility_Name
    def set_Build_Utility_Name(self, Build_Utility_Name): self.Build_Utility_Name = Build_Utility_Name
    def get_Build_Utility_Platform_Specification(self): return self.Build_Utility_Platform_Specification
    def set_Build_Utility_Platform_Specification(self, Build_Utility_Platform_Specification): self.Build_Utility_Platform_Specification = Build_Utility_Platform_Specification
    def hasContent_(self):
        if (
            self.Build_Utility_Name is not None or
            self.Build_Utility_Platform_Specification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BuildUtilityType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BuildUtilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BuildUtilityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BuildUtilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Build_Utility_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuild_Utility_Name>%s</%sBuild_Utility_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.Build_Utility_Name).encode(ExternalEncoding), input_name='Build_Utility_Name'), namespace_, eol_))
        if self.Build_Utility_Platform_Specification is not None:
            self.Build_Utility_Platform_Specification.export(outfile, level, namespace_, name_='Build_Utility_Platform_Specification', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BuildUtilityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Build_Utility_Name is not None:
            showIndent(outfile, level)
            outfile.write('Build_Utility_Name=%s,\n' % quote_python(self.Build_Utility_Name).encode(ExternalEncoding))
        if self.Build_Utility_Platform_Specification is not None:
            showIndent(outfile, level)
            outfile.write('Build_Utility_Platform_Specification=model_.PlatformSpecificationType(\n')
            self.Build_Utility_Platform_Specification.exportLiteral(outfile, level, name_='Build_Utility_Platform_Specification')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Build_Utility_Name':
            Build_Utility_Name_ = child_.text
            Build_Utility_Name_ = self.gds_validate_string(Build_Utility_Name_, node, 'Build_Utility_Name')
            self.Build_Utility_Name = Build_Utility_Name_
        elif nodeName_ == 'Build_Utility_Platform_Specification':
            obj_ = PlatformSpecificationType.factory()
            obj_.build(child_)
            self.Build_Utility_Platform_Specification = obj_
# end class BuildUtilityType


class CompilersType(GeneratedsSuper):
    """The CompilersType describes the compilers utilized during this build
    of this application."""
    subclass = None
    superclass = None
    def __init__(self, Compiler=None):
        if Compiler is None:
            self.Compiler = []
        else:
            self.Compiler = Compiler
    def factory(*args_, **kwargs_):
        if CompilersType.subclass:
            return CompilersType.subclass(*args_, **kwargs_)
        else:
            return CompilersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Compiler(self): return self.Compiler
    def set_Compiler(self, Compiler): self.Compiler = Compiler
    def add_Compiler(self, value): self.Compiler.append(value)
    def insert_Compiler(self, index, value): self.Compiler[index] = value
    def hasContent_(self):
        if (
            self.Compiler
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CompilersType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompilersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CompilersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CompilersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Compiler_ in self.Compiler:
            Compiler_.export(outfile, level, namespace_, name_='Compiler', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CompilersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Compiler=[\n')
        level += 1
        for Compiler_ in self.Compiler:
            showIndent(outfile, level)
            outfile.write('model_.CompilerType(\n')
            Compiler_.exportLiteral(outfile, level, name_='CompilerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Compiler':
            obj_ = CompilerType.factory()
            obj_.build(child_)
            self.Compiler.append(obj_)
# end class CompilersType


class CompilerType(GeneratedsSuper):
    """The CompilerType describes a single compiler utilized during this
    build of this application."""
    subclass = None
    superclass = None
    def __init__(self, Compiler_Informal_Description=None, Compiler_Platform_Specification=None):
        self.Compiler_Informal_Description = Compiler_Informal_Description
        self.Compiler_Platform_Specification = Compiler_Platform_Specification
    def factory(*args_, **kwargs_):
        if CompilerType.subclass:
            return CompilerType.subclass(*args_, **kwargs_)
        else:
            return CompilerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Compiler_Informal_Description(self): return self.Compiler_Informal_Description
    def set_Compiler_Informal_Description(self, Compiler_Informal_Description): self.Compiler_Informal_Description = Compiler_Informal_Description
    def get_Compiler_Platform_Specification(self): return self.Compiler_Platform_Specification
    def set_Compiler_Platform_Specification(self, Compiler_Platform_Specification): self.Compiler_Platform_Specification = Compiler_Platform_Specification
    def hasContent_(self):
        if (
            self.Compiler_Informal_Description is not None or
            self.Compiler_Platform_Specification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CompilerType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompilerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CompilerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CompilerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Compiler_Informal_Description is not None:
            self.Compiler_Informal_Description.export(outfile, level, namespace_, name_='Compiler_Informal_Description', pretty_print=pretty_print)
        if self.Compiler_Platform_Specification is not None:
            self.Compiler_Platform_Specification.export(outfile, level, namespace_, name_='Compiler_Platform_Specification', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CompilerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Compiler_Informal_Description is not None:
            showIndent(outfile, level)
            outfile.write('Compiler_Informal_Description=model_.CompilerInformalDescriptionType(\n')
            self.Compiler_Informal_Description.exportLiteral(outfile, level, name_='Compiler_Informal_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Compiler_Platform_Specification is not None:
            showIndent(outfile, level)
            outfile.write('Compiler_Platform_Specification=model_.PlatformSpecificationType(\n')
            self.Compiler_Platform_Specification.exportLiteral(outfile, level, name_='Compiler_Platform_Specification')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Compiler_Informal_Description':
            obj_ = CompilerInformalDescriptionType.factory()
            obj_.build(child_)
            self.Compiler_Informal_Description = obj_
        elif nodeName_ == 'Compiler_Platform_Specification':
            obj_ = PlatformSpecificationType.factory()
            obj_.build(child_)
            self.Compiler_Platform_Specification = obj_
# end class CompilerType


class CompilerInformalDescriptionType(GeneratedsSuper):
    """The CompilerInformalDescriptionType contains the informal
    description of this compiler instance."""
    subclass = None
    superclass = None
    def __init__(self, Compiler_Name=None, Compiler_Version=None):
        self.Compiler_Name = Compiler_Name
        self.Compiler_Version = Compiler_Version
    def factory(*args_, **kwargs_):
        if CompilerInformalDescriptionType.subclass:
            return CompilerInformalDescriptionType.subclass(*args_, **kwargs_)
        else:
            return CompilerInformalDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Compiler_Name(self): return self.Compiler_Name
    def set_Compiler_Name(self, Compiler_Name): self.Compiler_Name = Compiler_Name
    def get_Compiler_Version(self): return self.Compiler_Version
    def set_Compiler_Version(self, Compiler_Version): self.Compiler_Version = Compiler_Version
    def hasContent_(self):
        if (
            self.Compiler_Name is not None or
            self.Compiler_Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CompilerInformalDescriptionType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompilerInformalDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CompilerInformalDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CompilerInformalDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Compiler_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompiler_Name>%s</%sCompiler_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.Compiler_Name).encode(ExternalEncoding), input_name='Compiler_Name'), namespace_, eol_))
        if self.Compiler_Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompiler_Version>%s</%sCompiler_Version>%s' % (namespace_, self.gds_format_string(quote_xml(self.Compiler_Version).encode(ExternalEncoding), input_name='Compiler_Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CompilerInformalDescriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Compiler_Name is not None:
            showIndent(outfile, level)
            outfile.write('Compiler_Name=%s,\n' % quote_python(self.Compiler_Name).encode(ExternalEncoding))
        if self.Compiler_Version is not None:
            showIndent(outfile, level)
            outfile.write('Compiler_Version=%s,\n' % quote_python(self.Compiler_Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Compiler_Name':
            Compiler_Name_ = child_.text
            Compiler_Name_ = self.gds_validate_string(Compiler_Name_, node, 'Compiler_Name')
            self.Compiler_Name = Compiler_Name_
        elif nodeName_ == 'Compiler_Version':
            Compiler_Version_ = child_.text
            Compiler_Version_ = self.gds_validate_string(Compiler_Version_, node, 'Compiler_Version')
            self.Compiler_Version = Compiler_Version_
# end class CompilerInformalDescriptionType


class BuildConfigurationType(GeneratedsSuper):
    """The BuildConfigurationType describes how the build utility was
    configured for this build of this application."""
    subclass = None
    superclass = None
    def __init__(self, Configuration_Setting_Description=None, Configuration_Settings=None):
        self.Configuration_Setting_Description = Configuration_Setting_Description
        self.Configuration_Settings = Configuration_Settings
    def factory(*args_, **kwargs_):
        if BuildConfigurationType.subclass:
            return BuildConfigurationType.subclass(*args_, **kwargs_)
        else:
            return BuildConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration_Setting_Description(self): return self.Configuration_Setting_Description
    def set_Configuration_Setting_Description(self, Configuration_Setting_Description): self.Configuration_Setting_Description = Configuration_Setting_Description
    def get_Configuration_Settings(self): return self.Configuration_Settings
    def set_Configuration_Settings(self, Configuration_Settings): self.Configuration_Settings = Configuration_Settings
    def hasContent_(self):
        if (
            self.Configuration_Setting_Description is not None or
            self.Configuration_Settings is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BuildConfigurationType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BuildConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BuildConfigurationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BuildConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Configuration_Setting_Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConfiguration_Setting_Description>%s</%sConfiguration_Setting_Description>%s' % (namespace_, self.gds_format_string(quote_xml(self.Configuration_Setting_Description).encode(ExternalEncoding), input_name='Configuration_Setting_Description'), namespace_, eol_))
        if self.Configuration_Settings is not None:
            self.Configuration_Settings.export(outfile, level, namespace_, name_='Configuration_Settings', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BuildConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Configuration_Setting_Description is not None:
            showIndent(outfile, level)
            outfile.write('Configuration_Setting_Description=%s,\n' % quote_python(self.Configuration_Setting_Description).encode(ExternalEncoding))
        if self.Configuration_Settings is not None:
            showIndent(outfile, level)
            outfile.write('Configuration_Settings=model_.ConfigurationSettingsType(\n')
            self.Configuration_Settings.exportLiteral(outfile, level, name_='Configuration_Settings')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration_Setting_Description':
            Configuration_Setting_Description_ = child_.text
            Configuration_Setting_Description_ = self.gds_validate_string(Configuration_Setting_Description_, node, 'Configuration_Setting_Description')
            self.Configuration_Setting_Description = Configuration_Setting_Description_
        elif nodeName_ == 'Configuration_Settings':
            obj_ = ConfigurationSettingsType.factory()
            obj_.build(child_)
            self.Configuration_Settings = obj_
# end class BuildConfigurationType


class LibrariesType(GeneratedsSuper):
    """The LibrariesType identifies the libraries incorporated into the
    build of the tool."""
    subclass = None
    superclass = None
    def __init__(self, Library=None):
        self.Library = Library
    def factory(*args_, **kwargs_):
        if LibrariesType.subclass:
            return LibrariesType.subclass(*args_, **kwargs_)
        else:
            return LibrariesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Library(self): return self.Library
    def set_Library(self, Library): self.Library = Library
    def hasContent_(self):
        if (
            self.Library is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='LibrariesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LibrariesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='LibrariesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='LibrariesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Library is not None:
            self.Library.export(outfile, level, namespace_, name_='Library', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LibrariesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Library is not None:
            showIndent(outfile, level)
            outfile.write('Library=model_.LibraryType(\n')
            self.Library.exportLiteral(outfile, level, name_='Library')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Library':
            obj_ = LibraryType.factory()
            obj_.build(child_)
            self.Library = obj_
# end class LibrariesType


class LibraryType(GeneratedsSuper):
    """The LibraryType identifies a single library incorporated into the
    build of the tool.This field identifies the name of the
    library.This field identifies the version of the library."""
    subclass = None
    superclass = None
    def __init__(self, version=None, name=None):
        self.version = _cast(None, version)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if LibraryType.subclass:
            return LibraryType.subclass(*args_, **kwargs_)
        else:
            return LibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='LibraryType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='LibraryType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='LibraryType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LibraryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LibraryType


class ExecutionEnvironmentType(GeneratedsSuper):
    """The ExecutionEnvironmentType contains information describing the
    execution environment of the tool."""
    subclass = None
    superclass = None
    def __init__(self, System=None, User_Account_Info=None, Command_Line=None, Start_Time=None):
        self.System = System
        self.User_Account_Info = User_Account_Info
        self.Command_Line = Command_Line
        if isinstance(Start_Time, basestring):
            initvalue_ = datetime_.datetime.strptime(Start_Time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Start_Time
        self.Start_Time = initvalue_
    def factory(*args_, **kwargs_):
        if ExecutionEnvironmentType.subclass:
            return ExecutionEnvironmentType.subclass(*args_, **kwargs_)
        else:
            return ExecutionEnvironmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_System(self): return self.System
    def set_System(self, System): self.System = System
    def get_User_Account_Info(self): return self.User_Account_Info
    def set_User_Account_Info(self, User_Account_Info): self.User_Account_Info = User_Account_Info
    def get_Command_Line(self): return self.Command_Line
    def set_Command_Line(self, Command_Line): self.Command_Line = Command_Line
    def get_Start_Time(self): return self.Start_Time
    def set_Start_Time(self, Start_Time): self.Start_Time = Start_Time
    def hasContent_(self):
        if (
            self.System is not None or
            self.User_Account_Info is not None or
            self.Command_Line is not None or
            self.Start_Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ExecutionEnvironmentType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecutionEnvironmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ExecutionEnvironmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ExecutionEnvironmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.System is not None:
            self.System.export(outfile, level, namespace_, name_='System', pretty_print=pretty_print)
        if self.User_Account_Info is not None:
            self.User_Account_Info.export(outfile, level, namespace_, name_='User_Account_Info', pretty_print=pretty_print)
        if self.Command_Line is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCommand_Line>%s</%sCommand_Line>%s' % (namespace_, self.gds_format_string(quote_xml(self.Command_Line).encode(ExternalEncoding), input_name='Command_Line'), namespace_, eol_))
        if self.Start_Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStart_Time>%s</%sStart_Time>%s' % (namespace_, self.gds_format_datetime(self.Start_Time, input_name='Start_Time'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ExecutionEnvironmentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ObjectPropertiesType is not None:
            showIndent(outfile, level)
            outfile.write('ObjectPropertiesType=model_.ObjectPropertiesType(\n')
            self.ObjectPropertiesType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectPropertiesType is not None:
            showIndent(outfile, level)
            outfile.write('ObjectPropertiesType=model_.ObjectPropertiesType(\n')
            self.ObjectPropertiesType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Command_Line is not None:
            showIndent(outfile, level)
            outfile.write('Command_Line=%s,\n' % quote_python(self.Command_Line).encode(ExternalEncoding))
        if self.Start_Time is not None:
            showIndent(outfile, level)
            outfile.write('Start_Time=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Start_Time, input_name='Start_Time'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'System':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <System> element')
            self.System = obj_
        elif nodeName_ == 'User_Account_Info':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <User_Account_Info> element')
            self.User_Account_Info = obj_
        elif nodeName_ == 'Command_Line':
            Command_Line_ = child_.text
            Command_Line_ = self.gds_validate_string(Command_Line_, node, 'Command_Line')
            self.Command_Line = Command_Line_
        elif nodeName_ == 'Start_Time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Start_Time = dval_
# end class ExecutionEnvironmentType


class ErrorsType(GeneratedsSuper):
    """The ErrorsType captures any errors generated during the run of the
    tool."""
    subclass = None
    superclass = None
    def __init__(self, Error=None):
        if Error is None:
            self.Error = []
        else:
            self.Error = Error
    def factory(*args_, **kwargs_):
        if ErrorsType.subclass:
            return ErrorsType.subclass(*args_, **kwargs_)
        else:
            return ErrorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Error(self): return self.Error
    def set_Error(self, Error): self.Error = Error
    def add_Error(self, value): self.Error.append(value)
    def insert_Error(self, index, value): self.Error[index] = value
    def hasContent_(self):
        if (
            self.Error
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ErrorsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ErrorsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ErrorsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Error_ in self.Error:
            Error_.export(outfile, level, namespace_, name_='Error', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ErrorsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Error=[\n')
        level += 1
        for Error_ in self.Error:
            showIndent(outfile, level)
            outfile.write('model_.ErrorType(\n')
            Error_.exportLiteral(outfile, level, name_='ErrorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Error':
            obj_ = ErrorType.factory()
            obj_.build(child_)
            self.Error.append(obj_)
# end class ErrorsType


class ErrorType(GeneratedsSuper):
    """The ErrorType captures a single error generated during the run of
    the tool."""
    subclass = None
    superclass = None
    def __init__(self, Error_Type=None, Error_Count=None, Error_Instances=None):
        self.Error_Type = Error_Type
        self.Error_Count = Error_Count
        self.Error_Instances = Error_Instances
    def factory(*args_, **kwargs_):
        if ErrorType.subclass:
            return ErrorType.subclass(*args_, **kwargs_)
        else:
            return ErrorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Error_Type(self): return self.Error_Type
    def set_Error_Type(self, Error_Type): self.Error_Type = Error_Type
    def get_Error_Count(self): return self.Error_Count
    def set_Error_Count(self, Error_Count): self.Error_Count = Error_Count
    def get_Error_Instances(self): return self.Error_Instances
    def set_Error_Instances(self, Error_Instances): self.Error_Instances = Error_Instances
    def hasContent_(self):
        if (
            self.Error_Type is not None or
            self.Error_Count is not None or
            self.Error_Instances is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ErrorType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ErrorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ErrorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Error_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sError_Type>%s</%sError_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.Error_Type).encode(ExternalEncoding), input_name='Error_Type'), namespace_, eol_))
        if self.Error_Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sError_Count>%s</%sError_Count>%s' % (namespace_, self.gds_format_integer(self.Error_Count, input_name='Error_Count'), namespace_, eol_))
        if self.Error_Instances is not None:
            self.Error_Instances.export(outfile, level, namespace_, name_='Error_Instances', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ErrorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Error_Type is not None:
            showIndent(outfile, level)
            outfile.write('Error_Type=%s,\n' % quote_python(self.Error_Type).encode(ExternalEncoding))
        if self.Error_Count is not None:
            showIndent(outfile, level)
            outfile.write('Error_Count=%d,\n' % self.Error_Count)
        if self.Error_Instances is not None:
            showIndent(outfile, level)
            outfile.write('Error_Instances=model_.ErrorInstancesType(\n')
            self.Error_Instances.exportLiteral(outfile, level, name_='Error_Instances')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Error_Type':
            Error_Type_ = child_.text
            Error_Type_ = self.gds_validate_string(Error_Type_, node, 'Error_Type')
            self.Error_Type = Error_Type_
        elif nodeName_ == 'Error_Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Error_Count')
            self.Error_Count = ival_
        elif nodeName_ == 'Error_Instances':
            obj_ = ErrorInstancesType.factory()
            obj_.build(child_)
            self.Error_Instances = obj_
# end class ErrorType


class ErrorInstancesType(GeneratedsSuper):
    """The ErrorInstancesType captures the actual error output for each
    instance of this type of error."""
    subclass = None
    superclass = None
    def __init__(self, Error_Instance=None):
        if Error_Instance is None:
            self.Error_Instance = []
        else:
            self.Error_Instance = Error_Instance
    def factory(*args_, **kwargs_):
        if ErrorInstancesType.subclass:
            return ErrorInstancesType.subclass(*args_, **kwargs_)
        else:
            return ErrorInstancesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Error_Instance(self): return self.Error_Instance
    def set_Error_Instance(self, Error_Instance): self.Error_Instance = Error_Instance
    def add_Error_Instance(self, value): self.Error_Instance.append(value)
    def insert_Error_Instance(self, index, value): self.Error_Instance[index] = value
    def hasContent_(self):
        if (
            self.Error_Instance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ErrorInstancesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorInstancesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ErrorInstancesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ErrorInstancesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Error_Instance_ in self.Error_Instance:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sError_Instance>%s</%sError_Instance>%s' % (namespace_, self.gds_format_string(quote_xml(Error_Instance_).encode(ExternalEncoding), input_name='Error_Instance'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ErrorInstancesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Error_Instance=[\n')
        level += 1
        for Error_Instance_ in self.Error_Instance:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Error_Instance_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Error_Instance':
            Error_Instance_ = child_.text
            Error_Instance_ = self.gds_validate_string(Error_Instance_, node, 'Error_Instance')
            self.Error_Instance.append(Error_Instance_)
# end class ErrorInstancesType


class ObjectPropertiesType(GeneratedsSuper):
    """The ObjectPropertiesType is an Abstract type placeholder within the
    CybOX schema enabling the inclusion of contextually varying
    object properties descriptions. This Abstract type is leveraged
    as the extension base for all predefined CybOX object properties
    schemas. Through this extension mechanism any object instance
    data based on an object properties schema extended from
    ObjectPropertiesType (e.g. File_Object, Address_Object, etc.)
    can be directly integrated into any instance document where a
    field is defined as ObjectPropertiesType. For flexibility and
    extensibility purposes any user of CybOX can specify their own
    externally defined object properties schemas (outside of or
    derived from the set of predefined objects) extended from
    ObjectPropertiesType and utilize them as part of their CybOX
    content.The object_reference field specifies a unique ID
    reference to an Object defined elsewhere. This construct allows
    for the re-use of the defined Properties of one Object within
    another, without the need to embed the full Object in the
    location from which it is being referenced. Thus, this ID
    reference is intended to resolve to the Properties of the Object
    that it points to."""
    subclass = None
    superclass = None
    def __init__(self, object_reference=None, Custom_Properties=None, extensiontype_=None):
        self.object_reference = _cast(None, object_reference)
        self.Custom_Properties = Custom_Properties
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ObjectPropertiesType.subclass:
            return ObjectPropertiesType.subclass(*args_, **kwargs_)
        else:
            return ObjectPropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Custom_Properties(self): return self.Custom_Properties
    def set_Custom_Properties(self, Custom_Properties): self.Custom_Properties = Custom_Properties
    def get_object_reference(self): return self.object_reference
    def set_object_reference(self, object_reference): self.object_reference = object_reference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Custom_Properties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectPropertiesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectPropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectPropertiesType'):
        if self.object_reference is not None and 'object_reference' not in already_processed:
            already_processed.add('object_reference')
            outfile.write(' object_reference=%s' % (quote_attrib(self.object_reference), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectPropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Custom_Properties is not None:
            self.Custom_Properties.export(outfile, level, namespace_, name_='Custom_Properties', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectPropertiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.object_reference is not None and 'object_reference' not in already_processed:
            already_processed.add('object_reference')
            showIndent(outfile, level)
            outfile.write('object_reference=%s,\n' % (self.object_reference,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Custom_Properties is not None:
            showIndent(outfile, level)
            outfile.write('Custom_Properties=model_.CustomPropertiesType(\n')
            self.Custom_Properties.exportLiteral(outfile, level, name_='Custom_Properties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('object_reference', node)
        if value is not None and 'object_reference' not in already_processed:
            already_processed.add('object_reference')
            self.object_reference = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Custom_Properties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.Custom_Properties = obj_
# end class ObjectPropertiesType


class CustomPropertiesType(GeneratedsSuper):
    """The CustomPropertiesType enables the specification of a set of
    custom Object Properties that may not be defined in existing
    Properties schemas."""
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if CustomPropertiesType.subclass:
            return CustomPropertiesType.subclass(*args_, **kwargs_)
        else:
            return CustomPropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CustomPropertiesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomPropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CustomPropertiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CustomPropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomPropertiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
# end class CustomPropertiesType


class BaseObjectPropertyType(GeneratedsSuper):
    """The BaseObjectPropertyType is a type representing a common typing
    foundation for the specification of a single Object
    Property.Properties that use this type can express multiple
    values by providing them using a comma separated list. As such,
    a comma is a reserved character in all uses of this type. Commas
    in values should be expressed as &comma; (that is,
    ampersand-"comma"-semicolon). Such expressions should be
    converted back to a comma before displaying to users or handing
    off values to tools for processing. Note that whitespace is
    preserved and so, when specifying a list of values, do not
    include a space following a comma in a list unless the first
    character of the next list item should, in fact, be a space."""
    subclass = None
    superclass = None
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None, extensiontype_=None):
        self.obfuscation_algorithm_ref = _cast(None, obfuscation_algorithm_ref)
        self.refanging_transform_type = _cast(None, refanging_transform_type)
        self.has_changed = _cast(bool, has_changed)
        self.pattern_type = _cast(None, pattern_type)
        self.datatype = _cast(None, datatype)
        self.refanging_transform = _cast(None, refanging_transform)
        self.bit_mask = _cast(None, bit_mask)
        self.appears_random = _cast(bool, appears_random)
        self.trend = _cast(bool, trend)
        self.defanging_algorithm_ref = _cast(None, defanging_algorithm_ref)
        self.is_obfuscated = _cast(bool, is_obfuscated)
        self.regex_syntax = _cast(None, regex_syntax)
        self.apply_condition = _cast(None, apply_condition)
        self.idref = _cast(None, idref)
        self.is_defanged = _cast(bool, is_defanged)
        self.id = _cast(None, id)
        self.condition = _cast(None, condition)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if BaseObjectPropertyType.subclass:
            return BaseObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return BaseObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_obfuscation_algorithm_ref(self): return self.obfuscation_algorithm_ref
    def set_obfuscation_algorithm_ref(self, obfuscation_algorithm_ref): self.obfuscation_algorithm_ref = obfuscation_algorithm_ref
    def get_refanging_transform_type(self): return self.refanging_transform_type
    def set_refanging_transform_type(self, refanging_transform_type): self.refanging_transform_type = refanging_transform_type
    def get_has_changed(self): return self.has_changed
    def set_has_changed(self, has_changed): self.has_changed = has_changed
    def get_pattern_type(self): return self.pattern_type
    def set_pattern_type(self, pattern_type): self.pattern_type = pattern_type
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_refanging_transform(self): return self.refanging_transform
    def set_refanging_transform(self, refanging_transform): self.refanging_transform = refanging_transform
    def get_bit_mask(self): return self.bit_mask
    def set_bit_mask(self, bit_mask): self.bit_mask = bit_mask
    def get_appears_random(self): return self.appears_random
    def set_appears_random(self, appears_random): self.appears_random = appears_random
    def get_trend(self): return self.trend
    def set_trend(self, trend): self.trend = trend
    def get_defanging_algorithm_ref(self): return self.defanging_algorithm_ref
    def set_defanging_algorithm_ref(self, defanging_algorithm_ref): self.defanging_algorithm_ref = defanging_algorithm_ref
    def get_is_obfuscated(self): return self.is_obfuscated
    def set_is_obfuscated(self, is_obfuscated): self.is_obfuscated = is_obfuscated
    def get_regex_syntax(self): return self.regex_syntax
    def set_regex_syntax(self, regex_syntax): self.regex_syntax = regex_syntax
    def get_apply_condition(self): return self.apply_condition
    def set_apply_condition(self, apply_condition): self.apply_condition = apply_condition
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_is_defanged(self): return self.is_defanged
    def set_is_defanged(self, is_defanged): self.is_defanged = is_defanged
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BaseObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaseObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BaseObjectPropertyType'):
        if self.obfuscation_algorithm_ref is not None and 'obfuscation_algorithm_ref' not in already_processed:
            already_processed.add('obfuscation_algorithm_ref')
            outfile.write(' obfuscation_algorithm_ref=%s' % (self.gds_format_string(quote_attrib(self.obfuscation_algorithm_ref).encode(ExternalEncoding), input_name='obfuscation_algorithm_ref'), ))
        if self.refanging_transform_type is not None and 'refanging_transform_type' not in already_processed:
            already_processed.add('refanging_transform_type')
            outfile.write(' refanging_transform_type=%s' % (self.gds_format_string(quote_attrib(self.refanging_transform_type).encode(ExternalEncoding), input_name='refanging_transform_type'), ))
        if self.has_changed is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            outfile.write(' has_changed="%s"' % self.gds_format_boolean(self.has_changed, input_name='has_changed'))
        if self.pattern_type is not None and 'pattern_type' not in already_processed:
            already_processed.add('pattern_type')
            outfile.write(' pattern_type=%s' % (quote_attrib(self.pattern_type), ))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.refanging_transform is not None and 'refanging_transform' not in already_processed:
            already_processed.add('refanging_transform')
            outfile.write(' refanging_transform=%s' % (self.gds_format_string(quote_attrib(self.refanging_transform).encode(ExternalEncoding), input_name='refanging_transform'), ))
        if self.bit_mask is not None and 'bit_mask' not in already_processed:
            already_processed.add('bit_mask')
            outfile.write(' bit_mask=%s' % (self.gds_format_string(quote_attrib(self.bit_mask).encode(ExternalEncoding), input_name='bit_mask'), ))
        if self.appears_random is not None and 'appears_random' not in already_processed:
            already_processed.add('appears_random')
            outfile.write(' appears_random="%s"' % self.gds_format_boolean(self.appears_random, input_name='appears_random'))
        if self.trend is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            outfile.write(' trend="%s"' % self.gds_format_boolean(self.trend, input_name='trend'))
        if self.defanging_algorithm_ref is not None and 'defanging_algorithm_ref' not in already_processed:
            already_processed.add('defanging_algorithm_ref')
            outfile.write(' defanging_algorithm_ref=%s' % (self.gds_format_string(quote_attrib(self.defanging_algorithm_ref).encode(ExternalEncoding), input_name='defanging_algorithm_ref'), ))
        if self.is_obfuscated is not None and 'is_obfuscated' not in already_processed:
            already_processed.add('is_obfuscated')
            outfile.write(' is_obfuscated="%s"' % self.gds_format_boolean(self.is_obfuscated, input_name='is_obfuscated'))
        if self.regex_syntax is not None and 'regex_syntax' not in already_processed:
            already_processed.add('regex_syntax')
            outfile.write(' regex_syntax=%s' % (self.gds_format_string(quote_attrib(self.regex_syntax).encode(ExternalEncoding), input_name='regex_syntax'), ))
        if self.apply_condition is not None and 'apply_condition' not in already_processed:
            already_processed.add('apply_condition')
            outfile.write(' apply_condition=%s' % (quote_attrib(self.apply_condition), ))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.is_defanged is not None and 'is_defanged' not in already_processed:
            already_processed.add('is_defanged')
            outfile.write(' is_defanged="%s"' % self.gds_format_boolean(self.is_defanged, input_name='is_defanged'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            outfile.write(' condition=%s' % (quote_attrib(self.condition), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BaseObjectPropertyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BaseObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.obfuscation_algorithm_ref is not None and 'obfuscation_algorithm_ref' not in already_processed:
            already_processed.add('obfuscation_algorithm_ref')
            showIndent(outfile, level)
            outfile.write('obfuscation_algorithm_ref="%s",\n' % (self.obfuscation_algorithm_ref,))
        if self.refanging_transform_type is not None and 'refanging_transform_type' not in already_processed:
            already_processed.add('refanging_transform_type')
            showIndent(outfile, level)
            outfile.write('refanging_transform_type="%s",\n' % (self.refanging_transform_type,))
        if self.has_changed is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            showIndent(outfile, level)
            outfile.write('has_changed=%s,\n' % (self.has_changed,))
        if self.pattern_type is not None and 'pattern_type' not in already_processed:
            already_processed.add('pattern_type')
            showIndent(outfile, level)
            outfile.write('pattern_type=%s,\n' % (self.pattern_type,))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        if self.refanging_transform is not None and 'refanging_transform' not in already_processed:
            already_processed.add('refanging_transform')
            showIndent(outfile, level)
            outfile.write('refanging_transform="%s",\n' % (self.refanging_transform,))
        if self.bit_mask is not None and 'bit_mask' not in already_processed:
            already_processed.add('bit_mask')
            showIndent(outfile, level)
            outfile.write('bit_mask="%s",\n' % (self.bit_mask,))
        if self.appears_random is not None and 'appears_random' not in already_processed:
            already_processed.add('appears_random')
            showIndent(outfile, level)
            outfile.write('appears_random=%s,\n' % (self.appears_random,))
        if self.trend is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            showIndent(outfile, level)
            outfile.write('trend=%s,\n' % (self.trend,))
        if self.defanging_algorithm_ref is not None and 'defanging_algorithm_ref' not in already_processed:
            already_processed.add('defanging_algorithm_ref')
            showIndent(outfile, level)
            outfile.write('defanging_algorithm_ref="%s",\n' % (self.defanging_algorithm_ref,))
        if self.is_obfuscated is not None and 'is_obfuscated' not in already_processed:
            already_processed.add('is_obfuscated')
            showIndent(outfile, level)
            outfile.write('is_obfuscated=%s,\n' % (self.is_obfuscated,))
        if self.regex_syntax is not None and 'regex_syntax' not in already_processed:
            already_processed.add('regex_syntax')
            showIndent(outfile, level)
            outfile.write('regex_syntax="%s",\n' % (self.regex_syntax,))
        if self.apply_condition is not None and 'apply_condition' not in already_processed:
            already_processed.add('apply_condition')
            showIndent(outfile, level)
            outfile.write('apply_condition=%s,\n' % (self.apply_condition,))
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            showIndent(outfile, level)
            outfile.write('idref=%s,\n' % (self.idref,))
        if self.is_defanged is not None and 'is_defanged' not in already_processed:
            already_processed.add('is_defanged')
            showIndent(outfile, level)
            outfile.write('is_defanged=%s,\n' % (self.is_defanged,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            showIndent(outfile, level)
            outfile.write('condition=%s,\n' % (self.condition,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('obfuscation_algorithm_ref', node)
        if value is not None and 'obfuscation_algorithm_ref' not in already_processed:
            already_processed.add('obfuscation_algorithm_ref')
            self.obfuscation_algorithm_ref = value
        value = find_attr_value_('refanging_transform_type', node)
        if value is not None and 'refanging_transform_type' not in already_processed:
            already_processed.add('refanging_transform_type')
            self.refanging_transform_type = value
        value = find_attr_value_('has_changed', node)
        if value is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            if value in ('true', '1'):
                self.has_changed = True
            elif value in ('false', '0'):
                self.has_changed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('pattern_type', node)
        if value is not None and 'pattern_type' not in already_processed:
            already_processed.add('pattern_type')
            self.pattern_type = value
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        value = find_attr_value_('refanging_transform', node)
        if value is not None and 'refanging_transform' not in already_processed:
            already_processed.add('refanging_transform')
            self.refanging_transform = value
        value = find_attr_value_('bit_mask', node)
        if value is not None and 'bit_mask' not in already_processed:
            already_processed.add('bit_mask')
            self.bit_mask = value
        value = find_attr_value_('appears_random', node)
        if value is not None and 'appears_random' not in already_processed:
            already_processed.add('appears_random')
            if value in ('true', '1'):
                self.appears_random = True
            elif value in ('false', '0'):
                self.appears_random = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('trend', node)
        if value is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            if value in ('true', '1'):
                self.trend = True
            elif value in ('false', '0'):
                self.trend = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('defanging_algorithm_ref', node)
        if value is not None and 'defanging_algorithm_ref' not in already_processed:
            already_processed.add('defanging_algorithm_ref')
            self.defanging_algorithm_ref = value
        value = find_attr_value_('is_obfuscated', node)
        if value is not None and 'is_obfuscated' not in already_processed:
            already_processed.add('is_obfuscated')
            if value in ('true', '1'):
                self.is_obfuscated = True
            elif value in ('false', '0'):
                self.is_obfuscated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('regex_syntax', node)
        if value is not None and 'regex_syntax' not in already_processed:
            already_processed.add('regex_syntax')
            self.regex_syntax = value
        value = find_attr_value_('apply_condition', node)
        if value is not None and 'apply_condition' not in already_processed:
            already_processed.add('apply_condition')
            self.apply_condition = value
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('is_defanged', node)
        if value is not None and 'is_defanged' not in already_processed:
            already_processed.add('is_defanged')
            if value in ('true', '1'):
                self.is_defanged = True
            elif value in ('false', '0'):
                self.is_defanged = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            self.condition = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BaseObjectPropertyType


class IntegerObjectPropertyType(BaseObjectPropertyType):
    """The IntegerObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type Int. This
    type will be assigned to any property of a CybOX object that
    should contain content of type Integer and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(IntegerObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IntegerObjectPropertyType.subclass:
            return IntegerObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return IntegerObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(IntegerObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='IntegerObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='IntegerObjectPropertyType'):
        super(IntegerObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='IntegerObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(IntegerObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IntegerObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(IntegerObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IntegerObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(IntegerObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IntegerObjectPropertyType


class StringObjectPropertyType(BaseObjectPropertyType):
    """The StringObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type String. This
    type will be assigned to any property of a CybOX object that
    should contain content of type String and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None, extensiontype_=None):
        super(StringObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, extensiontype_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if StringObjectPropertyType.subclass:
            return StringObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return StringObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(StringObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='StringObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='StringObjectPropertyType'):
        super(StringObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StringObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='StringObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(StringObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='StringObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(StringObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StringObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(StringObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StringObjectPropertyType


class NameObjectPropertyType(BaseObjectPropertyType):
    """The NameObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type Name. This
    type will be assigned to any property of a CybOX object that
    should contain content of type Name and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(NameObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NameObjectPropertyType.subclass:
            return NameObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return NameObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(NameObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='NameObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='NameObjectPropertyType'):
        super(NameObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NameObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='NameObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(NameObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='NameObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(NameObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NameObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(NameObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameObjectPropertyType


class DateObjectPropertyType(BaseObjectPropertyType):
    """The DateObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type Date. This
    type will be assigned to any property of a CybOX object that
    should contain content of type Date and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(DateObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DateObjectPropertyType.subclass:
            return DateObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return DateObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DateObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DateObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DateObjectPropertyType'):
        super(DateObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DateObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DateObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(DateObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DateObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(DateObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DateObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(DateObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DateObjectPropertyType


class DateTimeObjectPropertyType(BaseObjectPropertyType):
    """The DateTimeObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type DateTime.
    This type will be assigned to any property of a CybOX object
    that should contain content of type DateTime and enables the use
    of relevant metadata for the property.Properties that use this
    type can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(DateTimeObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DateTimeObjectPropertyType.subclass:
            return DateTimeObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return DateTimeObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DateTimeObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DateTimeObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DateTimeObjectPropertyType'):
        super(DateTimeObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DateTimeObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(DateTimeObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DateTimeObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(DateTimeObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DateTimeObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(DateTimeObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DateTimeObjectPropertyType


class FloatObjectPropertyType(BaseObjectPropertyType):
    """The FloatObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type Float. This
    type will be assigned to any property of a CybOX object that
    should contain content of type Float and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(FloatObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FloatObjectPropertyType.subclass:
            return FloatObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return FloatObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(FloatObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='FloatObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='FloatObjectPropertyType'):
        super(FloatObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FloatObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='FloatObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(FloatObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='FloatObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(FloatObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FloatObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(FloatObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloatObjectPropertyType


class DoubleObjectPropertyType(BaseObjectPropertyType):
    """The DoubleObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type Double. This
    type will be assigned to any property of a CybOX object that
    should contain content of type Double and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(DoubleObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DoubleObjectPropertyType.subclass:
            return DoubleObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return DoubleObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DoubleObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DoubleObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoubleObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DoubleObjectPropertyType'):
        super(DoubleObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DoubleObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DoubleObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(DoubleObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DoubleObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(DoubleObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DoubleObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(DoubleObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DoubleObjectPropertyType


class UnsignedLongObjectPropertyType(BaseObjectPropertyType):
    """The UnsignedLongObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type UnsignedLong.
    This type will be assigned to any property of a CybOX object
    that should contain content of type UnsignedLong and enables the
    use of relevant metadata for the property.Properties that use
    this type can express multiple values by providing them using a
    comma separated list. As such, a comma is a reserved character
    in all uses of this type. Commas in values should be expressed
    as &comma; (that is, ampersand-"comma"-semicolon). Such
    expressions should be converted back to a comma before
    displaying to users or handing off values to tools for
    processing. Note that whitespace is preserved and so, when
    specifying a list of values, do not include a space following a
    comma in a list unless the first character of the next list item
    should, in fact, be a space.This attribute is optional and
    specifies the expected type for the value of the specified
    property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(UnsignedLongObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UnsignedLongObjectPropertyType.subclass:
            return UnsignedLongObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return UnsignedLongObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(UnsignedLongObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='UnsignedLongObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnsignedLongObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='UnsignedLongObjectPropertyType'):
        super(UnsignedLongObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnsignedLongObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='UnsignedLongObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(UnsignedLongObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='UnsignedLongObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(UnsignedLongObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UnsignedLongObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(UnsignedLongObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnsignedLongObjectPropertyType


class UnsignedIntegerObjectPropertyType(BaseObjectPropertyType):
    """The UnsignedIntegerObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type UnsignedInt.
    This type will be assigned to any property of a CybOX object
    that should contain content of type UnsignedInteger and enables
    the use of relevant metadata for the property.Properties that
    use this type can express multiple values by providing them
    using a comma separated list. As such, a comma is a reserved
    character in all uses of this type. Commas in values should be
    expressed as &comma; (that is, ampersand-"comma"-semicolon).
    Such expressions should be converted back to a comma before
    displaying to users or handing off values to tools for
    processing. Note that whitespace is preserved and so, when
    specifying a list of values, do not include a space following a
    comma in a list unless the first character of the next list item
    should, in fact, be a space.This attribute is optional and
    specifies the expected type for the value of the specified
    property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(UnsignedIntegerObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UnsignedIntegerObjectPropertyType.subclass:
            return UnsignedIntegerObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return UnsignedIntegerObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(UnsignedIntegerObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='UnsignedIntegerObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnsignedIntegerObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='UnsignedIntegerObjectPropertyType'):
        super(UnsignedIntegerObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnsignedIntegerObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='UnsignedIntegerObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(UnsignedIntegerObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='UnsignedIntegerObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(UnsignedIntegerObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UnsignedIntegerObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(UnsignedIntegerObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnsignedIntegerObjectPropertyType


class PositiveIntegerObjectPropertyType(BaseObjectPropertyType):
    """The PositiveIntegerObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type
    PositveInteger. This type will be assigned to any property of a
    CybOX object that should contain content of type PositiveInteger
    and enables the use of relevant metadata for the
    property.Properties that use this type can express multiple
    values by providing them using a comma separated list. As such,
    a comma is a reserved character in all uses of this type. Commas
    in values should be expressed as &comma; (that is,
    ampersand-"comma"-semicolon). Such expressions should be
    converted back to a comma before displaying to users or handing
    off values to tools for processing. Note that whitespace is
    preserved and so, when specifying a list of values, do not
    include a space following a comma in a list unless the first
    character of the next list item should, in fact, be a space.This
    attribute is optional and specifies the expected type for the
    value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(PositiveIntegerObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PositiveIntegerObjectPropertyType.subclass:
            return PositiveIntegerObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return PositiveIntegerObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(PositiveIntegerObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PositiveIntegerObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PositiveIntegerObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PositiveIntegerObjectPropertyType'):
        super(PositiveIntegerObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PositiveIntegerObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PositiveIntegerObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(PositiveIntegerObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PositiveIntegerObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(PositiveIntegerObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PositiveIntegerObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(PositiveIntegerObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PositiveIntegerObjectPropertyType


class HexBinaryObjectPropertyType(BaseObjectPropertyType):
    """The HexBinaryObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type HexBinary.
    This type will be assigned to any property of a CybOX object
    that should contain content of type HexBinary and enables the
    use of relevant metadata for the property.Properties that use
    this type can express multiple values by providing them using a
    comma separated list. As such, a comma is a reserved character
    in all uses of this type. Commas in values should be expressed
    as &comma; (that is, ampersand-"comma"-semicolon). Such
    expressions should be converted back to a comma before
    displaying to users or handing off values to tools for
    processing. Note that whitespace is preserved and so, when
    specifying a list of values, do not include a space following a
    comma in a list unless the first character of the next list item
    should, in fact, be a space.This attribute is optional and
    specifies the expected type for the value of the specified
    property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None, extensiontype_=None):
        super(HexBinaryObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, extensiontype_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if HexBinaryObjectPropertyType.subclass:
            return HexBinaryObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return HexBinaryObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(HexBinaryObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HexBinaryObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HexBinaryObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HexBinaryObjectPropertyType'):
        super(HexBinaryObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HexBinaryObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HexBinaryObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(HexBinaryObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='HexBinaryObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(HexBinaryObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HexBinaryObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(HexBinaryObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HexBinaryObjectPropertyType


class LongObjectPropertyType(BaseObjectPropertyType):
    """The LongObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type Long. This
    type will be assigned to any property of a CybOX object that
    should contain content of type Long and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(LongObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LongObjectPropertyType.subclass:
            return LongObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return LongObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(LongObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='LongObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LongObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='LongObjectPropertyType'):
        super(LongObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LongObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='LongObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(LongObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='LongObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(LongObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LongObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(LongObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LongObjectPropertyType


class NonNegativeIntegerObjectPropertyType(BaseObjectPropertyType):
    """The NonNegativeIntegerObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type
    nonNegativeInteger. This type will be assigned to any property
    of a CybOX object that should contain content of type
    NonNegativeInteger and enables the use of relevant metadata for
    the property.Properties that use this type can express multiple
    values by providing them using a comma separated list. As such,
    a comma is a reserved character in all uses of this type. Commas
    in values should be expressed as &comma; (that is,
    ampersand-"comma"-semicolon). Such expressions should be
    converted back to a comma before displaying to users or handing
    off values to tools for processing. Note that whitespace is
    preserved and so, when specifying a list of values, do not
    include a space following a comma in a list unless the first
    character of the next list item should, in fact, be a space.This
    attribute is optional and specifies the expected type for the
    value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(NonNegativeIntegerObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NonNegativeIntegerObjectPropertyType.subclass:
            return NonNegativeIntegerObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return NonNegativeIntegerObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(NonNegativeIntegerObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='NonNegativeIntegerObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeIntegerObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='NonNegativeIntegerObjectPropertyType'):
        super(NonNegativeIntegerObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonNegativeIntegerObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='NonNegativeIntegerObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(NonNegativeIntegerObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='NonNegativeIntegerObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(NonNegativeIntegerObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NonNegativeIntegerObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(NonNegativeIntegerObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NonNegativeIntegerObjectPropertyType


class AnyURIObjectPropertyType(BaseObjectPropertyType):
    """The AnyURIObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type anyURI. This
    type will be assigned to any property of a CybOX object that
    should contain content of type AnyURI and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(AnyURIObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AnyURIObjectPropertyType.subclass:
            return AnyURIObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return AnyURIObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AnyURIObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='AnyURIObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnyURIObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='AnyURIObjectPropertyType'):
        super(AnyURIObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AnyURIObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='AnyURIObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(AnyURIObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AnyURIObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(AnyURIObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AnyURIObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(AnyURIObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnyURIObjectPropertyType


class DurationObjectPropertyType(BaseObjectPropertyType):
    """The DurationObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type duration.
    This type will be assigned to any property of a CybOX object
    that should contain content of type Duration and enables the use
    of relevant metadata for the property.Properties that use this
    type can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(DurationObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DurationObjectPropertyType.subclass:
            return DurationObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return DurationObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DurationObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DurationObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DurationObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DurationObjectPropertyType'):
        super(DurationObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DurationObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DurationObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(DurationObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DurationObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(DurationObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DurationObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(DurationObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DurationObjectPropertyType


class TimeObjectPropertyType(BaseObjectPropertyType):
    """The TimeObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type time. This
    type will be assigned to any property of a CybOX object that
    should contain content of type Time and enables the use of
    relevant metadata for the property.Properties that use this type
    can express multiple values by providing them using a comma
    separated list. As such, a comma is a reserved character in all
    uses of this type. Commas in values should be expressed as
    &comma; (that is, ampersand-"comma"-semicolon). Such expressions
    should be converted back to a comma before displaying to users
    or handing off values to tools for processing. Note that
    whitespace is preserved and so, when specifying a list of
    values, do not include a space following a comma in a list
    unless the first character of the next list item should, in
    fact, be a space.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(TimeObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TimeObjectPropertyType.subclass:
            return TimeObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return TimeObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(TimeObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='TimeObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='TimeObjectPropertyType'):
        super(TimeObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='TimeObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(TimeObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TimeObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(TimeObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(TimeObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeObjectPropertyType


class Base64BinaryObjectPropertyType(BaseObjectPropertyType):
    """The Base64BinaryObjectPropertyType is a type (extended from
    BaseObjectPropertyType) representing the specification of a
    single Object property whose core value is of type base64Binary.
    This type will be assigned to any property of a CybOX object
    that should contain content of type Base64Binary and enables the
    use of relevant metadata for the property.Properties that use
    this type can express multiple values by providing them using a
    comma separated list. As such, a comma is a reserved character
    in all uses of this type. Commas in values should be expressed
    as &comma; (that is, ampersand-"comma"-semicolon). Such
    expressions should be converted back to a comma before
    displaying to users or handing off values to tools for
    processing. Note that whitespace is preserved and so, when
    specifying a list of values, do not include a space following a
    comma in a list unless the first character of the next list item
    should, in fact, be a space.This attribute is optional and
    specifies the expected type for the value of the specified
    property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(Base64BinaryObjectPropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Base64BinaryObjectPropertyType.subclass:
            return Base64BinaryObjectPropertyType.subclass(*args_, **kwargs_)
        else:
            return Base64BinaryObjectPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Base64BinaryObjectPropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='Base64BinaryObjectPropertyType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Base64BinaryObjectPropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='Base64BinaryObjectPropertyType'):
        super(Base64BinaryObjectPropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Base64BinaryObjectPropertyType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='Base64BinaryObjectPropertyType', fromsubclass_=False, pretty_print=True):
        super(Base64BinaryObjectPropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='Base64BinaryObjectPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(Base64BinaryObjectPropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Base64BinaryObjectPropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(Base64BinaryObjectPropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Base64BinaryObjectPropertyType


class ExtractedFeaturesType(GeneratedsSuper):
    """The ExtractedFeaturesType is a type representing a description of
    features extracted from an object such as a file."""
    subclass = None
    superclass = None
    def __init__(self, Strings=None, Imports=None, Functions=None, Code_Snippets=None):
        self.Strings = Strings
        self.Imports = Imports
        self.Functions = Functions
        self.Code_Snippets = Code_Snippets
    def factory(*args_, **kwargs_):
        if ExtractedFeaturesType.subclass:
            return ExtractedFeaturesType.subclass(*args_, **kwargs_)
        else:
            return ExtractedFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Strings(self): return self.Strings
    def set_Strings(self, Strings): self.Strings = Strings
    def get_Imports(self): return self.Imports
    def set_Imports(self, Imports): self.Imports = Imports
    def get_Functions(self): return self.Functions
    def set_Functions(self, Functions): self.Functions = Functions
    def get_Code_Snippets(self): return self.Code_Snippets
    def set_Code_Snippets(self, Code_Snippets): self.Code_Snippets = Code_Snippets
    def hasContent_(self):
        if (
            self.Strings is not None or
            self.Imports is not None or
            self.Functions is not None or
            self.Code_Snippets is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ExtractedFeaturesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtractedFeaturesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ExtractedFeaturesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ExtractedFeaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Strings is not None:
            self.Strings.export(outfile, level, namespace_, name_='Strings', pretty_print=pretty_print)
        if self.Imports is not None:
            self.Imports.export(outfile, level, namespace_, name_='Imports', pretty_print=pretty_print)
        if self.Functions is not None:
            self.Functions.export(outfile, level, namespace_, name_='Functions', pretty_print=pretty_print)
        if self.Code_Snippets is not None:
            self.Code_Snippets.export(outfile, level, namespace_, name_='Code_Snippets', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ExtractedFeaturesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Strings is not None:
            showIndent(outfile, level)
            outfile.write('Strings=model_.ExtractedStringsType(\n')
            self.Strings.exportLiteral(outfile, level, name_='Strings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Imports is not None:
            showIndent(outfile, level)
            outfile.write('Imports=model_.ImportsType(\n')
            self.Imports.exportLiteral(outfile, level, name_='Imports')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Functions is not None:
            showIndent(outfile, level)
            outfile.write('Functions=model_.FunctionsType(\n')
            self.Functions.exportLiteral(outfile, level, name_='Functions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Code_Snippets is not None:
            showIndent(outfile, level)
            outfile.write('Code_Snippets=model_.CodeSnippetsType(\n')
            self.Code_Snippets.exportLiteral(outfile, level, name_='Code_Snippets')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Strings':
            obj_ = ExtractedStringsType.factory()
            obj_.build(child_)
            self.Strings = obj_
        elif nodeName_ == 'Imports':
            obj_ = ImportsType.factory()
            obj_.build(child_)
            self.Imports = obj_
        elif nodeName_ == 'Functions':
            obj_ = FunctionsType.factory()
            obj_.build(child_)
            self.Functions = obj_
        elif nodeName_ == 'Code_Snippets':
            obj_ = CodeSnippetsType.factory()
            obj_.build(child_)
            self.Code_Snippets = obj_
# end class ExtractedFeaturesType


class ExtractedStringsType(GeneratedsSuper):
    """The ExtractedStringsType type is intended as container for strings
    extracted from CybOX objects."""
    subclass = None
    superclass = None
    def __init__(self, String=None):
        if String is None:
            self.String = []
        else:
            self.String = String
    def factory(*args_, **kwargs_):
        if ExtractedStringsType.subclass:
            return ExtractedStringsType.subclass(*args_, **kwargs_)
        else:
            return ExtractedStringsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_String(self): return self.String
    def set_String(self, String): self.String = String
    def add_String(self, value): self.String.append(value)
    def insert_String(self, index, value): self.String[index] = value
    def hasContent_(self):
        if (
            self.String
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ExtractedStringsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtractedStringsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ExtractedStringsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ExtractedStringsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for String_ in self.String:
            String_.export(outfile, level, namespace_, name_='String', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ExtractedStringsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('String=[\n')
        level += 1
        for String_ in self.String:
            showIndent(outfile, level)
            outfile.write('model_.ExtractedStringType(\n')
            String_.exportLiteral(outfile, level, name_='ExtractedStringType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'String':
            obj_ = ExtractedStringType.factory()
            obj_.build(child_)
            self.String.append(obj_)
# end class ExtractedStringsType


class ExtractedStringType(GeneratedsSuper):
    """The ExtractedStringType type is intended as container a single
    string extracted from a CybOX object."""
    subclass = None
    superclass = None
    def __init__(self, Encoding=None, String_Value=None, Byte_String_Value=None, Hashes=None, Address=None, Length=None, Language=None, English_Translation=None):
        self.Encoding = Encoding
        self.String_Value = String_Value
        self.Byte_String_Value = Byte_String_Value
        self.Hashes = Hashes
        self.Address = Address
        self.Length = Length
        self.Language = Language
        self.English_Translation = English_Translation
    def factory(*args_, **kwargs_):
        if ExtractedStringType.subclass:
            return ExtractedStringType.subclass(*args_, **kwargs_)
        else:
            return ExtractedStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Encoding(self): return self.Encoding
    def set_Encoding(self, Encoding): self.Encoding = Encoding
    def get_String_Value(self): return self.String_Value
    def set_String_Value(self, String_Value): self.String_Value = String_Value
    def get_Byte_String_Value(self): return self.Byte_String_Value
    def set_Byte_String_Value(self, Byte_String_Value): self.Byte_String_Value = Byte_String_Value
    def get_Hashes(self): return self.Hashes
    def set_Hashes(self, Hashes): self.Hashes = Hashes
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_Language(self): return self.Language
    def set_Language(self, Language): self.Language = Language
    def get_English_Translation(self): return self.English_Translation
    def set_English_Translation(self, English_Translation): self.English_Translation = English_Translation
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def validate_HexBinaryObjectPropertyType(self, value):
        # Validate type HexBinaryObjectPropertyType, a restriction on None.
        pass
    def validate_PositiveIntegerObjectPropertyType(self, value):
        # Validate type PositiveIntegerObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Encoding is not None or
            self.String_Value is not None or
            self.Byte_String_Value is not None or
            self.Hashes is not None or
            self.Address is not None or
            self.Length is not None or
            self.Language is not None or
            self.English_Translation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ExtractedStringType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtractedStringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ExtractedStringType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ExtractedStringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Encoding is not None:
            self.Encoding.export(outfile, level, namespace_, name_='Encoding', pretty_print=pretty_print)
        if self.String_Value is not None:
            self.String_Value.export(outfile, level, namespace_, name_='String_Value', pretty_print=pretty_print)
        if self.Byte_String_Value is not None:
            self.Byte_String_Value.export(outfile, level, namespace_, name_='Byte_String_Value', pretty_print=pretty_print)
        if self.Hashes is not None:
            self.Hashes.export(outfile, level, namespace_, name_='Hashes', pretty_print=pretty_print)
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.Length is not None:
            self.Length.export(outfile, level, namespace_, name_='Length', pretty_print=pretty_print)
        if self.Language is not None:
            self.Language.export(outfile, level, namespace_, name_='Language', pretty_print=pretty_print)
        if self.English_Translation is not None:
            self.English_Translation.export(outfile, level, namespace_, name_='English_Translation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ExtractedStringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Encoding is not None:
            showIndent(outfile, level)
            outfile.write('Encoding=model_.ControlledVocabularyStringType(\n')
            self.Encoding.exportLiteral(outfile, level, name_='Encoding')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.String_Value is not None:
            showIndent(outfile, level)
            outfile.write('String_Value=model_.StringObjectPropertyType(\n')
            self.String_Value.exportLiteral(outfile, level, name_='String_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Byte_String_Value is not None:
            showIndent(outfile, level)
            outfile.write('Byte_String_Value=model_.HexBinaryObjectPropertyType(\n')
            self.Byte_String_Value.exportLiteral(outfile, level, name_='Byte_String_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Hashes=model_.HashListType(\n')
            self.Hashes.exportLiteral(outfile, level, name_='Hashes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=model_.HexBinaryObjectPropertyType(\n')
            self.Address.exportLiteral(outfile, level, name_='Address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Length is not None:
            showIndent(outfile, level)
            outfile.write('Length=model_.PositiveIntegerObjectPropertyType(\n')
            self.Length.exportLiteral(outfile, level, name_='Length')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Language is not None:
            showIndent(outfile, level)
            outfile.write('Language=model_.StringObjectPropertyType(\n')
            self.Language.exportLiteral(outfile, level, name_='Language')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.English_Translation is not None:
            showIndent(outfile, level)
            outfile.write('English_Translation=model_.StringObjectPropertyType(\n')
            self.English_Translation.exportLiteral(outfile, level, name_='English_Translation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Encoding':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Encoding = obj_
        elif nodeName_ == 'String_Value':
            obj_ = None
            self.String_Value = obj_
            self.validate_StringObjectPropertyType(self.String_Value)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Byte_String_Value':
            obj_ = None
            self.Byte_String_Value = obj_
            self.validate_HexBinaryObjectPropertyType(self.Byte_String_Value)    # validate type HexBinaryObjectPropertyType
        elif nodeName_ == 'Hashes':
            obj_ = HashListType.factory()
            obj_.build(child_)
            self.Hashes = obj_
        elif nodeName_ == 'Address':
            obj_ = None
            self.Address = obj_
            self.validate_HexBinaryObjectPropertyType(self.Address)    # validate type HexBinaryObjectPropertyType
        elif nodeName_ == 'Length':
            obj_ = None
            self.Length = obj_
            self.validate_PositiveIntegerObjectPropertyType(self.Length)    # validate type PositiveIntegerObjectPropertyType
        elif nodeName_ == 'Language':
            obj_ = None
            self.Language = obj_
            self.validate_StringObjectPropertyType(self.Language)    # validate type StringObjectPropertyType
        elif nodeName_ == 'English_Translation':
            obj_ = None
            self.English_Translation = obj_
            self.validate_StringObjectPropertyType(self.English_Translation)    # validate type StringObjectPropertyType
# end class ExtractedStringType


class ImportsType(GeneratedsSuper):
    """The ImportsType is intended to represent an extracted list of
    imports specified within a CybOX object."""
    subclass = None
    superclass = None
    def __init__(self, Import=None):
        if Import is None:
            self.Import = []
        else:
            self.Import = Import
    def factory(*args_, **kwargs_):
        if ImportsType.subclass:
            return ImportsType.subclass(*args_, **kwargs_)
        else:
            return ImportsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Import(self): return self.Import
    def set_Import(self, Import): self.Import = Import
    def add_Import(self, value): self.Import.append(value)
    def insert_Import(self, index, value): self.Import[index] = value
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Import
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ImportsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImportsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ImportsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ImportsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Import_ in self.Import:
            Import_.export(outfile, level, namespace_, name_='Import', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ImportsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Import=[\n')
        level += 1
        for Import_ in self.Import:
            showIndent(outfile, level)
            outfile.write('model_.StringObjectPropertyType(\n')
            Import_.exportLiteral(outfile, level, name_='StringObjectPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Import':
            obj_ = None
            self.Import.append(obj_)
            self.validate_StringObjectPropertyType(self.Import)    # validate type StringObjectPropertyType
# end class ImportsType


class FunctionsType(GeneratedsSuper):
    """The FunctionsType is intended to represent an extracted list of
    functions leveraged within a CybOX object."""
    subclass = None
    superclass = None
    def __init__(self, Function=None):
        if Function is None:
            self.Function = []
        else:
            self.Function = Function
    def factory(*args_, **kwargs_):
        if FunctionsType.subclass:
            return FunctionsType.subclass(*args_, **kwargs_)
        else:
            return FunctionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Function(self): return self.Function
    def set_Function(self, Function): self.Function = Function
    def add_Function(self, value): self.Function.append(value)
    def insert_Function(self, index, value): self.Function[index] = value
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Function
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='FunctionsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='FunctionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='FunctionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Function_ in self.Function:
            Function_.export(outfile, level, namespace_, name_='Function', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FunctionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Function=[\n')
        level += 1
        for Function_ in self.Function:
            showIndent(outfile, level)
            outfile.write('model_.StringObjectPropertyType(\n')
            Function_.exportLiteral(outfile, level, name_='StringObjectPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Function':
            obj_ = None
            self.Function.append(obj_)
            self.validate_StringObjectPropertyType(self.Function)    # validate type StringObjectPropertyType
# end class FunctionsType


class CodeSnippetsType(GeneratedsSuper):
    """The CodeSnippetsType is intended to represent an set of code
    snippets extracted from within a CybOX object."""
    subclass = None
    superclass = None
    def __init__(self, Code_Snippet=None):
        if Code_Snippet is None:
            self.Code_Snippet = []
        else:
            self.Code_Snippet = Code_Snippet
    def factory(*args_, **kwargs_):
        if CodeSnippetsType.subclass:
            return CodeSnippetsType.subclass(*args_, **kwargs_)
        else:
            return CodeSnippetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code_Snippet(self): return self.Code_Snippet
    def set_Code_Snippet(self, Code_Snippet): self.Code_Snippet = Code_Snippet
    def add_Code_Snippet(self, value): self.Code_Snippet.append(value)
    def insert_Code_Snippet(self, index, value): self.Code_Snippet[index] = value
    def hasContent_(self):
        if (
            self.Code_Snippet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CodeSnippetsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeSnippetsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CodeSnippetsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CodeSnippetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Code_Snippet_ in self.Code_Snippet:
            Code_Snippet_.export(outfile, level, namespace_, name_='Code_Snippet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CodeSnippetsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Code_Snippet=[\n')
        level += 1
        for Code_Snippet_ in self.Code_Snippet:
            showIndent(outfile, level)
            outfile.write('model_.ObjectPropertiesType(\n')
            Code_Snippet_.exportLiteral(outfile, level, name_='ObjectPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code_Snippet':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Code_Snippet> element')
            self.Code_Snippet.append(obj_)
# end class CodeSnippetsType


class ByteRunsType(GeneratedsSuper):
    """The ByteRunsType is used for representing a list of byte runs from
    within a raw object."""
    subclass = None
    superclass = None
    def __init__(self, Byte_Run=None):
        if Byte_Run is None:
            self.Byte_Run = []
        else:
            self.Byte_Run = Byte_Run
    def factory(*args_, **kwargs_):
        if ByteRunsType.subclass:
            return ByteRunsType.subclass(*args_, **kwargs_)
        else:
            return ByteRunsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Byte_Run(self): return self.Byte_Run
    def set_Byte_Run(self, Byte_Run): self.Byte_Run = Byte_Run
    def add_Byte_Run(self, value): self.Byte_Run.append(value)
    def insert_Byte_Run(self, index, value): self.Byte_Run[index] = value
    def hasContent_(self):
        if (
            self.Byte_Run
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ByteRunsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ByteRunsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ByteRunsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ByteRunsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Byte_Run_ in self.Byte_Run:
            Byte_Run_.export(outfile, level, namespace_, name_='Byte_Run', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ByteRunsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Byte_Run=[\n')
        level += 1
        for Byte_Run_ in self.Byte_Run:
            showIndent(outfile, level)
            outfile.write('model_.ByteRunType(\n')
            Byte_Run_.exportLiteral(outfile, level, name_='ByteRunType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Byte_Run':
            obj_ = ByteRunType.factory()
            obj_.build(child_)
            self.Byte_Run.append(obj_)
# end class ByteRunsType


class ByteRunType(GeneratedsSuper):
    """The ByteRunType is used for representing a single byte run from
    within a raw object."""
    subclass = None
    superclass = None
    def __init__(self, Offset=None, File_System_Offset=None, Image_Offset=None, Length=None, Hashes=None, Byte_Run_Data=None):
        self.Offset = Offset
        self.File_System_Offset = File_System_Offset
        self.Image_Offset = Image_Offset
        self.Length = Length
        self.Hashes = Hashes
        self.Byte_Run_Data = Byte_Run_Data
    def factory(*args_, **kwargs_):
        if ByteRunType.subclass:
            return ByteRunType.subclass(*args_, **kwargs_)
        else:
            return ByteRunType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_File_System_Offset(self): return self.File_System_Offset
    def set_File_System_Offset(self, File_System_Offset): self.File_System_Offset = File_System_Offset
    def get_Image_Offset(self): return self.Image_Offset
    def set_Image_Offset(self, Image_Offset): self.Image_Offset = Image_Offset
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_Hashes(self): return self.Hashes
    def set_Hashes(self, Hashes): self.Hashes = Hashes
    def get_Byte_Run_Data(self): return self.Byte_Run_Data
    def set_Byte_Run_Data(self, Byte_Run_Data): self.Byte_Run_Data = Byte_Run_Data
    def validate_IntegerObjectPropertyType(self, value):
        # Validate type IntegerObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Offset is not None or
            self.File_System_Offset is not None or
            self.Image_Offset is not None or
            self.Length is not None or
            self.Hashes is not None or
            self.Byte_Run_Data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ByteRunType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ByteRunType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ByteRunType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ByteRunType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Offset is not None:
            self.Offset.export(outfile, level, namespace_, name_='Offset', pretty_print=pretty_print)
        if self.File_System_Offset is not None:
            self.File_System_Offset.export(outfile, level, namespace_, name_='File_System_Offset', pretty_print=pretty_print)
        if self.Image_Offset is not None:
            self.Image_Offset.export(outfile, level, namespace_, name_='Image_Offset', pretty_print=pretty_print)
        if self.Length is not None:
            self.Length.export(outfile, level, namespace_, name_='Length', pretty_print=pretty_print)
        if self.Hashes is not None:
            self.Hashes.export(outfile, level, namespace_, name_='Hashes', pretty_print=pretty_print)
        if self.Byte_Run_Data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sByte_Run_Data>%s</%sByte_Run_Data>%s' % (namespace_, self.gds_format_string(quote_xml(self.Byte_Run_Data).encode(ExternalEncoding), input_name='Byte_Run_Data'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ByteRunType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Offset is not None:
            showIndent(outfile, level)
            outfile.write('Offset=model_.IntegerObjectPropertyType(\n')
            self.Offset.exportLiteral(outfile, level, name_='Offset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.File_System_Offset is not None:
            showIndent(outfile, level)
            outfile.write('File_System_Offset=model_.IntegerObjectPropertyType(\n')
            self.File_System_Offset.exportLiteral(outfile, level, name_='File_System_Offset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Image_Offset is not None:
            showIndent(outfile, level)
            outfile.write('Image_Offset=model_.IntegerObjectPropertyType(\n')
            self.Image_Offset.exportLiteral(outfile, level, name_='Image_Offset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Length is not None:
            showIndent(outfile, level)
            outfile.write('Length=model_.IntegerObjectPropertyType(\n')
            self.Length.exportLiteral(outfile, level, name_='Length')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hashes is not None:
            showIndent(outfile, level)
            outfile.write('Hashes=model_.HashListType(\n')
            self.Hashes.exportLiteral(outfile, level, name_='Hashes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Byte_Run_Data is not None:
            showIndent(outfile, level)
            outfile.write('Byte_Run_Data=%s,\n' % quote_python(self.Byte_Run_Data).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Offset':
            obj_ = None
            self.Offset = obj_
            self.validate_IntegerObjectPropertyType(self.Offset)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'File_System_Offset':
            obj_ = None
            self.File_System_Offset = obj_
            self.validate_IntegerObjectPropertyType(self.File_System_Offset)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Image_Offset':
            obj_ = None
            self.Image_Offset = obj_
            self.validate_IntegerObjectPropertyType(self.Image_Offset)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Length':
            obj_ = None
            self.Length = obj_
            self.validate_IntegerObjectPropertyType(self.Length)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Hashes':
            obj_ = HashListType.factory()
            obj_.build(child_)
            self.Hashes = obj_
        elif nodeName_ == 'Byte_Run_Data':
            Byte_Run_Data_ = child_.text
            Byte_Run_Data_ = self.gds_validate_string(Byte_Run_Data_, node, 'Byte_Run_Data')
            self.Byte_Run_Data = Byte_Run_Data_
# end class ByteRunType


class HashListType(GeneratedsSuper):
    """The HashListType type is used for representing a list of hash
    values."""
    subclass = None
    superclass = None
    def __init__(self, Hash=None):
        if Hash is None:
            self.Hash = []
        else:
            self.Hash = Hash
    def factory(*args_, **kwargs_):
        if HashListType.subclass:
            return HashListType.subclass(*args_, **kwargs_)
        else:
            return HashListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hash(self): return self.Hash
    def set_Hash(self, Hash): self.Hash = Hash
    def add_Hash(self, value): self.Hash.append(value)
    def insert_Hash(self, index, value): self.Hash[index] = value
    def hasContent_(self):
        if (
            self.Hash
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HashListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HashListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HashListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HashListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Hash_ in self.Hash:
            Hash_.export(outfile, level, namespace_, name_='Hash', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HashListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Hash=[\n')
        level += 1
        for Hash_ in self.Hash:
            showIndent(outfile, level)
            outfile.write('model_.HashType(\n')
            Hash_.exportLiteral(outfile, level, name_='HashType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hash':
            obj_ = HashType.factory()
            obj_.build(child_)
            self.Hash.append(obj_)
# end class HashListType


class HashValueType(GeneratedsSuper):
    """The HashValueType is used for specifying the resulting value from a
    hash calculation."""
    subclass = None
    superclass = None
    def __init__(self, Simple_Hash_Value=None, Fuzzy_Hash_Value=None):
        self.Simple_Hash_Value = Simple_Hash_Value
        self.Fuzzy_Hash_Value = Fuzzy_Hash_Value
    def factory(*args_, **kwargs_):
        if HashValueType.subclass:
            return HashValueType.subclass(*args_, **kwargs_)
        else:
            return HashValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Simple_Hash_Value(self): return self.Simple_Hash_Value
    def set_Simple_Hash_Value(self, Simple_Hash_Value): self.Simple_Hash_Value = Simple_Hash_Value
    def get_Fuzzy_Hash_Value(self): return self.Fuzzy_Hash_Value
    def set_Fuzzy_Hash_Value(self, Fuzzy_Hash_Value): self.Fuzzy_Hash_Value = Fuzzy_Hash_Value
    def hasContent_(self):
        if (
            self.Simple_Hash_Value is not None or
            self.Fuzzy_Hash_Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HashValueType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HashValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HashValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HashValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Simple_Hash_Value is not None:
            self.Simple_Hash_Value.export(outfile, level, namespace_, name_='Simple_Hash_Value', pretty_print=pretty_print)
        if self.Fuzzy_Hash_Value is not None:
            self.Fuzzy_Hash_Value.export(outfile, level, namespace_, name_='Fuzzy_Hash_Value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HashValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Simple_Hash_Value is not None:
            showIndent(outfile, level)
            outfile.write('Simple_Hash_Value=model_.SimpleHashValueType(\n')
            self.Simple_Hash_Value.exportLiteral(outfile, level, name_='Simple_Hash_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Fuzzy_Hash_Value is not None:
            showIndent(outfile, level)
            outfile.write('Fuzzy_Hash_Value=model_.FuzzyHashValueType(\n')
            self.Fuzzy_Hash_Value.exportLiteral(outfile, level, name_='Fuzzy_Hash_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Simple_Hash_Value':
            obj_ = SimpleHashValueType.factory()
            obj_.build(child_)
            self.Simple_Hash_Value = obj_
        elif nodeName_ == 'Fuzzy_Hash_Value':
            obj_ = FuzzyHashValueType.factory()
            obj_.build(child_)
            self.Fuzzy_Hash_Value = obj_
# end class HashValueType


class SimpleHashValueType(HexBinaryObjectPropertyType):
    """The SimpleHashValueType is used for characterizing the output of
    basic cryptograhic hash functions outputing a single hexbinary
    hash value."""
    subclass = None
    superclass = HexBinaryObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None):
        super(SimpleHashValueType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, )
        pass
    def factory(*args_, **kwargs_):
        if SimpleHashValueType.subclass:
            return SimpleHashValueType.subclass(*args_, **kwargs_)
        else:
            return SimpleHashValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SimpleHashValueType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='SimpleHashValueType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleHashValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='SimpleHashValueType'):
        super(SimpleHashValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleHashValueType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='SimpleHashValueType', fromsubclass_=False, pretty_print=True):
        super(SimpleHashValueType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SimpleHashValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SimpleHashValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SimpleHashValueType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SimpleHashValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SimpleHashValueType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SimpleHashValueType


class FuzzyHashValueType(StringObjectPropertyType):
    """The FuzzyHashValueType is used for characterizing the output of
    cryptograhic fuzzy hash functions outputing a single complex
    string based hash value."""
    subclass = None
    superclass = StringObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None):
        super(FuzzyHashValueType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, )
        pass
    def factory(*args_, **kwargs_):
        if FuzzyHashValueType.subclass:
            return FuzzyHashValueType.subclass(*args_, **kwargs_)
        else:
            return FuzzyHashValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FuzzyHashValueType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='FuzzyHashValueType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FuzzyHashValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='FuzzyHashValueType'):
        super(FuzzyHashValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FuzzyHashValueType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='FuzzyHashValueType', fromsubclass_=False, pretty_print=True):
        super(FuzzyHashValueType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='FuzzyHashValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FuzzyHashValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FuzzyHashValueType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FuzzyHashValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FuzzyHashValueType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FuzzyHashValueType


class FuzzyHashStructureType(GeneratedsSuper):
    """The FuzzyHashStructureType is used for characterizing the internal
    components of a cryptograhic fuzzy hash algorithmic calculation."""
    subclass = None
    superclass = None
    def __init__(self, Block_Size=None, Block_Hash=None):
        self.Block_Size = Block_Size
        self.Block_Hash = Block_Hash
    def factory(*args_, **kwargs_):
        if FuzzyHashStructureType.subclass:
            return FuzzyHashStructureType.subclass(*args_, **kwargs_)
        else:
            return FuzzyHashStructureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Block_Size(self): return self.Block_Size
    def set_Block_Size(self, Block_Size): self.Block_Size = Block_Size
    def get_Block_Hash(self): return self.Block_Hash
    def set_Block_Hash(self, Block_Hash): self.Block_Hash = Block_Hash
    def validate_IntegerObjectPropertyType(self, value):
        # Validate type IntegerObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Block_Size is not None or
            self.Block_Hash is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='FuzzyHashStructureType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FuzzyHashStructureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='FuzzyHashStructureType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='FuzzyHashStructureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Block_Size is not None:
            self.Block_Size.export(outfile, level, namespace_, name_='Block_Size', pretty_print=pretty_print)
        if self.Block_Hash is not None:
            self.Block_Hash.export(outfile, level, namespace_, name_='Block_Hash', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FuzzyHashStructureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Block_Size is not None:
            showIndent(outfile, level)
            outfile.write('Block_Size=model_.IntegerObjectPropertyType(\n')
            self.Block_Size.exportLiteral(outfile, level, name_='Block_Size')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Block_Hash is not None:
            showIndent(outfile, level)
            outfile.write('Block_Hash=model_.FuzzyHashBlockType(\n')
            self.Block_Hash.exportLiteral(outfile, level, name_='Block_Hash')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Block_Size':
            obj_ = None
            self.Block_Size = obj_
            self.validate_IntegerObjectPropertyType(self.Block_Size)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Block_Hash':
            obj_ = FuzzyHashBlockType.factory()
            obj_.build(child_)
            self.Block_Hash = obj_
# end class FuzzyHashStructureType


class FuzzyHashBlockType(GeneratedsSuper):
    """The FuzzyHashBlockType is used for characterizing the internal
    components of a single block in a cryptograhic fuzzy hash
    algorithmic calculation."""
    subclass = None
    superclass = None
    def __init__(self, Block_Hash_Value=None, Segment_Count=None, Segments=None):
        self.Block_Hash_Value = Block_Hash_Value
        self.Segment_Count = Segment_Count
        self.Segments = Segments
    def factory(*args_, **kwargs_):
        if FuzzyHashBlockType.subclass:
            return FuzzyHashBlockType.subclass(*args_, **kwargs_)
        else:
            return FuzzyHashBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Block_Hash_Value(self): return self.Block_Hash_Value
    def set_Block_Hash_Value(self, Block_Hash_Value): self.Block_Hash_Value = Block_Hash_Value
    def get_Segment_Count(self): return self.Segment_Count
    def set_Segment_Count(self, Segment_Count): self.Segment_Count = Segment_Count
    def get_Segments(self): return self.Segments
    def set_Segments(self, Segments): self.Segments = Segments
    def validate_IntegerObjectPropertyType(self, value):
        # Validate type IntegerObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Block_Hash_Value is not None or
            self.Segment_Count is not None or
            self.Segments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='FuzzyHashBlockType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FuzzyHashBlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='FuzzyHashBlockType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='FuzzyHashBlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Block_Hash_Value is not None:
            self.Block_Hash_Value.export(outfile, level, namespace_, name_='Block_Hash_Value', pretty_print=pretty_print)
        if self.Segment_Count is not None:
            self.Segment_Count.export(outfile, level, namespace_, name_='Segment_Count', pretty_print=pretty_print)
        if self.Segments is not None:
            self.Segments.export(outfile, level, namespace_, name_='Segments', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FuzzyHashBlockType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Block_Hash_Value is not None:
            showIndent(outfile, level)
            outfile.write('Block_Hash_Value=model_.HashValueType(\n')
            self.Block_Hash_Value.exportLiteral(outfile, level, name_='Block_Hash_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Segment_Count is not None:
            showIndent(outfile, level)
            outfile.write('Segment_Count=model_.IntegerObjectPropertyType(\n')
            self.Segment_Count.exportLiteral(outfile, level, name_='Segment_Count')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Segments is not None:
            showIndent(outfile, level)
            outfile.write('Segments=model_.HashSegmentsType(\n')
            self.Segments.exportLiteral(outfile, level, name_='Segments')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Block_Hash_Value':
            obj_ = HashValueType.factory()
            obj_.build(child_)
            self.Block_Hash_Value = obj_
        elif nodeName_ == 'Segment_Count':
            obj_ = None
            self.Segment_Count = obj_
            self.validate_IntegerObjectPropertyType(self.Segment_Count)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Segments':
            obj_ = HashSegmentsType.factory()
            obj_.build(child_)
            self.Segments = obj_
# end class FuzzyHashBlockType


class HashSegmentsType(GeneratedsSuper):
    """The HashSegmentsType is used for characterizing the internal
    components of a set of trigger point-delimited segments in a
    cryptograhic fuzzy hash algorithmic calculation."""
    subclass = None
    superclass = None
    def __init__(self, Segment=None):
        if Segment is None:
            self.Segment = []
        else:
            self.Segment = Segment
    def factory(*args_, **kwargs_):
        if HashSegmentsType.subclass:
            return HashSegmentsType.subclass(*args_, **kwargs_)
        else:
            return HashSegmentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Segment(self): return self.Segment
    def set_Segment(self, Segment): self.Segment = Segment
    def add_Segment(self, value): self.Segment.append(value)
    def insert_Segment(self, index, value): self.Segment[index] = value
    def hasContent_(self):
        if (
            self.Segment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HashSegmentsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HashSegmentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HashSegmentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HashSegmentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Segment_ in self.Segment:
            Segment_.export(outfile, level, namespace_, name_='Segment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HashSegmentsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Segment=[\n')
        level += 1
        for Segment_ in self.Segment:
            showIndent(outfile, level)
            outfile.write('model_.HashSegmentType(\n')
            Segment_.exportLiteral(outfile, level, name_='HashSegmentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Segment':
            obj_ = HashSegmentType.factory()
            obj_.build(child_)
            self.Segment.append(obj_)
# end class HashSegmentsType


class HashSegmentType(GeneratedsSuper):
    """The HashSegmentType is used for characterizing the internal
    components of a single trigger point-delimited segment in a
    cryptograhic fuzzy hash algorithmic calculation."""
    subclass = None
    superclass = None
    def __init__(self, Trigger_Point=None, Segment_Hash=None, Raw_Segment_Content=None):
        self.Trigger_Point = Trigger_Point
        self.Segment_Hash = Segment_Hash
        self.Raw_Segment_Content = Raw_Segment_Content
    def factory(*args_, **kwargs_):
        if HashSegmentType.subclass:
            return HashSegmentType.subclass(*args_, **kwargs_)
        else:
            return HashSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Trigger_Point(self): return self.Trigger_Point
    def set_Trigger_Point(self, Trigger_Point): self.Trigger_Point = Trigger_Point
    def get_Segment_Hash(self): return self.Segment_Hash
    def set_Segment_Hash(self, Segment_Hash): self.Segment_Hash = Segment_Hash
    def get_Raw_Segment_Content(self): return self.Raw_Segment_Content
    def set_Raw_Segment_Content(self, Raw_Segment_Content): self.Raw_Segment_Content = Raw_Segment_Content
    def validate_HexBinaryObjectPropertyType(self, value):
        # Validate type HexBinaryObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Trigger_Point is not None or
            self.Segment_Hash is not None or
            self.Raw_Segment_Content is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HashSegmentType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HashSegmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HashSegmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HashSegmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Trigger_Point is not None:
            self.Trigger_Point.export(outfile, level, namespace_, name_='Trigger_Point', pretty_print=pretty_print)
        if self.Segment_Hash is not None:
            self.Segment_Hash.export(outfile, level, namespace_, name_='Segment_Hash', pretty_print=pretty_print)
        if self.Raw_Segment_Content is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRaw_Segment_Content>%s</%sRaw_Segment_Content>%s' % (namespace_, self.gds_format_string(quote_xml(self.Raw_Segment_Content).encode(ExternalEncoding), input_name='Raw_Segment_Content'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='HashSegmentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Trigger_Point is not None:
            showIndent(outfile, level)
            outfile.write('Trigger_Point=model_.HexBinaryObjectPropertyType(\n')
            self.Trigger_Point.exportLiteral(outfile, level, name_='Trigger_Point')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Segment_Hash is not None:
            showIndent(outfile, level)
            outfile.write('Segment_Hash=model_.HashValueType(\n')
            self.Segment_Hash.exportLiteral(outfile, level, name_='Segment_Hash')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Raw_Segment_Content is not None:
            showIndent(outfile, level)
            outfile.write('Raw_Segment_Content=%s,\n' % quote_python(self.Raw_Segment_Content).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Trigger_Point':
            obj_ = None
            self.Trigger_Point = obj_
            self.validate_HexBinaryObjectPropertyType(self.Trigger_Point)    # validate type HexBinaryObjectPropertyType
        elif nodeName_ == 'Segment_Hash':
            obj_ = HashValueType.factory()
            obj_.build(child_)
            self.Segment_Hash = obj_
        elif nodeName_ == 'Raw_Segment_Content':
            Raw_Segment_Content_ = child_.text
            Raw_Segment_Content_ = self.gds_validate_string(Raw_Segment_Content_, node, 'Raw_Segment_Content')
            self.Raw_Segment_Content = Raw_Segment_Content_
# end class HashSegmentType


class HashType(GeneratedsSuper):
    """The HashType type is intended to characterize hash values."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Simple_Hash_Value=None, Fuzzy_Hash_Value=None, Fuzzy_Hash_Structure=None):
        self.Type = Type
        self.Simple_Hash_Value = Simple_Hash_Value
        self.Fuzzy_Hash_Value = Fuzzy_Hash_Value
        if Fuzzy_Hash_Structure is None:
            self.Fuzzy_Hash_Structure = []
        else:
            self.Fuzzy_Hash_Structure = Fuzzy_Hash_Structure
    def factory(*args_, **kwargs_):
        if HashType.subclass:
            return HashType.subclass(*args_, **kwargs_)
        else:
            return HashType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Simple_Hash_Value(self): return self.Simple_Hash_Value
    def set_Simple_Hash_Value(self, Simple_Hash_Value): self.Simple_Hash_Value = Simple_Hash_Value
    def get_Fuzzy_Hash_Value(self): return self.Fuzzy_Hash_Value
    def set_Fuzzy_Hash_Value(self, Fuzzy_Hash_Value): self.Fuzzy_Hash_Value = Fuzzy_Hash_Value
    def get_Fuzzy_Hash_Structure(self): return self.Fuzzy_Hash_Structure
    def set_Fuzzy_Hash_Structure(self, Fuzzy_Hash_Structure): self.Fuzzy_Hash_Structure = Fuzzy_Hash_Structure
    def add_Fuzzy_Hash_Structure(self, value): self.Fuzzy_Hash_Structure.append(value)
    def insert_Fuzzy_Hash_Structure(self, index, value): self.Fuzzy_Hash_Structure[index] = value
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Simple_Hash_Value is not None or
            self.Fuzzy_Hash_Value is not None or
            self.Fuzzy_Hash_Structure
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HashType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HashType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HashType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HashType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Simple_Hash_Value is not None:
            self.Simple_Hash_Value.export(outfile, level, namespace_, name_='Simple_Hash_Value', pretty_print=pretty_print)
        if self.Fuzzy_Hash_Value is not None:
            self.Fuzzy_Hash_Value.export(outfile, level, namespace_, name_='Fuzzy_Hash_Value', pretty_print=pretty_print)
        for Fuzzy_Hash_Structure_ in self.Fuzzy_Hash_Structure:
            Fuzzy_Hash_Structure_.export(outfile, level, namespace_, name_='Fuzzy_Hash_Structure', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HashType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.ControlledVocabularyStringType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Simple_Hash_Value is not None:
            showIndent(outfile, level)
            outfile.write('Simple_Hash_Value=model_.SimpleHashValueType(\n')
            self.Simple_Hash_Value.exportLiteral(outfile, level, name_='Simple_Hash_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Fuzzy_Hash_Value is not None:
            showIndent(outfile, level)
            outfile.write('Fuzzy_Hash_Value=model_.FuzzyHashValueType(\n')
            self.Fuzzy_Hash_Value.exportLiteral(outfile, level, name_='Fuzzy_Hash_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Fuzzy_Hash_Structure=[\n')
        level += 1
        for Fuzzy_Hash_Structure_ in self.Fuzzy_Hash_Structure:
            showIndent(outfile, level)
            outfile.write('model_.FuzzyHashStructureType(\n')
            Fuzzy_Hash_Structure_.exportLiteral(outfile, level, name_='FuzzyHashStructureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Type = obj_
        elif nodeName_ == 'Simple_Hash_Value':
            obj_ = SimpleHashValueType.factory()
            obj_.build(child_)
            self.Simple_Hash_Value = obj_
        elif nodeName_ == 'Fuzzy_Hash_Value':
            obj_ = FuzzyHashValueType.factory()
            obj_.build(child_)
            self.Fuzzy_Hash_Value = obj_
        elif nodeName_ == 'Fuzzy_Hash_Structure':
            obj_ = FuzzyHashStructureType.factory()
            obj_.build(child_)
            self.Fuzzy_Hash_Structure.append(obj_)
# end class HashType


class StructuredTextType(GeneratedsSuper):
    """The StructuredTextType is a type representing a generalized
    structure for capturing structured or unstructured textual
    information such as descriptions of things.Used to indicate a
    particular structuring format (e.g., HTML5) used within an
    instance of StructuredTextType. Note that if the markup tags
    used by this format would be interpreted as XML information
    (such as the bracket-based tags of HTML) the text area should be
    enclosed in a CDATA section to prevent the markup from
    interferring with XML validation of the CybOX document. If this
    attribute is absent, the implication is that no markup is being
    used."""
    subclass = None
    superclass = None
    def __init__(self, structuring_format=None, valueOf_=None):
        self.structuring_format = _cast(None, structuring_format)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if StructuredTextType.subclass:
            return StructuredTextType.subclass(*args_, **kwargs_)
        else:
            return StructuredTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_structuring_format(self): return self.structuring_format
    def set_structuring_format(self, structuring_format): self.structuring_format = structuring_format
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='StructuredTextType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuredTextType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='StructuredTextType'):
        if self.structuring_format is not None and 'structuring_format' not in already_processed:
            already_processed.add('structuring_format')
            outfile.write(' structuring_format=%s' % (self.gds_format_string(quote_attrib(self.structuring_format).encode(ExternalEncoding), input_name='structuring_format'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='StructuredTextType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='StructuredTextType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.structuring_format is not None and 'structuring_format' not in already_processed:
            already_processed.add('structuring_format')
            showIndent(outfile, level)
            outfile.write('structuring_format="%s",\n' % (self.structuring_format,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('structuring_format', node)
        if value is not None and 'structuring_format' not in already_processed:
            already_processed.add('structuring_format')
            self.structuring_format = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StructuredTextType


class ReferenceListType(GeneratedsSuper):
    """The ReferencesListType contains one or more Reference elements, each
    of which provide further reading and insight into the item. This
    should be filled out as appropriate."""
    subclass = None
    superclass = None
    def __init__(self, Reference=None):
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if ReferenceListType.subclass:
            return ReferenceListType.subclass(*args_, **kwargs_)
        else:
            return ReferenceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference(self, index, value): self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ReferenceListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ReferenceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ReferenceListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            Reference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
# end class ReferenceListType


class ReferenceType(GeneratedsSuper):
    """The ReferenceType is a type representing a single reference to a
    source of information. The id field is optional and is used as a
    mechanism for citing text in the entry. If an id is provided, it
    is placed between brackets and precedes this reference and the
    matching id should be used inside of the text for the entry
    itself where this reference is applicable. All reference ids
    assigned within an entry must be unique."""
    subclass = None
    superclass = None
    def __init__(self, reference_id=None, Reference_Description=None, Reference_Author=None, Reference_Title=None, Reference_Section=None, Reference_Edition=None, Reference_Publication=None, Reference_Publisher=None, Reference_Date=None, Reference_PubDate=None, Reference_Link=None):
        self.reference_id = _cast(None, reference_id)
        self.Reference_Description = Reference_Description
        if Reference_Author is None:
            self.Reference_Author = []
        else:
            self.Reference_Author = Reference_Author
        self.Reference_Title = Reference_Title
        self.Reference_Section = Reference_Section
        self.Reference_Edition = Reference_Edition
        self.Reference_Publication = Reference_Publication
        self.Reference_Publisher = Reference_Publisher
        if isinstance(Reference_Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Reference_Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Reference_Date
        self.Reference_Date = initvalue_
        self.Reference_PubDate = Reference_PubDate
        self.Reference_Link = Reference_Link
    def factory(*args_, **kwargs_):
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference_Description(self): return self.Reference_Description
    def set_Reference_Description(self, Reference_Description): self.Reference_Description = Reference_Description
    def get_Reference_Author(self): return self.Reference_Author
    def set_Reference_Author(self, Reference_Author): self.Reference_Author = Reference_Author
    def add_Reference_Author(self, value): self.Reference_Author.append(value)
    def insert_Reference_Author(self, index, value): self.Reference_Author[index] = value
    def get_Reference_Title(self): return self.Reference_Title
    def set_Reference_Title(self, Reference_Title): self.Reference_Title = Reference_Title
    def get_Reference_Section(self): return self.Reference_Section
    def set_Reference_Section(self, Reference_Section): self.Reference_Section = Reference_Section
    def get_Reference_Edition(self): return self.Reference_Edition
    def set_Reference_Edition(self, Reference_Edition): self.Reference_Edition = Reference_Edition
    def get_Reference_Publication(self): return self.Reference_Publication
    def set_Reference_Publication(self, Reference_Publication): self.Reference_Publication = Reference_Publication
    def get_Reference_Publisher(self): return self.Reference_Publisher
    def set_Reference_Publisher(self, Reference_Publisher): self.Reference_Publisher = Reference_Publisher
    def get_Reference_Date(self): return self.Reference_Date
    def set_Reference_Date(self, Reference_Date): self.Reference_Date = Reference_Date
    def get_Reference_PubDate(self): return self.Reference_PubDate
    def set_Reference_PubDate(self, Reference_PubDate): self.Reference_PubDate = Reference_PubDate
    def get_Reference_Link(self): return self.Reference_Link
    def set_Reference_Link(self, Reference_Link): self.Reference_Link = Reference_Link
    def get_reference_id(self): return self.reference_id
    def set_reference_id(self, reference_id): self.reference_id = reference_id
    def hasContent_(self):
        if (
            self.Reference_Description is not None or
            self.Reference_Author or
            self.Reference_Title is not None or
            self.Reference_Section is not None or
            self.Reference_Edition is not None or
            self.Reference_Publication is not None or
            self.Reference_Publisher is not None or
            self.Reference_Date is not None or
            self.Reference_PubDate is not None or
            self.Reference_Link is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ReferenceType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ReferenceType'):
        if self.reference_id is not None and 'reference_id' not in already_processed:
            already_processed.add('reference_id')
            outfile.write(' reference_id=%s' % (self.gds_format_string(quote_attrib(self.reference_id).encode(ExternalEncoding), input_name='reference_id'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Reference_Description is not None:
            self.Reference_Description.export(outfile, level, namespace_, name_='Reference_Description', pretty_print=pretty_print)
        for Reference_Author_ in self.Reference_Author:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Author>%s</%sReference_Author>%s' % (namespace_, self.gds_format_string(quote_xml(Reference_Author_).encode(ExternalEncoding), input_name='Reference_Author'), namespace_, eol_))
        if self.Reference_Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Title>%s</%sReference_Title>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Title).encode(ExternalEncoding), input_name='Reference_Title'), namespace_, eol_))
        if self.Reference_Section is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Section>%s</%sReference_Section>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Section).encode(ExternalEncoding), input_name='Reference_Section'), namespace_, eol_))
        if self.Reference_Edition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Edition>%s</%sReference_Edition>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Edition).encode(ExternalEncoding), input_name='Reference_Edition'), namespace_, eol_))
        if self.Reference_Publication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Publication>%s</%sReference_Publication>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Publication).encode(ExternalEncoding), input_name='Reference_Publication'), namespace_, eol_))
        if self.Reference_Publisher is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Publisher>%s</%sReference_Publisher>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Publisher).encode(ExternalEncoding), input_name='Reference_Publisher'), namespace_, eol_))
        if self.Reference_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Date>%s</%sReference_Date>%s' % (namespace_, self.gds_format_date(self.Reference_Date, input_name='Reference_Date'), namespace_, eol_))
        if self.Reference_PubDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_PubDate>%s</%sReference_PubDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_PubDate).encode(ExternalEncoding), input_name='Reference_PubDate'), namespace_, eol_))
        if self.Reference_Link is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Link>%s</%sReference_Link>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Link).encode(ExternalEncoding), input_name='Reference_Link'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reference_id is not None and 'reference_id' not in already_processed:
            already_processed.add('reference_id')
            showIndent(outfile, level)
            outfile.write('reference_id="%s",\n' % (self.reference_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Reference_Description is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Description=model_.StructuredTextType(\n')
            self.Reference_Description.exportLiteral(outfile, level, name_='Reference_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Reference_Author=[\n')
        level += 1
        for Reference_Author_ in self.Reference_Author:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Reference_Author_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Reference_Title is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Title=%s,\n' % quote_python(self.Reference_Title).encode(ExternalEncoding))
        if self.Reference_Section is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Section=%s,\n' % quote_python(self.Reference_Section).encode(ExternalEncoding))
        if self.Reference_Edition is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Edition=%s,\n' % quote_python(self.Reference_Edition).encode(ExternalEncoding))
        if self.Reference_Publication is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Publication=%s,\n' % quote_python(self.Reference_Publication).encode(ExternalEncoding))
        if self.Reference_Publisher is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Publisher=%s,\n' % quote_python(self.Reference_Publisher).encode(ExternalEncoding))
        if self.Reference_Date is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.Reference_Date, input_name='Reference_Date'))
        if self.Reference_PubDate is not None:
            showIndent(outfile, level)
            outfile.write('Reference_PubDate=%s,\n' % quote_python(self.Reference_PubDate).encode(ExternalEncoding))
        if self.Reference_Link is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Link=%s,\n' % quote_python(self.Reference_Link).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference_id', node)
        if value is not None and 'reference_id' not in already_processed:
            already_processed.add('reference_id')
            self.reference_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference_Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Reference_Description = obj_
        elif nodeName_ == 'Reference_Author':
            Reference_Author_ = child_.text
            Reference_Author_ = self.gds_validate_string(Reference_Author_, node, 'Reference_Author')
            self.Reference_Author.append(Reference_Author_)
        elif nodeName_ == 'Reference_Title':
            Reference_Title_ = child_.text
            Reference_Title_ = self.gds_validate_string(Reference_Title_, node, 'Reference_Title')
            self.Reference_Title = Reference_Title_
        elif nodeName_ == 'Reference_Section':
            Reference_Section_ = child_.text
            Reference_Section_ = self.gds_validate_string(Reference_Section_, node, 'Reference_Section')
            self.Reference_Section = Reference_Section_
        elif nodeName_ == 'Reference_Edition':
            Reference_Edition_ = child_.text
            Reference_Edition_ = self.gds_validate_string(Reference_Edition_, node, 'Reference_Edition')
            self.Reference_Edition = Reference_Edition_
        elif nodeName_ == 'Reference_Publication':
            Reference_Publication_ = child_.text
            Reference_Publication_ = self.gds_validate_string(Reference_Publication_, node, 'Reference_Publication')
            self.Reference_Publication = Reference_Publication_
        elif nodeName_ == 'Reference_Publisher':
            Reference_Publisher_ = child_.text
            Reference_Publisher_ = self.gds_validate_string(Reference_Publisher_, node, 'Reference_Publisher')
            self.Reference_Publisher = Reference_Publisher_
        elif nodeName_ == 'Reference_Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Reference_Date = dval_
        elif nodeName_ == 'Reference_PubDate':
            Reference_PubDate_ = child_.text
            Reference_PubDate_ = self.gds_validate_string(Reference_PubDate_, node, 'Reference_PubDate')
            self.Reference_PubDate = Reference_PubDate_
        elif nodeName_ == 'Reference_Link':
            Reference_Link_ = child_.text
            Reference_Link_ = self.gds_validate_string(Reference_Link_, node, 'Reference_Link')
            self.Reference_Link = Reference_Link_
# end class ReferenceType


class DataSegmentType(GeneratedsSuper):
    """The DataSegmentType is intended to provide a relatively abstract way
    of characterizing data segments that may be
    written/read/transmitted or otherwise utilized in actions or
    behaviors. The id field specifies a unique id for this data
    segment."""
    subclass = None
    superclass = None
    def __init__(self, id=None, Data_Format=None, Data_Size=None, Data_Segment=None, Offset=None, Search_Distance=None, Search_Within=None):
        self.id = _cast(None, id)
        self.Data_Format = Data_Format
        self.Data_Size = Data_Size
        self.Data_Segment = Data_Segment
        self.Offset = Offset
        self.Search_Distance = Search_Distance
        self.Search_Within = Search_Within
    def factory(*args_, **kwargs_):
        if DataSegmentType.subclass:
            return DataSegmentType.subclass(*args_, **kwargs_)
        else:
            return DataSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Data_Format(self): return self.Data_Format
    def set_Data_Format(self, Data_Format): self.Data_Format = Data_Format
    def get_Data_Size(self): return self.Data_Size
    def set_Data_Size(self, Data_Size): self.Data_Size = Data_Size
    def get_Data_Segment(self): return self.Data_Segment
    def set_Data_Segment(self, Data_Segment): self.Data_Segment = Data_Segment
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_Search_Distance(self): return self.Search_Distance
    def set_Search_Distance(self, Search_Distance): self.Search_Distance = Search_Distance
    def get_Search_Within(self): return self.Search_Within
    def set_Search_Within(self, Search_Within): self.Search_Within = Search_Within
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_DataFormatEnum(self, value):
        # Validate type DataFormatEnum, a restriction on xs:string.
        pass
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def validate_IntegerObjectPropertyType(self, value):
        # Validate type IntegerObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Data_Format is not None or
            self.Data_Size is not None or
            self.Data_Segment is not None or
            self.Offset is not None or
            self.Search_Distance is not None or
            self.Search_Within is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DataSegmentType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSegmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DataSegmentType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DataSegmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Data_Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sData_Format>%s</%sData_Format>%s' % (namespace_, self.gds_format_string(quote_xml(self.Data_Format).encode(ExternalEncoding), input_name='Data_Format'), namespace_, eol_))
        if self.Data_Size is not None:
            self.Data_Size.export(outfile, level, namespace_, name_='Data_Size', pretty_print=pretty_print)
        if self.Data_Segment is not None:
            self.Data_Segment.export(outfile, level, namespace_, name_='Data_Segment', pretty_print=pretty_print)
        if self.Offset is not None:
            self.Offset.export(outfile, level, namespace_, name_='Offset', pretty_print=pretty_print)
        if self.Search_Distance is not None:
            self.Search_Distance.export(outfile, level, namespace_, name_='Search_Distance', pretty_print=pretty_print)
        if self.Search_Within is not None:
            self.Search_Within.export(outfile, level, namespace_, name_='Search_Within', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataSegmentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Data_Format is not None:
            showIndent(outfile, level)
            outfile.write('Data_Format=%s,\n' % quote_python(self.Data_Format).encode(ExternalEncoding))
        if self.Data_Size is not None:
            showIndent(outfile, level)
            outfile.write('Data_Size=model_.DataSizeType(\n')
            self.Data_Size.exportLiteral(outfile, level, name_='Data_Size')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Data_Segment is not None:
            showIndent(outfile, level)
            outfile.write('Data_Segment=model_.StringObjectPropertyType(\n')
            self.Data_Segment.exportLiteral(outfile, level, name_='Data_Segment')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Offset is not None:
            showIndent(outfile, level)
            outfile.write('Offset=model_.IntegerObjectPropertyType(\n')
            self.Offset.exportLiteral(outfile, level, name_='Offset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Search_Distance is not None:
            showIndent(outfile, level)
            outfile.write('Search_Distance=model_.IntegerObjectPropertyType(\n')
            self.Search_Distance.exportLiteral(outfile, level, name_='Search_Distance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Search_Within is not None:
            showIndent(outfile, level)
            outfile.write('Search_Within=model_.IntegerObjectPropertyType(\n')
            self.Search_Within.exportLiteral(outfile, level, name_='Search_Within')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Data_Format':
            Data_Format_ = child_.text
            Data_Format_ = self.gds_validate_string(Data_Format_, node, 'Data_Format')
            self.Data_Format = Data_Format_
            self.validate_DataFormatEnum(self.Data_Format)    # validate type DataFormatEnum
        elif nodeName_ == 'Data_Size':
            obj_ = DataSizeType.factory()
            obj_.build(child_)
            self.Data_Size = obj_
        elif nodeName_ == 'Data_Segment':
            obj_ = None
            self.Data_Segment = obj_
            self.validate_StringObjectPropertyType(self.Data_Segment)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Offset':
            obj_ = None
            self.Offset = obj_
            self.validate_IntegerObjectPropertyType(self.Offset)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Search_Distance':
            obj_ = None
            self.Search_Distance = obj_
            self.validate_IntegerObjectPropertyType(self.Search_Distance)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Search_Within':
            obj_ = None
            self.Search_Within = obj_
            self.validate_IntegerObjectPropertyType(self.Search_Within)    # validate type IntegerObjectPropertyType
# end class DataSegmentType


class DataSizeType(StringObjectPropertyType):
    """The DataSizeType specifies the size of the data segment.This field
    represents the Units used in the object size element. Possible
    values are: Bytes, Kilobytes, Megabytes."""
    subclass = None
    superclass = StringObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, units=None, valueOf_=None):
        super(DataSizeType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DataSizeType.subclass:
            return DataSizeType.subclass(*args_, **kwargs_)
        else:
            return DataSizeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DataSizeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DataSizeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSizeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DataSizeType'):
        super(DataSizeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DataSizeType')
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DataSizeType', fromsubclass_=False, pretty_print=True):
        super(DataSizeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DataSizeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units=%s,\n' % (self.units,))
        super(DataSizeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DataSizeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
        super(DataSizeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataSizeType


class PlatformSpecificationType(GeneratedsSuper):
    """PlatformSpecificationType is a modularized data type intended for
    providing a consistent approach to uniquely specifying the
    identity of a specific platform.In addition to capturing basic
    information, this type is intended to be extended to enable the
    structured description of a platform instance using the XML
    Schema extension feature. The CybOX default extension uses the
    Common Platform Enumeration (CPE) Applicability Language schema
    to do so. The extension that defines this is captured in the
    CPE23PlatformSpecificationType in the
    http://cybox.mitre.org/extensions/platform#CPE2.3-1 namespace.
    This type is defined in the extensions/platform/cpe2.3.xsd file."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Identifier=None):
        self.Description = Description
        if Identifier is None:
            self.Identifier = []
        else:
            self.Identifier = Identifier
    def factory(*args_, **kwargs_):
        if PlatformSpecificationType.subclass:
            return PlatformSpecificationType.subclass(*args_, **kwargs_)
        else:
            return PlatformSpecificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Identifier(self): return self.Identifier
    def set_Identifier(self, Identifier): self.Identifier = Identifier
    def add_Identifier(self, value): self.Identifier.append(value)
    def insert_Identifier(self, index, value): self.Identifier[index] = value
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Identifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PlatformSpecificationType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformSpecificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PlatformSpecificationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PlatformSpecificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Identifier_ in self.Identifier:
            Identifier_.export(outfile, level, namespace_, name_='Identifier', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformSpecificationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Identifier=[\n')
        level += 1
        for Identifier_ in self.Identifier:
            showIndent(outfile, level)
            outfile.write('model_.PlatformIdentifierType(\n')
            Identifier_.exportLiteral(outfile, level, name_='PlatformIdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Identifier':
            obj_ = PlatformIdentifierType.factory()
            obj_.build(child_)
            self.Identifier.append(obj_)
# end class PlatformSpecificationType


class PlatformIdentifierType(StringObjectPropertyType):
    """Used to specify a name for a platform using a particular naming
    system and also allowing a reference pointing to more
    information about that naming scheme. For example, one could
    provide a CPE (Common Platform Enumeration) name using the CPE
    naming format. In this case, the system value could be "CPE"
    while the system_ref value could be
    "http://scap.nist.gov/specifications/cpe/".Indicates the naming
    system from which the indicated name was drawn.A reference to
    information about the naming system from which the indicated
    name was drawn."""
    subclass = None
    superclass = StringObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, system_ref=None, system=None, valueOf_=None):
        super(PlatformIdentifierType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.system_ref = _cast(None, system_ref)
        self.system = _cast(None, system)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PlatformIdentifierType.subclass:
            return PlatformIdentifierType.subclass(*args_, **kwargs_)
        else:
            return PlatformIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_system_ref(self): return self.system_ref
    def set_system_ref(self, system_ref): self.system_ref = system_ref
    def get_system(self): return self.system
    def set_system(self, system): self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(PlatformIdentifierType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PlatformIdentifierType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformIdentifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PlatformIdentifierType'):
        super(PlatformIdentifierType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformIdentifierType')
        if self.system_ref is not None and 'system_ref' not in already_processed:
            already_processed.add('system_ref')
            outfile.write(' system-ref=%s' % (self.gds_format_string(quote_attrib(self.system_ref).encode(ExternalEncoding), input_name='system-ref'), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (self.gds_format_string(quote_attrib(self.system).encode(ExternalEncoding), input_name='system'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PlatformIdentifierType', fromsubclass_=False, pretty_print=True):
        super(PlatformIdentifierType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PlatformIdentifierType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.system_ref is not None and 'system_ref' not in already_processed:
            already_processed.add('system_ref')
            showIndent(outfile, level)
            outfile.write('system_ref="%s",\n' % (self.system_ref,))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            showIndent(outfile, level)
            outfile.write('system="%s",\n' % (self.system,))
        super(PlatformIdentifierType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PlatformIdentifierType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system-ref', node)
        if value is not None and 'system-ref' not in already_processed:
            already_processed.add('system-ref')
            self.system_ref = value
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        super(PlatformIdentifierType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PlatformIdentifierType


class MetadataType(GeneratedsSuper):
    """The MetadataType is intended as mechanism to capture any non-
    context-specific metadataThis field specifies the type of name
    of a single metadata field."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, Value=None, SubDatum=None):
        self.type_ = _cast(None, type_)
        self.Value = Value
        if SubDatum is None:
            self.SubDatum = []
        else:
            self.SubDatum = SubDatum
    def factory(*args_, **kwargs_):
        if MetadataType.subclass:
            return MetadataType.subclass(*args_, **kwargs_)
        else:
            return MetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_SubDatum(self): return self.SubDatum
    def set_SubDatum(self, SubDatum): self.SubDatum = SubDatum
    def add_SubDatum(self, value): self.SubDatum.append(value)
    def insert_SubDatum(self, index, value): self.SubDatum[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Value is not None or
            self.SubDatum
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='MetadataType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='MetadataType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='MetadataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
        for SubDatum_ in self.SubDatum:
            SubDatum_.export(outfile, level, namespace_, name_='SubDatum', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('SubDatum=[\n')
        level += 1
        for SubDatum_ in self.SubDatum:
            showIndent(outfile, level)
            outfile.write('model_.MetadataType(\n')
            SubDatum_.exportLiteral(outfile, level, name_='MetadataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'SubDatum':
            obj_ = MetadataType.factory()
            obj_.build(child_)
            self.SubDatum.append(obj_)
# end class MetadataType


class EnvironmentVariableListType(GeneratedsSuper):
    """The EnvironmentVariableListType type is used for representing a list
    of environment variables."""
    subclass = None
    superclass = None
    def __init__(self, Environment_Variable=None):
        if Environment_Variable is None:
            self.Environment_Variable = []
        else:
            self.Environment_Variable = Environment_Variable
    def factory(*args_, **kwargs_):
        if EnvironmentVariableListType.subclass:
            return EnvironmentVariableListType.subclass(*args_, **kwargs_)
        else:
            return EnvironmentVariableListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Environment_Variable(self): return self.Environment_Variable
    def set_Environment_Variable(self, Environment_Variable): self.Environment_Variable = Environment_Variable
    def add_Environment_Variable(self, value): self.Environment_Variable.append(value)
    def insert_Environment_Variable(self, index, value): self.Environment_Variable[index] = value
    def hasContent_(self):
        if (
            self.Environment_Variable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='EnvironmentVariableListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentVariableListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='EnvironmentVariableListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='EnvironmentVariableListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Environment_Variable_ in self.Environment_Variable:
            Environment_Variable_.export(outfile, level, namespace_, name_='Environment_Variable', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EnvironmentVariableListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Environment_Variable=[\n')
        level += 1
        for Environment_Variable_ in self.Environment_Variable:
            showIndent(outfile, level)
            outfile.write('model_.EnvironmentVariableType(\n')
            Environment_Variable_.exportLiteral(outfile, level, name_='EnvironmentVariableType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Environment_Variable':
            obj_ = EnvironmentVariableType.factory()
            obj_.build(child_)
            self.Environment_Variable.append(obj_)
# end class EnvironmentVariableListType


class EnvironmentVariableType(GeneratedsSuper):
    """The EnvironmentVariableType type is used for representing
    environment variables using a name/value pair."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None):
        self.Name = Name
        self.Value = Value
    def factory(*args_, **kwargs_):
        if EnvironmentVariableType.subclass:
            return EnvironmentVariableType.subclass(*args_, **kwargs_)
        else:
            return EnvironmentVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='EnvironmentVariableType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentVariableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='EnvironmentVariableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='EnvironmentVariableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.Value is not None:
            self.Value.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EnvironmentVariableType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.StringObjectPropertyType(\n')
            self.Name.exportLiteral(outfile, level, name_='Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=model_.StringObjectPropertyType(\n')
            self.Value.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = None
            self.Name = obj_
            self.validate_StringObjectPropertyType(self.Name)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Value':
            obj_ = None
            self.Value = obj_
            self.validate_StringObjectPropertyType(self.Value)    # validate type StringObjectPropertyType
# end class EnvironmentVariableType


class DigitalSignaturesType(GeneratedsSuper):
    """The DigitalSignaturesType is used for representing a list of digital
    signatures."""
    subclass = None
    superclass = None
    def __init__(self, Digital_Signature=None):
        if Digital_Signature is None:
            self.Digital_Signature = []
        else:
            self.Digital_Signature = Digital_Signature
    def factory(*args_, **kwargs_):
        if DigitalSignaturesType.subclass:
            return DigitalSignaturesType.subclass(*args_, **kwargs_)
        else:
            return DigitalSignaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Digital_Signature(self): return self.Digital_Signature
    def set_Digital_Signature(self, Digital_Signature): self.Digital_Signature = Digital_Signature
    def add_Digital_Signature(self, value): self.Digital_Signature.append(value)
    def insert_Digital_Signature(self, index, value): self.Digital_Signature[index] = value
    def hasContent_(self):
        if (
            self.Digital_Signature
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DigitalSignaturesType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DigitalSignaturesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DigitalSignaturesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DigitalSignaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Digital_Signature_ in self.Digital_Signature:
            Digital_Signature_.export(outfile, level, namespace_, name_='Digital_Signature', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DigitalSignaturesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Digital_Signature=[\n')
        level += 1
        for Digital_Signature_ in self.Digital_Signature:
            showIndent(outfile, level)
            outfile.write('model_.DigitalSignatureInfoType(\n')
            Digital_Signature_.exportLiteral(outfile, level, name_='DigitalSignatureInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Digital_Signature':
            obj_ = DigitalSignatureInfoType.factory()
            obj_.build(child_)
            self.Digital_Signature.append(obj_)
# end class DigitalSignaturesType


class DigitalSignatureInfoType(GeneratedsSuper):
    """The DigitalSignatureInfoType type is used as a way to represent some
    of the basic information about a digital signature.Specifies
    whether the digital signature exists.Specifies if the digital
    signature is verified."""
    subclass = None
    superclass = None
    def __init__(self, signature_verified=None, signature_exists=None, Certificate_Issuer=None, Certificate_Subject=None, Signature_Description=None):
        self.signature_verified = _cast(bool, signature_verified)
        self.signature_exists = _cast(bool, signature_exists)
        self.Certificate_Issuer = Certificate_Issuer
        self.Certificate_Subject = Certificate_Subject
        self.Signature_Description = Signature_Description
    def factory(*args_, **kwargs_):
        if DigitalSignatureInfoType.subclass:
            return DigitalSignatureInfoType.subclass(*args_, **kwargs_)
        else:
            return DigitalSignatureInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Certificate_Issuer(self): return self.Certificate_Issuer
    def set_Certificate_Issuer(self, Certificate_Issuer): self.Certificate_Issuer = Certificate_Issuer
    def get_Certificate_Subject(self): return self.Certificate_Subject
    def set_Certificate_Subject(self, Certificate_Subject): self.Certificate_Subject = Certificate_Subject
    def get_Signature_Description(self): return self.Signature_Description
    def set_Signature_Description(self, Signature_Description): self.Signature_Description = Signature_Description
    def get_signature_verified(self): return self.signature_verified
    def set_signature_verified(self, signature_verified): self.signature_verified = signature_verified
    def get_signature_exists(self): return self.signature_exists
    def set_signature_exists(self, signature_exists): self.signature_exists = signature_exists
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Certificate_Issuer is not None or
            self.Certificate_Subject is not None or
            self.Signature_Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DigitalSignatureInfoType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DigitalSignatureInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DigitalSignatureInfoType'):
        if self.signature_verified is not None and 'signature_verified' not in already_processed:
            already_processed.add('signature_verified')
            outfile.write(' signature_verified="%s"' % self.gds_format_boolean(self.signature_verified, input_name='signature_verified'))
        if self.signature_exists is not None and 'signature_exists' not in already_processed:
            already_processed.add('signature_exists')
            outfile.write(' signature_exists="%s"' % self.gds_format_boolean(self.signature_exists, input_name='signature_exists'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DigitalSignatureInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Certificate_Issuer is not None:
            self.Certificate_Issuer.export(outfile, level, namespace_, name_='Certificate_Issuer', pretty_print=pretty_print)
        if self.Certificate_Subject is not None:
            self.Certificate_Subject.export(outfile, level, namespace_, name_='Certificate_Subject', pretty_print=pretty_print)
        if self.Signature_Description is not None:
            self.Signature_Description.export(outfile, level, namespace_, name_='Signature_Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DigitalSignatureInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.signature_verified is not None and 'signature_verified' not in already_processed:
            already_processed.add('signature_verified')
            showIndent(outfile, level)
            outfile.write('signature_verified=%s,\n' % (self.signature_verified,))
        if self.signature_exists is not None and 'signature_exists' not in already_processed:
            already_processed.add('signature_exists')
            showIndent(outfile, level)
            outfile.write('signature_exists=%s,\n' % (self.signature_exists,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Certificate_Issuer is not None:
            showIndent(outfile, level)
            outfile.write('Certificate_Issuer=model_.StringObjectPropertyType(\n')
            self.Certificate_Issuer.exportLiteral(outfile, level, name_='Certificate_Issuer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Certificate_Subject is not None:
            showIndent(outfile, level)
            outfile.write('Certificate_Subject=model_.StringObjectPropertyType(\n')
            self.Certificate_Subject.exportLiteral(outfile, level, name_='Certificate_Subject')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Signature_Description is not None:
            showIndent(outfile, level)
            outfile.write('Signature_Description=model_.StringObjectPropertyType(\n')
            self.Signature_Description.exportLiteral(outfile, level, name_='Signature_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('signature_verified', node)
        if value is not None and 'signature_verified' not in already_processed:
            already_processed.add('signature_verified')
            if value in ('true', '1'):
                self.signature_verified = True
            elif value in ('false', '0'):
                self.signature_verified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('signature_exists', node)
        if value is not None and 'signature_exists' not in already_processed:
            already_processed.add('signature_exists')
            if value in ('true', '1'):
                self.signature_exists = True
            elif value in ('false', '0'):
                self.signature_exists = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Certificate_Issuer':
            obj_ = None
            self.Certificate_Issuer = obj_
            self.validate_StringObjectPropertyType(self.Certificate_Issuer)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Certificate_Subject':
            obj_ = None
            self.Certificate_Subject = obj_
            self.validate_StringObjectPropertyType(self.Certificate_Subject)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Signature_Description':
            obj_ = None
            self.Signature_Description = obj_
            self.validate_StringObjectPropertyType(self.Signature_Description)    # validate type StringObjectPropertyType
# end class DigitalSignatureInfoType


class PatternableFieldType(GeneratedsSuper):
    """The PatternableFieldType is a grouping of attributes applicable to
    defining patterns on a specific field."""
    subclass = None
    superclass = None
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, valueOf_=None, extensiontype_=None):
        self.pattern_type = _cast(None, pattern_type)
        self.has_changed = _cast(bool, has_changed)
        self.trend = _cast(bool, trend)
        self.apply_condition = _cast(None, apply_condition)
        self.bit_mask = _cast(None, bit_mask)
        self.regex_syntax = _cast(None, regex_syntax)
        self.condition = _cast(None, condition)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if PatternableFieldType.subclass:
            return PatternableFieldType.subclass(*args_, **kwargs_)
        else:
            return PatternableFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pattern_type(self): return self.pattern_type
    def set_pattern_type(self, pattern_type): self.pattern_type = pattern_type
    def get_has_changed(self): return self.has_changed
    def set_has_changed(self, has_changed): self.has_changed = has_changed
    def get_trend(self): return self.trend
    def set_trend(self, trend): self.trend = trend
    def get_apply_condition(self): return self.apply_condition
    def set_apply_condition(self, apply_condition): self.apply_condition = apply_condition
    def get_bit_mask(self): return self.bit_mask
    def set_bit_mask(self, bit_mask): self.bit_mask = bit_mask
    def get_regex_syntax(self): return self.regex_syntax
    def set_regex_syntax(self, regex_syntax): self.regex_syntax = regex_syntax
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PatternableFieldType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PatternableFieldType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PatternableFieldType'):
        if self.pattern_type is not None and 'pattern_type' not in already_processed:
            already_processed.add('pattern_type')
            outfile.write(' pattern_type=%s' % (quote_attrib(self.pattern_type), ))
        if self.has_changed is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            outfile.write(' has_changed="%s"' % self.gds_format_boolean(self.has_changed, input_name='has_changed'))
        if self.trend is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            outfile.write(' trend="%s"' % self.gds_format_boolean(self.trend, input_name='trend'))
        if self.apply_condition is not None and 'apply_condition' not in already_processed:
            already_processed.add('apply_condition')
            outfile.write(' apply_condition=%s' % (quote_attrib(self.apply_condition), ))
        if self.bit_mask is not None and 'bit_mask' not in already_processed:
            already_processed.add('bit_mask')
            outfile.write(' bit_mask=%s' % (self.gds_format_string(quote_attrib(self.bit_mask).encode(ExternalEncoding), input_name='bit_mask'), ))
        if self.regex_syntax is not None and 'regex_syntax' not in already_processed:
            already_processed.add('regex_syntax')
            outfile.write(' regex_syntax=%s' % (self.gds_format_string(quote_attrib(self.regex_syntax).encode(ExternalEncoding), input_name='regex_syntax'), ))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            outfile.write(' condition=%s' % (quote_attrib(self.condition), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PatternableFieldType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PatternableFieldType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pattern_type is not None and 'pattern_type' not in already_processed:
            already_processed.add('pattern_type')
            showIndent(outfile, level)
            outfile.write('pattern_type=%s,\n' % (self.pattern_type,))
        if self.has_changed is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            showIndent(outfile, level)
            outfile.write('has_changed=%s,\n' % (self.has_changed,))
        if self.trend is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            showIndent(outfile, level)
            outfile.write('trend=%s,\n' % (self.trend,))
        if self.apply_condition is not None and 'apply_condition' not in already_processed:
            already_processed.add('apply_condition')
            showIndent(outfile, level)
            outfile.write('apply_condition=%s,\n' % (self.apply_condition,))
        if self.bit_mask is not None and 'bit_mask' not in already_processed:
            already_processed.add('bit_mask')
            showIndent(outfile, level)
            outfile.write('bit_mask="%s",\n' % (self.bit_mask,))
        if self.regex_syntax is not None and 'regex_syntax' not in already_processed:
            already_processed.add('regex_syntax')
            showIndent(outfile, level)
            outfile.write('regex_syntax="%s",\n' % (self.regex_syntax,))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            showIndent(outfile, level)
            outfile.write('condition=%s,\n' % (self.condition,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pattern_type', node)
        if value is not None and 'pattern_type' not in already_processed:
            already_processed.add('pattern_type')
            self.pattern_type = value
        value = find_attr_value_('has_changed', node)
        if value is not None and 'has_changed' not in already_processed:
            already_processed.add('has_changed')
            if value in ('true', '1'):
                self.has_changed = True
            elif value in ('false', '0'):
                self.has_changed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('trend', node)
        if value is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            if value in ('true', '1'):
                self.trend = True
            elif value in ('false', '0'):
                self.trend = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('apply_condition', node)
        if value is not None and 'apply_condition' not in already_processed:
            already_processed.add('apply_condition')
            self.apply_condition = value
        value = find_attr_value_('bit_mask', node)
        if value is not None and 'bit_mask' not in already_processed:
            already_processed.add('bit_mask')
            self.bit_mask = value
        value = find_attr_value_('regex_syntax', node)
        if value is not None and 'regex_syntax' not in already_processed:
            already_processed.add('regex_syntax')
            self.regex_syntax = value
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            self.condition = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PatternableFieldType


class ControlledVocabularyStringType(PatternableFieldType):
    """The ControlledVocabularyStringType is used as the basis for defining
    controlled vocabularies.The vocab_name field specifies the name
    of the controlled vocabulary.The vocab_reference field specifies
    the URI to the location of where the controlled vocabulary is
    defined, e.g., in an externally located XML schema file."""
    subclass = None
    superclass = PatternableFieldType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None, extensiontype_=None):
        super(ControlledVocabularyStringType, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, valueOf_, extensiontype_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ControlledVocabularyStringType.subclass:
            return ControlledVocabularyStringType.subclass(*args_, **kwargs_)
        else:
            return ControlledVocabularyStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ControlledVocabularyStringType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ControlledVocabularyStringType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ControlledVocabularyStringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ControlledVocabularyStringType'):
        super(ControlledVocabularyStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ControlledVocabularyStringType')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ControlledVocabularyStringType', fromsubclass_=False, pretty_print=True):
        super(ControlledVocabularyStringType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ControlledVocabularyStringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ControlledVocabularyStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ControlledVocabularyStringType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ControlledVocabularyStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ControlledVocabularyStringType


class SIDType(BaseObjectPropertyType):
    """SIDType specifies Windows Security ID (SID) types via a union of the
    SIDTypeEnum type and the atomic xs:string type. Its base type is
    the CybOX Core BaseObjectPropertyType, for permitting complex
    (i.e. regular-expression based) specifications.Properties that
    use this type can express multiple values by providing them
    using a comma separated list. As such, a comma is a reserved
    character in all uses of this type. Commas in values should be
    expressed as &comma; (that is, ampersand-"comma"-semicolon).
    Such expressions should be converted back to a comma before
    displaying to users or handing off values to tools for
    processing. Note that whitespace is preserved and so, when
    specifying a list of values, do not include a space following a
    comma in a list unless the first character of the next list item
    should, in fact, be a space.This attribute is optional and
    specifies the expected type for the value of the specified
    property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(SIDType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SIDType.subclass:
            return SIDType.subclass(*args_, **kwargs_)
        else:
            return SIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(SIDType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='SIDType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='SIDType'):
        super(SIDType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SIDType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='SIDType', fromsubclass_=False, pretty_print=True):
        super(SIDType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SIDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(SIDType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SIDType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(SIDType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SIDType


class CodeObjectType(ObjectPropertiesType):
    """The CodeObjectType type is intended to characterize a body of
    computer code."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, Description=None, Type=None, Purpose=None, Code_Language=None, Targeted_Platforms=None, Processor_Family=None, Discovery_Method=None, Start_Address=None, Code_Segment=None, Code_Segment_XOR=None, Digital_Signatures=None, Extracted_Features=None):
        super(CodeObjectType, self).__init__(object_reference, Custom_Properties, )
        self.Description = Description
        self.Type = Type
        self.Purpose = Purpose
        self.Code_Language = Code_Language
        self.Targeted_Platforms = Targeted_Platforms
        self.Processor_Family = Processor_Family
        self.Discovery_Method = Discovery_Method
        self.Start_Address = Start_Address
        self.Code_Segment = Code_Segment
        self.Code_Segment_XOR = Code_Segment_XOR
        self.Digital_Signatures = Digital_Signatures
        self.Extracted_Features = Extracted_Features
    def factory(*args_, **kwargs_):
        if CodeObjectType.subclass:
            return CodeObjectType.subclass(*args_, **kwargs_)
        else:
            return CodeObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def get_Code_Language(self): return self.Code_Language
    def set_Code_Language(self, Code_Language): self.Code_Language = Code_Language
    def get_Targeted_Platforms(self): return self.Targeted_Platforms
    def set_Targeted_Platforms(self, Targeted_Platforms): self.Targeted_Platforms = Targeted_Platforms
    def get_Processor_Family(self): return self.Processor_Family
    def set_Processor_Family(self, Processor_Family): self.Processor_Family = Processor_Family
    def get_Discovery_Method(self): return self.Discovery_Method
    def set_Discovery_Method(self, Discovery_Method): self.Discovery_Method = Discovery_Method
    def get_Start_Address(self): return self.Start_Address
    def set_Start_Address(self, Start_Address): self.Start_Address = Start_Address
    def get_Code_Segment(self): return self.Code_Segment
    def set_Code_Segment(self, Code_Segment): self.Code_Segment = Code_Segment
    def get_Code_Segment_XOR(self): return self.Code_Segment_XOR
    def set_Code_Segment_XOR(self, Code_Segment_XOR): self.Code_Segment_XOR = Code_Segment_XOR
    def get_Digital_Signatures(self): return self.Digital_Signatures
    def set_Digital_Signatures(self, Digital_Signatures): self.Digital_Signatures = Digital_Signatures
    def get_Extracted_Features(self): return self.Extracted_Features
    def set_Extracted_Features(self, Extracted_Features): self.Extracted_Features = Extracted_Features
    def validate_CodeTypeType(self, value):
        # Validate type CodeTypeType, a restriction on None.
        pass
    def validate_CodePurposeType(self, value):
        # Validate type CodePurposeType, a restriction on None.
        pass
    def validate_CodeLanguageType(self, value):
        # Validate type CodeLanguageType, a restriction on None.
        pass
    def validate_ProcessorTypeType(self, value):
        # Validate type ProcessorTypeType, a restriction on None.
        pass
    def validate_HexBinaryObjectPropertyType(self, value):
        # Validate type HexBinaryObjectPropertyType, a restriction on None.
        pass
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Type is not None or
            self.Purpose is not None or
            self.Code_Language is not None or
            self.Targeted_Platforms is not None or
            self.Processor_Family is not None or
            self.Discovery_Method is not None or
            self.Start_Address is not None or
            self.Code_Segment is not None or
            self.Code_Segment_XOR is not None or
            self.Digital_Signatures is not None or
            self.Extracted_Features is not None or
            super(CodeObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CodeObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:CodeObj="http://cybox.mitre.org/objects#CodeObject-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CodeObjectType'):
        super(CodeObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CodeObjectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CodeObjectType', fromsubclass_=False, pretty_print=True):
        super(CodeObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Purpose is not None:
            self.Purpose.export(outfile, level, namespace_, name_='Purpose', pretty_print=pretty_print)
        if self.Code_Language is not None:
            self.Code_Language.export(outfile, level, namespace_, name_='Code_Language', pretty_print=pretty_print)
        if self.Targeted_Platforms is not None:
            self.Targeted_Platforms.export(outfile, level, namespace_, name_='Targeted_Platforms', pretty_print=pretty_print)
        if self.Processor_Family is not None:
            self.Processor_Family.export(outfile, level, namespace_, name_='Processor_Family', pretty_print=pretty_print)
        if self.Discovery_Method is not None:
            self.Discovery_Method.export(outfile, level, namespace_, name_='Discovery_Method', pretty_print=pretty_print)
        if self.Start_Address is not None:
            self.Start_Address.export(outfile, level, namespace_, name_='Start_Address', pretty_print=pretty_print)
        if self.Code_Segment is not None:
            self.Code_Segment.export(outfile, level, namespace_, name_='Code_Segment', pretty_print=pretty_print)
        if self.Code_Segment_XOR is not None:
            self.Code_Segment_XOR.export(outfile, level, namespace_, name_='Code_Segment_XOR', pretty_print=pretty_print)
        if self.Digital_Signatures is not None:
            self.Digital_Signatures.export(outfile, level, namespace_, name_='Digital_Signatures', pretty_print=pretty_print)
        if self.Extracted_Features is not None:
            self.Extracted_Features.export(outfile, level, namespace_, name_='Extracted_Features', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CodeObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CodeObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CodeObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=model_.CodeTypeType(\n')
            self.Type.exportLiteral(outfile, level, name_='Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Purpose is not None:
            showIndent(outfile, level)
            outfile.write('Purpose=model_.CodePurposeType(\n')
            self.Purpose.exportLiteral(outfile, level, name_='Purpose')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Code_Language is not None:
            showIndent(outfile, level)
            outfile.write('Code_Language=model_.CodeLanguageType(\n')
            self.Code_Language.exportLiteral(outfile, level, name_='Code_Language')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targeted_Platforms is not None:
            showIndent(outfile, level)
            outfile.write('Targeted_Platforms=model_.TargetedPlatformsType(\n')
            self.Targeted_Platforms.exportLiteral(outfile, level, name_='Targeted_Platforms')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Processor_Family is not None:
            showIndent(outfile, level)
            outfile.write('Processor_Family=model_.ProcessorTypeType(\n')
            self.Processor_Family.exportLiteral(outfile, level, name_='Processor_Family')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discovery_Method is not None:
            showIndent(outfile, level)
            outfile.write('Discovery_Method=model_.MeasureSourceType(\n')
            self.Discovery_Method.exportLiteral(outfile, level, name_='Discovery_Method')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Start_Address is not None:
            showIndent(outfile, level)
            outfile.write('Start_Address=model_.HexBinaryObjectPropertyType(\n')
            self.Start_Address.exportLiteral(outfile, level, name_='Start_Address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Code_Segment is not None:
            showIndent(outfile, level)
            outfile.write('Code_Segment=model_.StringObjectPropertyType(\n')
            self.Code_Segment.exportLiteral(outfile, level, name_='Code_Segment')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Code_Segment_XOR is not None:
            showIndent(outfile, level)
            outfile.write('Code_Segment_XOR=model_.CodeSegmentXORType(\n')
            self.Code_Segment_XOR.exportLiteral(outfile, level, name_='Code_Segment_XOR')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Digital_Signatures is not None:
            showIndent(outfile, level)
            outfile.write('Digital_Signatures=model_.DigitalSignaturesType(\n')
            self.Digital_Signatures.exportLiteral(outfile, level, name_='Digital_Signatures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extracted_Features is not None:
            showIndent(outfile, level)
            outfile.write('Extracted_Features=model_.ExtractedFeaturesType(\n')
            self.Extracted_Features.exportLiteral(outfile, level, name_='Extracted_Features')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CodeObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Type':
            obj_ = None
            self.Type = obj_
            self.validate_CodeTypeType(self.Type)    # validate type CodeTypeType
        elif nodeName_ == 'Purpose':
            obj_ = None
            self.Purpose = obj_
            self.validate_CodePurposeType(self.Purpose)    # validate type CodePurposeType
        elif nodeName_ == 'Code_Language':
            obj_ = None
            self.Code_Language = obj_
            self.validate_CodeLanguageType(self.Code_Language)    # validate type CodeLanguageType
        elif nodeName_ == 'Targeted_Platforms':
            obj_ = TargetedPlatformsType.factory()
            obj_.build(child_)
            self.Targeted_Platforms = obj_
        elif nodeName_ == 'Processor_Family':
            obj_ = None
            self.Processor_Family = obj_
            self.validate_ProcessorTypeType(self.Processor_Family)    # validate type ProcessorTypeType
        elif nodeName_ == 'Discovery_Method':
            obj_ = MeasureSourceType.factory()
            obj_.build(child_)
            self.Discovery_Method = obj_
        elif nodeName_ == 'Start_Address':
            obj_ = None
            self.Start_Address = obj_
            self.validate_HexBinaryObjectPropertyType(self.Start_Address)    # validate type HexBinaryObjectPropertyType
        elif nodeName_ == 'Code_Segment':
            obj_ = None
            self.Code_Segment = obj_
            self.validate_StringObjectPropertyType(self.Code_Segment)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Code_Segment_XOR':
            obj_ = CodeSegmentXORType.factory()
            obj_.build(child_)
            self.Code_Segment_XOR = obj_
        elif nodeName_ == 'Digital_Signatures':
            obj_ = DigitalSignaturesType.factory()
            obj_.build(child_)
            self.Digital_Signatures = obj_
        elif nodeName_ == 'Extracted_Features':
            obj_ = ExtractedFeaturesType.factory()
            obj_.build(child_)
            self.Extracted_Features = obj_
        super(CodeObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class CodeObjectType


class CodeTypeType(BaseObjectPropertyType):
    """CodeTypeType specifies types of code, via a union of the
    CodeTypeEnum type and the atomic xs:string type. Its base type
    is the CybOX Core BaseObjectPropertyType, for permitting complex
    (i.e. regular-expression based) specifications.This field is
    optional and specifies the expected type for the value of the
    specified field."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(CodeTypeType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CodeTypeType.subclass:
            return CodeTypeType.subclass(*args_, **kwargs_)
        else:
            return CodeTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CodeTypeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CodeTypeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CodeTypeType'):
        super(CodeTypeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CodeTypeType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CodeTypeType', fromsubclass_=False, pretty_print=True):
        super(CodeTypeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CodeTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(CodeTypeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CodeTypeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(CodeTypeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeTypeType


class CodeSegmentXORType(StringObjectPropertyType):
    """Used to encapsulate a segment of code that has been XORed with a
    pattern in order to avoid tripping anti-virus detection.The
    xor_pattern field contains a 16-hexadecimal-character hex
    string, which represents the pattern that the Code_Segment_XOR
    field should be XORed with in order to recover the actual code.
    The default value is 55AA55AA55AA55BB, as specified by IETF RFC
    5901."""
    subclass = None
    superclass = StringObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, xor_pattern='55AA55AA55AA55BB', valueOf_=None):
        super(CodeSegmentXORType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.xor_pattern = _cast(None, xor_pattern)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CodeSegmentXORType.subclass:
            return CodeSegmentXORType.subclass(*args_, **kwargs_)
        else:
            return CodeSegmentXORType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xor_pattern(self): return self.xor_pattern
    def set_xor_pattern(self, xor_pattern): self.xor_pattern = xor_pattern
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CodeSegmentXORType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CodeSegmentXORType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeSegmentXORType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CodeSegmentXORType'):
        super(CodeSegmentXORType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CodeSegmentXORType')
        if self.xor_pattern is not None and 'xor_pattern' not in already_processed:
            already_processed.add('xor_pattern')
            outfile.write(' xor_pattern=%s' % (self.gds_format_string(quote_attrib(self.xor_pattern).encode(ExternalEncoding), input_name='xor_pattern'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CodeSegmentXORType', fromsubclass_=False, pretty_print=True):
        super(CodeSegmentXORType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CodeSegmentXORType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.xor_pattern is not None and 'xor_pattern' not in already_processed:
            already_processed.add('xor_pattern')
            showIndent(outfile, level)
            outfile.write('xor_pattern="%s",\n' % (self.xor_pattern,))
        super(CodeSegmentXORType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CodeSegmentXORType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xor_pattern', node)
        if value is not None and 'xor_pattern' not in already_processed:
            already_processed.add('xor_pattern')
            self.xor_pattern = value
        super(CodeSegmentXORType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeSegmentXORType


class CodePurposeType(BaseObjectPropertyType):
    """CodePurposeType specifies intended purposes of code, via a union of
    the CodePurposeEnum type and the atomic xs:string type. Its base
    type is the CybOX Core BaseObjectPropertyType, for permitting
    complex (i.e. regular-expression based) specifications.This
    field is optional and specifies the expected type for the value
    of the specified field."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(CodePurposeType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CodePurposeType.subclass:
            return CodePurposeType.subclass(*args_, **kwargs_)
        else:
            return CodePurposeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CodePurposeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CodePurposeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodePurposeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CodePurposeType'):
        super(CodePurposeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CodePurposeType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CodePurposeType', fromsubclass_=False, pretty_print=True):
        super(CodePurposeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CodePurposeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(CodePurposeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CodePurposeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(CodePurposeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodePurposeType


class CodeLanguageType(BaseObjectPropertyType):
    """CodeLanguageType specifies languages of code, via a union of the
    CodeLanguageEnum type and the atomic xs:string type. Its base
    type is the CybOX Core BaseObjectPropertyType, for permitting
    complex (i.e. regular-expression based) specifications.This
    field is optional and specifies the expected type for the value
    of the specified field."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(CodeLanguageType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CodeLanguageType.subclass:
            return CodeLanguageType.subclass(*args_, **kwargs_)
        else:
            return CodeLanguageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CodeLanguageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CodeLanguageType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeLanguageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CodeLanguageType'):
        super(CodeLanguageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CodeLanguageType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CodeLanguageType', fromsubclass_=False, pretty_print=True):
        super(CodeLanguageType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CodeLanguageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(CodeLanguageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CodeLanguageType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(CodeLanguageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeLanguageType


class ProcessorTypeType(BaseObjectPropertyType):
    """ProcessorTypeType specifies relevant processor families, via a union
    of the ProcessorTypeEnum type and the atomic xs:string type. Its
    base type is the CybOX Core BaseObjectPropertyType, for
    permitting complex (i.e. regular-expression based)
    specifications.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(ProcessorTypeType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ProcessorTypeType.subclass:
            return ProcessorTypeType.subclass(*args_, **kwargs_)
        else:
            return ProcessorTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ProcessorTypeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ProcessorTypeType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessorTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ProcessorTypeType'):
        super(ProcessorTypeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessorTypeType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ProcessorTypeType', fromsubclass_=False, pretty_print=True):
        super(ProcessorTypeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ProcessorTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(ProcessorTypeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProcessorTypeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(ProcessorTypeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProcessorTypeType


class TargetedPlatformsType(GeneratedsSuper):
    """A list of targeted platforms"""
    subclass = None
    superclass = None
    def __init__(self, Targeted_Platform=None):
        if Targeted_Platform is None:
            self.Targeted_Platform = []
        else:
            self.Targeted_Platform = Targeted_Platform
    def factory(*args_, **kwargs_):
        if TargetedPlatformsType.subclass:
            return TargetedPlatformsType.subclass(*args_, **kwargs_)
        else:
            return TargetedPlatformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Targeted_Platform(self): return self.Targeted_Platform
    def set_Targeted_Platform(self, Targeted_Platform): self.Targeted_Platform = Targeted_Platform
    def add_Targeted_Platform(self, value): self.Targeted_Platform.append(value)
    def insert_Targeted_Platform(self, index, value): self.Targeted_Platform[index] = value
    def hasContent_(self):
        if (
            self.Targeted_Platform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='TargetedPlatformsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetedPlatformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='TargetedPlatformsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='TargetedPlatformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Targeted_Platform_ in self.Targeted_Platform:
            Targeted_Platform_.export(outfile, level, namespace_, name_='Targeted_Platform', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TargetedPlatformsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Targeted_Platform=[\n')
        level += 1
        for Targeted_Platform_ in self.Targeted_Platform:
            showIndent(outfile, level)
            outfile.write('model_.PlatformSpecificationType(\n')
            Targeted_Platform_.exportLiteral(outfile, level, name_='PlatformSpecificationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Targeted_Platform':
            obj_ = PlatformSpecificationType.factory()
            obj_.build(child_)
            self.Targeted_Platform.append(obj_)
# end class TargetedPlatformsType


class ProcessObjectType(ObjectPropertiesType):
    """The ProcessObjectType type is intended to characterize system
    processes.The is_hidden field specifies whether the process is
    hidden or not."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, is_hidden=None, PID=None, Name=None, Creation_Time=None, Parent_PID=None, Child_PID_List=None, Image_Info=None, Argument_List=None, Environment_Variable_List=None, Kernel_Time=None, Port_List=None, Network_Connection_List=None, Start_Time=None, Status=None, Username=None, User_Time=None, Extracted_Features=None, extensiontype_=None):
        super(ProcessObjectType, self).__init__(object_reference, Custom_Properties, extensiontype_, )
        self.is_hidden = _cast(bool, is_hidden)
        self.PID = PID
        self.Name = Name
        self.Creation_Time = Creation_Time
        self.Parent_PID = Parent_PID
        self.Child_PID_List = Child_PID_List
        self.Image_Info = Image_Info
        self.Argument_List = Argument_List
        self.Environment_Variable_List = Environment_Variable_List
        self.Kernel_Time = Kernel_Time
        self.Port_List = Port_List
        self.Network_Connection_List = Network_Connection_List
        self.Start_Time = Start_Time
        self.Status = Status
        self.Username = Username
        self.User_Time = User_Time
        self.Extracted_Features = Extracted_Features
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ProcessObjectType.subclass:
            return ProcessObjectType.subclass(*args_, **kwargs_)
        else:
            return ProcessObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PID(self): return self.PID
    def set_PID(self, PID): self.PID = PID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Creation_Time(self): return self.Creation_Time
    def set_Creation_Time(self, Creation_Time): self.Creation_Time = Creation_Time
    def get_Parent_PID(self): return self.Parent_PID
    def set_Parent_PID(self, Parent_PID): self.Parent_PID = Parent_PID
    def get_Child_PID_List(self): return self.Child_PID_List
    def set_Child_PID_List(self, Child_PID_List): self.Child_PID_List = Child_PID_List
    def get_Image_Info(self): return self.Image_Info
    def set_Image_Info(self, Image_Info): self.Image_Info = Image_Info
    def get_Argument_List(self): return self.Argument_List
    def set_Argument_List(self, Argument_List): self.Argument_List = Argument_List
    def get_Environment_Variable_List(self): return self.Environment_Variable_List
    def set_Environment_Variable_List(self, Environment_Variable_List): self.Environment_Variable_List = Environment_Variable_List
    def get_Kernel_Time(self): return self.Kernel_Time
    def set_Kernel_Time(self, Kernel_Time): self.Kernel_Time = Kernel_Time
    def get_Port_List(self): return self.Port_List
    def set_Port_List(self, Port_List): self.Port_List = Port_List
    def get_Network_Connection_List(self): return self.Network_Connection_List
    def set_Network_Connection_List(self, Network_Connection_List): self.Network_Connection_List = Network_Connection_List
    def get_Start_Time(self): return self.Start_Time
    def set_Start_Time(self, Start_Time): self.Start_Time = Start_Time
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Username(self): return self.Username
    def set_Username(self, Username): self.Username = Username
    def get_User_Time(self): return self.User_Time
    def set_User_Time(self, User_Time): self.User_Time = User_Time
    def get_Extracted_Features(self): return self.Extracted_Features
    def set_Extracted_Features(self, Extracted_Features): self.Extracted_Features = Extracted_Features
    def get_is_hidden(self): return self.is_hidden
    def set_is_hidden(self, is_hidden): self.is_hidden = is_hidden
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_UnsignedIntegerObjectPropertyType(self, value):
        # Validate type UnsignedIntegerObjectPropertyType, a restriction on None.
        pass
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def validate_DateTimeObjectPropertyType(self, value):
        # Validate type DateTimeObjectPropertyType, a restriction on None.
        pass
    def validate_DurationObjectPropertyType(self, value):
        # Validate type DurationObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.PID is not None or
            self.Name is not None or
            self.Creation_Time is not None or
            self.Parent_PID is not None or
            self.Child_PID_List is not None or
            self.Image_Info is not None or
            self.Argument_List is not None or
            self.Environment_Variable_List is not None or
            self.Kernel_Time is not None or
            self.Port_List is not None or
            self.Network_Connection_List is not None or
            self.Start_Time is not None or
            self.Status is not None or
            self.Username is not None or
            self.User_Time is not None or
            self.Extracted_Features is not None or
            super(ProcessObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ProcessObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:ProcessObj="http://cybox.mitre.org/objects#ProcessObject-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ProcessObjectType'):
        super(ProcessObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessObjectType')
        if self.is_hidden is not None and 'is_hidden' not in already_processed:
            already_processed.add('is_hidden')
            outfile.write(' is_hidden="%s"' % self.gds_format_boolean(self.is_hidden, input_name='is_hidden'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ProcessObjectType', fromsubclass_=False, pretty_print=True):
        super(ProcessObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PID is not None:
            self.PID.export(outfile, level, namespace_, name_='PID', pretty_print=pretty_print)
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.Creation_Time is not None:
            self.Creation_Time.export(outfile, level, namespace_, name_='Creation_Time', pretty_print=pretty_print)
        if self.Parent_PID is not None:
            self.Parent_PID.export(outfile, level, namespace_, name_='Parent_PID', pretty_print=pretty_print)
        if self.Child_PID_List is not None:
            self.Child_PID_List.export(outfile, level, namespace_, name_='Child_PID_List', pretty_print=pretty_print)
        if self.Image_Info is not None:
            self.Image_Info.export(outfile, level, namespace_, name_='Image_Info', pretty_print=pretty_print)
        if self.Argument_List is not None:
            self.Argument_List.export(outfile, level, namespace_, name_='Argument_List', pretty_print=pretty_print)
        if self.Environment_Variable_List is not None:
            self.Environment_Variable_List.export(outfile, level, namespace_, name_='Environment_Variable_List', pretty_print=pretty_print)
        if self.Kernel_Time is not None:
            self.Kernel_Time.export(outfile, level, namespace_, name_='Kernel_Time', pretty_print=pretty_print)
        if self.Port_List is not None:
            self.Port_List.export(outfile, level, namespace_, name_='Port_List', pretty_print=pretty_print)
        if self.Network_Connection_List is not None:
            self.Network_Connection_List.export(outfile, level, namespace_, name_='Network_Connection_List', pretty_print=pretty_print)
        if self.Start_Time is not None:
            self.Start_Time.export(outfile, level, namespace_, name_='Start_Time', pretty_print=pretty_print)
        if self.Status is not None:
            self.Status.export(outfile, level, namespace_, name_='Status', pretty_print=pretty_print)
        if self.Username is not None:
            self.Username.export(outfile, level, namespace_, name_='Username', pretty_print=pretty_print)
        if self.User_Time is not None:
            self.User_Time.export(outfile, level, namespace_, name_='User_Time', pretty_print=pretty_print)
        if self.Extracted_Features is not None:
            self.Extracted_Features.export(outfile, level, namespace_, name_='Extracted_Features', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.is_hidden is not None and 'is_hidden' not in already_processed:
            already_processed.add('is_hidden')
            showIndent(outfile, level)
            outfile.write('is_hidden=%s,\n' % (self.is_hidden,))
        super(ProcessObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProcessObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.PID is not None:
            showIndent(outfile, level)
            outfile.write('PID=model_.UnsignedIntegerObjectPropertyType(\n')
            self.PID.exportLiteral(outfile, level, name_='PID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.StringObjectPropertyType(\n')
            self.Name.exportLiteral(outfile, level, name_='Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Creation_Time is not None:
            showIndent(outfile, level)
            outfile.write('Creation_Time=model_.DateTimeObjectPropertyType(\n')
            self.Creation_Time.exportLiteral(outfile, level, name_='Creation_Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Parent_PID is not None:
            showIndent(outfile, level)
            outfile.write('Parent_PID=model_.UnsignedIntegerObjectPropertyType(\n')
            self.Parent_PID.exportLiteral(outfile, level, name_='Parent_PID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Child_PID_List is not None:
            showIndent(outfile, level)
            outfile.write('Child_PID_List=model_.ChildPIDListType(\n')
            self.Child_PID_List.exportLiteral(outfile, level, name_='Child_PID_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Image_Info is not None:
            showIndent(outfile, level)
            outfile.write('Image_Info=model_.ImageInfoType(\n')
            self.Image_Info.exportLiteral(outfile, level, name_='Image_Info')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Argument_List is not None:
            showIndent(outfile, level)
            outfile.write('Argument_List=model_.ArgumentListType(\n')
            self.Argument_List.exportLiteral(outfile, level, name_='Argument_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Environment_Variable_List is not None:
            showIndent(outfile, level)
            outfile.write('Environment_Variable_List=model_.EnvironmentVariableListType(\n')
            self.Environment_Variable_List.exportLiteral(outfile, level, name_='Environment_Variable_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Kernel_Time is not None:
            showIndent(outfile, level)
            outfile.write('Kernel_Time=model_.DurationObjectPropertyType(\n')
            self.Kernel_Time.exportLiteral(outfile, level, name_='Kernel_Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Port_List is not None:
            showIndent(outfile, level)
            outfile.write('Port_List=model_.PortListType(\n')
            self.Port_List.exportLiteral(outfile, level, name_='Port_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Network_Connection_List is not None:
            showIndent(outfile, level)
            outfile.write('Network_Connection_List=model_.NetworkConnectionListType(\n')
            self.Network_Connection_List.exportLiteral(outfile, level, name_='Network_Connection_List')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Start_Time is not None:
            showIndent(outfile, level)
            outfile.write('Start_Time=model_.DateTimeObjectPropertyType(\n')
            self.Start_Time.exportLiteral(outfile, level, name_='Start_Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProcessStatusType is not None:
            showIndent(outfile, level)
            outfile.write('ProcessStatusType=model_.ProcessStatusType(\n')
            self.ProcessStatusType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Username is not None:
            showIndent(outfile, level)
            outfile.write('Username=model_.StringObjectPropertyType(\n')
            self.Username.exportLiteral(outfile, level, name_='Username')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.User_Time is not None:
            showIndent(outfile, level)
            outfile.write('User_Time=model_.DurationObjectPropertyType(\n')
            self.User_Time.exportLiteral(outfile, level, name_='User_Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Extracted_Features is not None:
            showIndent(outfile, level)
            outfile.write('Extracted_Features=model_.ExtractedFeaturesType(\n')
            self.Extracted_Features.exportLiteral(outfile, level, name_='Extracted_Features')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('is_hidden', node)
        if value is not None and 'is_hidden' not in already_processed:
            already_processed.add('is_hidden')
            if value in ('true', '1'):
                self.is_hidden = True
            elif value in ('false', '0'):
                self.is_hidden = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ProcessObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PID':
            obj_ = None
            self.PID = obj_
            self.validate_UnsignedIntegerObjectPropertyType(self.PID)    # validate type UnsignedIntegerObjectPropertyType
        elif nodeName_ == 'Name':
            obj_ = None
            self.Name = obj_
            self.validate_StringObjectPropertyType(self.Name)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Creation_Time':
            obj_ = None
            self.Creation_Time = obj_
            self.validate_DateTimeObjectPropertyType(self.Creation_Time)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'Parent_PID':
            obj_ = None
            self.Parent_PID = obj_
            self.validate_UnsignedIntegerObjectPropertyType(self.Parent_PID)    # validate type UnsignedIntegerObjectPropertyType
        elif nodeName_ == 'Child_PID_List':
            obj_ = ChildPIDListType.factory()
            obj_.build(child_)
            self.Child_PID_List = obj_
        elif nodeName_ == 'Image_Info':
            obj_ = ImageInfoType.factory()
            obj_.build(child_)
            self.Image_Info = obj_
        elif nodeName_ == 'Argument_List':
            obj_ = ArgumentListType.factory()
            obj_.build(child_)
            self.Argument_List = obj_
        elif nodeName_ == 'Environment_Variable_List':
            obj_ = EnvironmentVariableListType.factory()
            obj_.build(child_)
            self.Environment_Variable_List = obj_
        elif nodeName_ == 'Kernel_Time':
            obj_ = None
            self.Kernel_Time = obj_
            self.validate_DurationObjectPropertyType(self.Kernel_Time)    # validate type DurationObjectPropertyType
        elif nodeName_ == 'Port_List':
            obj_ = PortListType.factory()
            obj_.build(child_)
            self.Port_List = obj_
        elif nodeName_ == 'Network_Connection_List':
            obj_ = NetworkConnectionListType.factory()
            obj_.build(child_)
            self.Network_Connection_List = obj_
        elif nodeName_ == 'Start_Time':
            obj_ = None
            self.Start_Time = obj_
            self.validate_DateTimeObjectPropertyType(self.Start_Time)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'Status':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Status> element')
            self.Status = obj_
        elif nodeName_ == 'Username':
            obj_ = None
            self.Username = obj_
            self.validate_StringObjectPropertyType(self.Username)    # validate type StringObjectPropertyType
        elif nodeName_ == 'User_Time':
            obj_ = None
            self.User_Time = obj_
            self.validate_DurationObjectPropertyType(self.User_Time)    # validate type DurationObjectPropertyType
        elif nodeName_ == 'Extracted_Features':
            obj_ = ExtractedFeaturesType.factory()
            obj_.build(child_)
            self.Extracted_Features = obj_
        super(ProcessObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class ProcessObjectType


class NetworkConnectionListType(GeneratedsSuper):
    """The NetworkConnectionListType type is a list of network connections."""
    subclass = None
    superclass = None
    def __init__(self, Network_Connection=None):
        if Network_Connection is None:
            self.Network_Connection = []
        else:
            self.Network_Connection = Network_Connection
    def factory(*args_, **kwargs_):
        if NetworkConnectionListType.subclass:
            return NetworkConnectionListType.subclass(*args_, **kwargs_)
        else:
            return NetworkConnectionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Network_Connection(self): return self.Network_Connection
    def set_Network_Connection(self, Network_Connection): self.Network_Connection = Network_Connection
    def add_Network_Connection(self, value): self.Network_Connection.append(value)
    def insert_Network_Connection(self, index, value): self.Network_Connection[index] = value
    def hasContent_(self):
        if (
            self.Network_Connection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='NetworkConnectionListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='NetworkConnectionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='NetworkConnectionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Network_Connection_ in self.Network_Connection:
            Network_Connection_.export(outfile, level, namespace_, name_='Network_Connection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkConnectionListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Network_Connection=[\n')
        level += 1
        for Network_Connection_ in self.Network_Connection:
            showIndent(outfile, level)
            outfile.write('model_.NetworkConnectionObjectType(\n')
            Network_Connection_.exportLiteral(outfile, level, name_='NetworkConnectionObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Network_Connection':
            obj_ = NetworkConnectionObjectType.factory()
            obj_.build(child_)
            self.Network_Connection.append(obj_)
# end class NetworkConnectionListType


class ImageInfoType(GeneratedsSuper):
    """The ImageInfoType type captures information about the process image."""
    subclass = None
    superclass = None
    def __init__(self, File_Name=None, Command_Line=None, Current_Directory=None, Path=None):
        self.File_Name = File_Name
        self.Command_Line = Command_Line
        self.Current_Directory = Current_Directory
        self.Path = Path
    def factory(*args_, **kwargs_):
        if ImageInfoType.subclass:
            return ImageInfoType.subclass(*args_, **kwargs_)
        else:
            return ImageInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File_Name(self): return self.File_Name
    def set_File_Name(self, File_Name): self.File_Name = File_Name
    def get_Command_Line(self): return self.Command_Line
    def set_Command_Line(self, Command_Line): self.Command_Line = Command_Line
    def get_Current_Directory(self): return self.Current_Directory
    def set_Current_Directory(self, Current_Directory): self.Current_Directory = Current_Directory
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.File_Name is not None or
            self.Command_Line is not None or
            self.Current_Directory is not None or
            self.Path is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ImageInfoType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ImageInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ImageInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.File_Name is not None:
            self.File_Name.export(outfile, level, namespace_, name_='File_Name', pretty_print=pretty_print)
        if self.Command_Line is not None:
            self.Command_Line.export(outfile, level, namespace_, name_='Command_Line', pretty_print=pretty_print)
        if self.Current_Directory is not None:
            self.Current_Directory.export(outfile, level, namespace_, name_='Current_Directory', pretty_print=pretty_print)
        if self.Path is not None:
            self.Path.export(outfile, level, namespace_, name_='Path', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ImageInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.File_Name is not None:
            showIndent(outfile, level)
            outfile.write('File_Name=model_.StringObjectPropertyType(\n')
            self.File_Name.exportLiteral(outfile, level, name_='File_Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Command_Line is not None:
            showIndent(outfile, level)
            outfile.write('Command_Line=model_.StringObjectPropertyType(\n')
            self.Command_Line.exportLiteral(outfile, level, name_='Command_Line')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Current_Directory is not None:
            showIndent(outfile, level)
            outfile.write('Current_Directory=model_.StringObjectPropertyType(\n')
            self.Current_Directory.exportLiteral(outfile, level, name_='Current_Directory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('Path=model_.StringObjectPropertyType(\n')
            self.Path.exportLiteral(outfile, level, name_='Path')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File_Name':
            obj_ = None
            self.File_Name = obj_
            self.validate_StringObjectPropertyType(self.File_Name)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Command_Line':
            obj_ = None
            self.Command_Line = obj_
            self.validate_StringObjectPropertyType(self.Command_Line)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Current_Directory':
            obj_ = None
            self.Current_Directory = obj_
            self.validate_StringObjectPropertyType(self.Current_Directory)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Path':
            obj_ = None
            self.Path = obj_
            self.validate_StringObjectPropertyType(self.Path)    # validate type StringObjectPropertyType
# end class ImageInfoType


class ProcessStatusType(GeneratedsSuper):
    """The ProcessStatusType is used for specifying the status of a running
    or terminated process. Since this property is platform-specific,
    it is created here as an abstract type and then used in the
    platform-specific process CybOX objects."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ProcessStatusType.subclass:
            return ProcessStatusType.subclass(*args_, **kwargs_)
        else:
            return ProcessStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ProcessStatusType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ProcessStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ProcessStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ProcessStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProcessStatusType


class ChildPIDListType(GeneratedsSuper):
    """The ChildPIDListType type captures the PID's of the children of the
    process in a list format."""
    subclass = None
    superclass = None
    def __init__(self, Child_PID=None):
        if Child_PID is None:
            self.Child_PID = []
        else:
            self.Child_PID = Child_PID
    def factory(*args_, **kwargs_):
        if ChildPIDListType.subclass:
            return ChildPIDListType.subclass(*args_, **kwargs_)
        else:
            return ChildPIDListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Child_PID(self): return self.Child_PID
    def set_Child_PID(self, Child_PID): self.Child_PID = Child_PID
    def add_Child_PID(self, value): self.Child_PID.append(value)
    def insert_Child_PID(self, index, value): self.Child_PID[index] = value
    def validate_UnsignedIntegerObjectPropertyType(self, value):
        # Validate type UnsignedIntegerObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Child_PID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ChildPIDListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChildPIDListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ChildPIDListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ChildPIDListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Child_PID_ in self.Child_PID:
            Child_PID_.export(outfile, level, namespace_, name_='Child_PID', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ChildPIDListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Child_PID=[\n')
        level += 1
        for Child_PID_ in self.Child_PID:
            showIndent(outfile, level)
            outfile.write('model_.UnsignedIntegerObjectPropertyType(\n')
            Child_PID_.exportLiteral(outfile, level, name_='UnsignedIntegerObjectPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Child_PID':
            obj_ = None
            self.Child_PID.append(obj_)
            self.validate_UnsignedIntegerObjectPropertyType(self.Child_PID)    # validate type UnsignedIntegerObjectPropertyType
# end class ChildPIDListType


class ArgumentListType(GeneratedsSuper):
    """The ArgumentListType is intended to specify a list of arguments
    utlized in intiating the process."""
    subclass = None
    superclass = None
    def __init__(self, Argument=None):
        if Argument is None:
            self.Argument = []
        else:
            self.Argument = Argument
    def factory(*args_, **kwargs_):
        if ArgumentListType.subclass:
            return ArgumentListType.subclass(*args_, **kwargs_)
        else:
            return ArgumentListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Argument(self): return self.Argument
    def set_Argument(self, Argument): self.Argument = Argument
    def add_Argument(self, value): self.Argument.append(value)
    def insert_Argument(self, index, value): self.Argument[index] = value
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Argument
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ArgumentListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArgumentListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ArgumentListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ArgumentListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Argument_ in self.Argument:
            Argument_.export(outfile, level, namespace_, name_='Argument', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ArgumentListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Argument=[\n')
        level += 1
        for Argument_ in self.Argument:
            showIndent(outfile, level)
            outfile.write('model_.StringObjectPropertyType(\n')
            Argument_.exportLiteral(outfile, level, name_='StringObjectPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Argument':
            obj_ = None
            self.Argument.append(obj_)
            self.validate_StringObjectPropertyType(self.Argument)    # validate type StringObjectPropertyType
# end class ArgumentListType


class PortListType(GeneratedsSuper):
    """The PortListType is intended to specify a list of network ports."""
    subclass = None
    superclass = None
    def __init__(self, Port=None):
        if Port is None:
            self.Port = []
        else:
            self.Port = Port
    def factory(*args_, **kwargs_):
        if PortListType.subclass:
            return PortListType.subclass(*args_, **kwargs_)
        else:
            return PortListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def add_Port(self, value): self.Port.append(value)
    def insert_Port(self, index, value): self.Port[index] = value
    def hasContent_(self):
        if (
            self.Port
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PortListType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PortListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PortListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Port_ in self.Port:
            Port_.export(outfile, level, namespace_, name_='Port', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PortListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Port=[\n')
        level += 1
        for Port_ in self.Port:
            showIndent(outfile, level)
            outfile.write('model_.PortObjectType(\n')
            Port_.exportLiteral(outfile, level, name_='PortObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Port':
            obj_ = PortObjectType.factory()
            obj_.build(child_)
            self.Port.append(obj_)
# end class PortListType


class PortObjectType(ObjectPropertiesType):
    """The PortObjectType type is intended to characterize networking
    ports."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, Port_Value=None, Layer4_Protocol=None):
        super(PortObjectType, self).__init__(object_reference, Custom_Properties, )
        self.Port_Value = Port_Value
        self.Layer4_Protocol = Layer4_Protocol
    def factory(*args_, **kwargs_):
        if PortObjectType.subclass:
            return PortObjectType.subclass(*args_, **kwargs_)
        else:
            return PortObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Port_Value(self): return self.Port_Value
    def set_Port_Value(self, Port_Value): self.Port_Value = Port_Value
    def get_Layer4_Protocol(self): return self.Layer4_Protocol
    def set_Layer4_Protocol(self, Layer4_Protocol): self.Layer4_Protocol = Layer4_Protocol
    def validate_PositiveIntegerObjectPropertyType(self, value):
        # Validate type PositiveIntegerObjectPropertyType, a restriction on None.
        pass
    def validate_Layer4ProtocolType(self, value):
        # Validate type Layer4ProtocolType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Port_Value is not None or
            self.Layer4_Protocol is not None or
            super(PortObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PortObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PortObjectType'):
        super(PortObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PortObjectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PortObjectType', fromsubclass_=False, pretty_print=True):
        super(PortObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Port_Value is not None:
            self.Port_Value.export(outfile, level, namespace_, name_='Port_Value', pretty_print=pretty_print)
        if self.Layer4_Protocol is not None:
            self.Layer4_Protocol.export(outfile, level, namespace_, name_='Layer4_Protocol', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PortObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PortObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PortObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Port_Value is not None:
            showIndent(outfile, level)
            outfile.write('Port_Value=model_.PositiveIntegerObjectPropertyType(\n')
            self.Port_Value.exportLiteral(outfile, level, name_='Port_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Layer4_Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Layer4_Protocol=model_.Layer4ProtocolType(\n')
            self.Layer4_Protocol.exportLiteral(outfile, level, name_='Layer4_Protocol')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PortObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Port_Value':
            obj_ = None
            self.Port_Value = obj_
            self.validate_PositiveIntegerObjectPropertyType(self.Port_Value)    # validate type PositiveIntegerObjectPropertyType
        elif nodeName_ == 'Layer4_Protocol':
            obj_ = None
            self.Layer4_Protocol = obj_
            self.validate_Layer4ProtocolType(self.Layer4_Protocol)    # validate type Layer4ProtocolType
        super(PortObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class PortObjectType


class Layer4ProtocolType(BaseObjectPropertyType):
    """Layer4ProtocolType specifies Layer 4 (OSI model) protocols, via a
    union of the Layer4ProtocolEnum type and the atomic xs:string
    type. Its base type is the CybOX Core BaseObjectPropertyType,
    for permitting complex (i.e. regular-expression based)
    specifications.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(Layer4ProtocolType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Layer4ProtocolType.subclass:
            return Layer4ProtocolType.subclass(*args_, **kwargs_)
        else:
            return Layer4ProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Layer4ProtocolType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='Layer4ProtocolType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Layer4ProtocolType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='Layer4ProtocolType'):
        super(Layer4ProtocolType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Layer4ProtocolType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='Layer4ProtocolType', fromsubclass_=False, pretty_print=True):
        super(Layer4ProtocolType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='Layer4ProtocolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(Layer4ProtocolType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Layer4ProtocolType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(Layer4ProtocolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Layer4ProtocolType


class NetworkConnectionObjectType(ObjectPropertiesType):
    """The NetworkConnectionObjectType is intended as a way of
    characterizing local or remote (i.e. Internet) network
    connections.The tls_used field specifies whether or not
    Transport Layer Security (TLS) is used in the network
    connection."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, tls_used=None, Creation_Time=None, Layer3_Protocol=None, Layer4_Protocol=None, Layer7_Protocol=None, Source_Socket_Address=None, Source_TCP_State=None, Destination_Socket_Address=None, Destination_TCP_State=None, Layer7_Connections=None):
        super(NetworkConnectionObjectType, self).__init__(object_reference, Custom_Properties, )
        self.tls_used = _cast(bool, tls_used)
        self.Creation_Time = Creation_Time
        self.Layer3_Protocol = Layer3_Protocol
        self.Layer4_Protocol = Layer4_Protocol
        self.Layer7_Protocol = Layer7_Protocol
        self.Source_Socket_Address = Source_Socket_Address
        self.Source_TCP_State = Source_TCP_State
        self.Destination_Socket_Address = Destination_Socket_Address
        self.Destination_TCP_State = Destination_TCP_State
        self.Layer7_Connections = Layer7_Connections
    def factory(*args_, **kwargs_):
        if NetworkConnectionObjectType.subclass:
            return NetworkConnectionObjectType.subclass(*args_, **kwargs_)
        else:
            return NetworkConnectionObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Creation_Time(self): return self.Creation_Time
    def set_Creation_Time(self, Creation_Time): self.Creation_Time = Creation_Time
    def get_Layer3_Protocol(self): return self.Layer3_Protocol
    def set_Layer3_Protocol(self, Layer3_Protocol): self.Layer3_Protocol = Layer3_Protocol
    def get_Layer4_Protocol(self): return self.Layer4_Protocol
    def set_Layer4_Protocol(self, Layer4_Protocol): self.Layer4_Protocol = Layer4_Protocol
    def get_Layer7_Protocol(self): return self.Layer7_Protocol
    def set_Layer7_Protocol(self, Layer7_Protocol): self.Layer7_Protocol = Layer7_Protocol
    def get_Source_Socket_Address(self): return self.Source_Socket_Address
    def set_Source_Socket_Address(self, Source_Socket_Address): self.Source_Socket_Address = Source_Socket_Address
    def get_Source_TCP_State(self): return self.Source_TCP_State
    def set_Source_TCP_State(self, Source_TCP_State): self.Source_TCP_State = Source_TCP_State
    def get_Destination_Socket_Address(self): return self.Destination_Socket_Address
    def set_Destination_Socket_Address(self, Destination_Socket_Address): self.Destination_Socket_Address = Destination_Socket_Address
    def get_Destination_TCP_State(self): return self.Destination_TCP_State
    def set_Destination_TCP_State(self, Destination_TCP_State): self.Destination_TCP_State = Destination_TCP_State
    def get_Layer7_Connections(self): return self.Layer7_Connections
    def set_Layer7_Connections(self, Layer7_Connections): self.Layer7_Connections = Layer7_Connections
    def get_tls_used(self): return self.tls_used
    def set_tls_used(self, tls_used): self.tls_used = tls_used
    def validate_DateTimeObjectPropertyType(self, value):
        # Validate type DateTimeObjectPropertyType, a restriction on None.
        pass
    def validate_Layer3ProtocolType(self, value):
        # Validate type Layer3ProtocolType, a restriction on None.
        pass
    def validate_Layer4ProtocolType(self, value):
        # Validate type Layer4ProtocolType, a restriction on None.
        pass
    def validate_Layer7ProtocolType(self, value):
        # Validate type Layer7ProtocolType, a restriction on None.
        pass
    def validate_TCPStateEnum(self, value):
        # Validate type TCPStateEnum, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Creation_Time is not None or
            self.Layer3_Protocol is not None or
            self.Layer4_Protocol is not None or
            self.Layer7_Protocol is not None or
            self.Source_Socket_Address is not None or
            self.Source_TCP_State is not None or
            self.Destination_Socket_Address is not None or
            self.Destination_TCP_State is not None or
            self.Layer7_Connections is not None or
            super(NetworkConnectionObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='NetworkConnectionObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='NetworkConnectionObjectType'):
        super(NetworkConnectionObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionObjectType')
        if self.tls_used is not None and 'tls_used' not in already_processed:
            already_processed.add('tls_used')
            outfile.write(' tls_used="%s"' % self.gds_format_boolean(self.tls_used, input_name='tls_used'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='NetworkConnectionObjectType', fromsubclass_=False, pretty_print=True):
        super(NetworkConnectionObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Creation_Time is not None:
            self.Creation_Time.export(outfile, level, namespace_, name_='Creation_Time', pretty_print=pretty_print)
        if self.Layer3_Protocol is not None:
            self.Layer3_Protocol.export(outfile, level, namespace_, name_='Layer3_Protocol', pretty_print=pretty_print)
        if self.Layer4_Protocol is not None:
            self.Layer4_Protocol.export(outfile, level, namespace_, name_='Layer4_Protocol', pretty_print=pretty_print)
        if self.Layer7_Protocol is not None:
            self.Layer7_Protocol.export(outfile, level, namespace_, name_='Layer7_Protocol', pretty_print=pretty_print)
        if self.Source_Socket_Address is not None:
            self.Source_Socket_Address.export(outfile, level, namespace_, name_='Source_Socket_Address', pretty_print=pretty_print)
        if self.Source_TCP_State is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSource_TCP_State>%s</%sSource_TCP_State>%s' % (namespace_, self.gds_format_string(quote_xml(self.Source_TCP_State).encode(ExternalEncoding), input_name='Source_TCP_State'), namespace_, eol_))
        if self.Destination_Socket_Address is not None:
            self.Destination_Socket_Address.export(outfile, level, namespace_, name_='Destination_Socket_Address', pretty_print=pretty_print)
        if self.Destination_TCP_State is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestination_TCP_State>%s</%sDestination_TCP_State>%s' % (namespace_, self.gds_format_string(quote_xml(self.Destination_TCP_State).encode(ExternalEncoding), input_name='Destination_TCP_State'), namespace_, eol_))
        if self.Layer7_Connections is not None:
            self.Layer7_Connections.export(outfile, level, namespace_, name_='Layer7_Connections', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkConnectionObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tls_used is not None and 'tls_used' not in already_processed:
            already_processed.add('tls_used')
            showIndent(outfile, level)
            outfile.write('tls_used=%s,\n' % (self.tls_used,))
        super(NetworkConnectionObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConnectionObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Creation_Time is not None:
            showIndent(outfile, level)
            outfile.write('Creation_Time=model_.DateTimeObjectPropertyType(\n')
            self.Creation_Time.exportLiteral(outfile, level, name_='Creation_Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Layer3_Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Layer3_Protocol=model_.Layer3ProtocolType(\n')
            self.Layer3_Protocol.exportLiteral(outfile, level, name_='Layer3_Protocol')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Layer4_Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Layer4_Protocol=model_.Layer4ProtocolType(\n')
            self.Layer4_Protocol.exportLiteral(outfile, level, name_='Layer4_Protocol')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Layer7_Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Layer7_Protocol=model_.Layer7ProtocolType(\n')
            self.Layer7_Protocol.exportLiteral(outfile, level, name_='Layer7_Protocol')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Source_Socket_Address is not None:
            showIndent(outfile, level)
            outfile.write('Source_Socket_Address=model_.SocketAddressObjectType(\n')
            self.Source_Socket_Address.exportLiteral(outfile, level, name_='Source_Socket_Address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Source_TCP_State is not None:
            showIndent(outfile, level)
            outfile.write('Source_TCP_State=%s,\n' % quote_python(self.Source_TCP_State).encode(ExternalEncoding))
        if self.Destination_Socket_Address is not None:
            showIndent(outfile, level)
            outfile.write('Destination_Socket_Address=model_.SocketAddressObjectType(\n')
            self.Destination_Socket_Address.exportLiteral(outfile, level, name_='Destination_Socket_Address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Destination_TCP_State is not None:
            showIndent(outfile, level)
            outfile.write('Destination_TCP_State=%s,\n' % quote_python(self.Destination_TCP_State).encode(ExternalEncoding))
        if self.Layer7_Connections is not None:
            showIndent(outfile, level)
            outfile.write('Layer7_Connections=model_.Layer7ConnectionsType(\n')
            self.Layer7_Connections.exportLiteral(outfile, level, name_='Layer7_Connections')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tls_used', node)
        if value is not None and 'tls_used' not in already_processed:
            already_processed.add('tls_used')
            if value in ('true', '1'):
                self.tls_used = True
            elif value in ('false', '0'):
                self.tls_used = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(NetworkConnectionObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Creation_Time':
            obj_ = None
            self.Creation_Time = obj_
            self.validate_DateTimeObjectPropertyType(self.Creation_Time)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'Layer3_Protocol':
            obj_ = None
            self.Layer3_Protocol = obj_
            self.validate_Layer3ProtocolType(self.Layer3_Protocol)    # validate type Layer3ProtocolType
        elif nodeName_ == 'Layer4_Protocol':
            obj_ = None
            self.Layer4_Protocol = obj_
            self.validate_Layer4ProtocolType(self.Layer4_Protocol)    # validate type Layer4ProtocolType
        elif nodeName_ == 'Layer7_Protocol':
            obj_ = None
            self.Layer7_Protocol = obj_
            self.validate_Layer7ProtocolType(self.Layer7_Protocol)    # validate type Layer7ProtocolType
        elif nodeName_ == 'Source_Socket_Address':
            obj_ = SocketAddressObjectType.factory()
            obj_.build(child_)
            self.Source_Socket_Address = obj_
        elif nodeName_ == 'Source_TCP_State':
            Source_TCP_State_ = child_.text
            Source_TCP_State_ = self.gds_validate_string(Source_TCP_State_, node, 'Source_TCP_State')
            self.Source_TCP_State = Source_TCP_State_
            self.validate_TCPStateEnum(self.Source_TCP_State)    # validate type TCPStateEnum
        elif nodeName_ == 'Destination_Socket_Address':
            obj_ = SocketAddressObjectType.factory()
            obj_.build(child_)
            self.Destination_Socket_Address = obj_
        elif nodeName_ == 'Destination_TCP_State':
            Destination_TCP_State_ = child_.text
            Destination_TCP_State_ = self.gds_validate_string(Destination_TCP_State_, node, 'Destination_TCP_State')
            self.Destination_TCP_State = Destination_TCP_State_
            self.validate_TCPStateEnum(self.Destination_TCP_State)    # validate type TCPStateEnum
        elif nodeName_ == 'Layer7_Connections':
            obj_ = Layer7ConnectionsType.factory()
            obj_.build(child_)
            self.Layer7_Connections = obj_
        super(NetworkConnectionObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConnectionObjectType


class Layer7ConnectionsType(GeneratedsSuper):
    """The Layer7ConnectionsType specifies the different types of
    application (layer 7 in the OSI model) connections that may be
    initiated as part of the network connection."""
    subclass = None
    superclass = None
    def __init__(self, HTTP_Session=None, DNS_Query=None):
        self.HTTP_Session = HTTP_Session
        if DNS_Query is None:
            self.DNS_Query = []
        else:
            self.DNS_Query = DNS_Query
    def factory(*args_, **kwargs_):
        if Layer7ConnectionsType.subclass:
            return Layer7ConnectionsType.subclass(*args_, **kwargs_)
        else:
            return Layer7ConnectionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HTTP_Session(self): return self.HTTP_Session
    def set_HTTP_Session(self, HTTP_Session): self.HTTP_Session = HTTP_Session
    def get_DNS_Query(self): return self.DNS_Query
    def set_DNS_Query(self, DNS_Query): self.DNS_Query = DNS_Query
    def add_DNS_Query(self, value): self.DNS_Query.append(value)
    def insert_DNS_Query(self, index, value): self.DNS_Query[index] = value
    def hasContent_(self):
        if (
            self.HTTP_Session is not None or
            self.DNS_Query
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='Layer7ConnectionsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Layer7ConnectionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='Layer7ConnectionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='Layer7ConnectionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HTTP_Session is not None:
            self.HTTP_Session.export(outfile, level, namespace_, name_='HTTP_Session', pretty_print=pretty_print)
        for DNS_Query_ in self.DNS_Query:
            DNS_Query_.export(outfile, level, namespace_, name_='DNS_Query', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Layer7ConnectionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HTTP_Session is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Session=model_.HTTPSessionObjectType(\n')
            self.HTTP_Session.exportLiteral(outfile, level, name_='HTTP_Session')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('DNS_Query=[\n')
        level += 1
        for DNS_Query_ in self.DNS_Query:
            showIndent(outfile, level)
            outfile.write('model_.DNSQueryObjectType(\n')
            DNS_Query_.exportLiteral(outfile, level, name_='DNSQueryObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HTTP_Session':
            obj_ = HTTPSessionObjectType.factory()
            obj_.build(child_)
            self.HTTP_Session = obj_
        elif nodeName_ == 'DNS_Query':
            obj_ = DNSQueryObjectType.factory()
            obj_.build(child_)
            self.DNS_Query.append(obj_)
# end class Layer7ConnectionsType


class Layer3ProtocolType(BaseObjectPropertyType):
    """Layer3ProtocolType specifies Layer 3 protocol types, via a union of
    the Layer3ProtocolEnum type and the atomic xs:string type. Its
    base type is the CybOX Core BaseObjectPropertyType, for
    permitting complex (i.e. regular-expression based)
    specifications.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(Layer3ProtocolType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Layer3ProtocolType.subclass:
            return Layer3ProtocolType.subclass(*args_, **kwargs_)
        else:
            return Layer3ProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Layer3ProtocolType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='Layer3ProtocolType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Layer3ProtocolType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='Layer3ProtocolType'):
        super(Layer3ProtocolType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Layer3ProtocolType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='Layer3ProtocolType', fromsubclass_=False, pretty_print=True):
        super(Layer3ProtocolType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='Layer3ProtocolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(Layer3ProtocolType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Layer3ProtocolType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(Layer3ProtocolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Layer3ProtocolType


class Layer7ProtocolType(BaseObjectPropertyType):
    """Layer7ProtocolType specifies Layer 7 protocol types, via a union of
    the Layer7ProtocolEnum type and the atomic xs:string type. Its
    base type is the CybOX Core BaseObjectPropertyType, for
    permitting complex (i.e. regular-expression based)
    specifications.This attribute is optional and specifies the
    expected type for the value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(Layer7ProtocolType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Layer7ProtocolType.subclass:
            return Layer7ProtocolType.subclass(*args_, **kwargs_)
        else:
            return Layer7ProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Layer7ProtocolType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='Layer7ProtocolType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Layer7ProtocolType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='Layer7ProtocolType'):
        super(Layer7ProtocolType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Layer7ProtocolType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='Layer7ProtocolType', fromsubclass_=False, pretty_print=True):
        super(Layer7ProtocolType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='Layer7ProtocolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(Layer7ProtocolType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Layer7ProtocolType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(Layer7ProtocolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Layer7ProtocolType


class HTTPSessionObjectType(ObjectPropertiesType):
    """The HTTPSessionObjectType is intended to capture the details of an
    HTTP session."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, HTTP_Request_Response=None):
        super(HTTPSessionObjectType, self).__init__(object_reference, Custom_Properties, )
        if HTTP_Request_Response is None:
            self.HTTP_Request_Response = []
        else:
            self.HTTP_Request_Response = HTTP_Request_Response
    def factory(*args_, **kwargs_):
        if HTTPSessionObjectType.subclass:
            return HTTPSessionObjectType.subclass(*args_, **kwargs_)
        else:
            return HTTPSessionObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HTTP_Request_Response(self): return self.HTTP_Request_Response
    def set_HTTP_Request_Response(self, HTTP_Request_Response): self.HTTP_Request_Response = HTTP_Request_Response
    def add_HTTP_Request_Response(self, value): self.HTTP_Request_Response.append(value)
    def insert_HTTP_Request_Response(self, index, value): self.HTTP_Request_Response[index] = value
    def hasContent_(self):
        if (
            self.HTTP_Request_Response or
            super(HTTPSessionObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPSessionObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPSessionObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPSessionObjectType'):
        super(HTTPSessionObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPSessionObjectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPSessionObjectType', fromsubclass_=False, pretty_print=True):
        super(HTTPSessionObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HTTP_Request_Response_ in self.HTTP_Request_Response:
            HTTP_Request_Response_.export(outfile, level, namespace_, name_='HTTP_Request_Response', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPSessionObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HTTPSessionObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HTTPSessionObjectType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('HTTP_Request_Response=[\n')
        level += 1
        for HTTP_Request_Response_ in self.HTTP_Request_Response:
            showIndent(outfile, level)
            outfile.write('model_.HTTPRequestResponseType(\n')
            HTTP_Request_Response_.exportLiteral(outfile, level, name_='HTTPRequestResponseType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HTTPSessionObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HTTP_Request_Response':
            obj_ = HTTPRequestResponseType.factory()
            obj_.build(child_)
            self.HTTP_Request_Response.append(obj_)
        super(HTTPSessionObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class HTTPSessionObjectType


class HTTPRequestResponseType(GeneratedsSuper):
    """The HTTPRequestResponseType captures a single HTTP request/response
    pair."""
    subclass = None
    superclass = None
    def __init__(self, HTTP_Client_Request=None, HTTP_Server_Response=None):
        self.HTTP_Client_Request = HTTP_Client_Request
        self.HTTP_Server_Response = HTTP_Server_Response
    def factory(*args_, **kwargs_):
        if HTTPRequestResponseType.subclass:
            return HTTPRequestResponseType.subclass(*args_, **kwargs_)
        else:
            return HTTPRequestResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HTTP_Client_Request(self): return self.HTTP_Client_Request
    def set_HTTP_Client_Request(self, HTTP_Client_Request): self.HTTP_Client_Request = HTTP_Client_Request
    def get_HTTP_Server_Response(self): return self.HTTP_Server_Response
    def set_HTTP_Server_Response(self, HTTP_Server_Response): self.HTTP_Server_Response = HTTP_Server_Response
    def hasContent_(self):
        if (
            self.HTTP_Client_Request is not None or
            self.HTTP_Server_Response is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPRequestResponseType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPRequestResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPRequestResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPRequestResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HTTP_Client_Request is not None:
            self.HTTP_Client_Request.export(outfile, level, namespace_, name_='HTTP_Client_Request', pretty_print=pretty_print)
        if self.HTTP_Server_Response is not None:
            self.HTTP_Server_Response.export(outfile, level, namespace_, name_='HTTP_Server_Response', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPRequestResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HTTP_Client_Request is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Client_Request=model_.HTTPClientRequestType(\n')
            self.HTTP_Client_Request.exportLiteral(outfile, level, name_='HTTP_Client_Request')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HTTP_Server_Response is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Server_Response=model_.HTTPServerResponseType(\n')
            self.HTTP_Server_Response.exportLiteral(outfile, level, name_='HTTP_Server_Response')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HTTP_Client_Request':
            obj_ = HTTPClientRequestType.factory()
            obj_.build(child_)
            self.HTTP_Client_Request = obj_
        elif nodeName_ == 'HTTP_Server_Response':
            obj_ = HTTPServerResponseType.factory()
            obj_.build(child_)
            self.HTTP_Server_Response = obj_
# end class HTTPRequestResponseType


class HTTPClientRequestType(GeneratedsSuper):
    """The HTTPClientRequestType field captures the details of an HTTP
    client request."""
    subclass = None
    superclass = None
    def __init__(self, HTTP_Request_Line=None, HTTP_Request_Header=None, HTTP_Message_Body=None):
        self.HTTP_Request_Line = HTTP_Request_Line
        self.HTTP_Request_Header = HTTP_Request_Header
        self.HTTP_Message_Body = HTTP_Message_Body
    def factory(*args_, **kwargs_):
        if HTTPClientRequestType.subclass:
            return HTTPClientRequestType.subclass(*args_, **kwargs_)
        else:
            return HTTPClientRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HTTP_Request_Line(self): return self.HTTP_Request_Line
    def set_HTTP_Request_Line(self, HTTP_Request_Line): self.HTTP_Request_Line = HTTP_Request_Line
    def get_HTTP_Request_Header(self): return self.HTTP_Request_Header
    def set_HTTP_Request_Header(self, HTTP_Request_Header): self.HTTP_Request_Header = HTTP_Request_Header
    def get_HTTP_Message_Body(self): return self.HTTP_Message_Body
    def set_HTTP_Message_Body(self, HTTP_Message_Body): self.HTTP_Message_Body = HTTP_Message_Body
    def hasContent_(self):
        if (
            self.HTTP_Request_Line is not None or
            self.HTTP_Request_Header is not None or
            self.HTTP_Message_Body is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPClientRequestType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPClientRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPClientRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPClientRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HTTP_Request_Line is not None:
            self.HTTP_Request_Line.export(outfile, level, namespace_, name_='HTTP_Request_Line', pretty_print=pretty_print)
        if self.HTTP_Request_Header is not None:
            self.HTTP_Request_Header.export(outfile, level, namespace_, name_='HTTP_Request_Header', pretty_print=pretty_print)
        if self.HTTP_Message_Body is not None:
            self.HTTP_Message_Body.export(outfile, level, namespace_, name_='HTTP_Message_Body', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPClientRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HTTP_Request_Line is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Request_Line=model_.HTTPRequestLineType(\n')
            self.HTTP_Request_Line.exportLiteral(outfile, level, name_='HTTP_Request_Line')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HTTP_Request_Header is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Request_Header=model_.HTTPRequestHeaderType(\n')
            self.HTTP_Request_Header.exportLiteral(outfile, level, name_='HTTP_Request_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HTTP_Message_Body is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Message_Body=model_.HTTPMessageType(\n')
            self.HTTP_Message_Body.exportLiteral(outfile, level, name_='HTTP_Message_Body')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HTTP_Request_Line':
            obj_ = HTTPRequestLineType.factory()
            obj_.build(child_)
            self.HTTP_Request_Line = obj_
        elif nodeName_ == 'HTTP_Request_Header':
            obj_ = HTTPRequestHeaderType.factory()
            obj_.build(child_)
            self.HTTP_Request_Header = obj_
        elif nodeName_ == 'HTTP_Message_Body':
            obj_ = HTTPMessageType.factory()
            obj_.build(child_)
            self.HTTP_Message_Body = obj_
# end class HTTPClientRequestType


class HTTPServerResponseType(GeneratedsSuper):
    """The HTTPServerResponseType captures the details of an HTTP server
    response."""
    subclass = None
    superclass = None
    def __init__(self, HTTP_Status_Line=None, HTTP_Response_Header=None, HTTP_Message_Body=None):
        self.HTTP_Status_Line = HTTP_Status_Line
        self.HTTP_Response_Header = HTTP_Response_Header
        self.HTTP_Message_Body = HTTP_Message_Body
    def factory(*args_, **kwargs_):
        if HTTPServerResponseType.subclass:
            return HTTPServerResponseType.subclass(*args_, **kwargs_)
        else:
            return HTTPServerResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HTTP_Status_Line(self): return self.HTTP_Status_Line
    def set_HTTP_Status_Line(self, HTTP_Status_Line): self.HTTP_Status_Line = HTTP_Status_Line
    def get_HTTP_Response_Header(self): return self.HTTP_Response_Header
    def set_HTTP_Response_Header(self, HTTP_Response_Header): self.HTTP_Response_Header = HTTP_Response_Header
    def get_HTTP_Message_Body(self): return self.HTTP_Message_Body
    def set_HTTP_Message_Body(self, HTTP_Message_Body): self.HTTP_Message_Body = HTTP_Message_Body
    def hasContent_(self):
        if (
            self.HTTP_Status_Line is not None or
            self.HTTP_Response_Header is not None or
            self.HTTP_Message_Body is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPServerResponseType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPServerResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPServerResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPServerResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HTTP_Status_Line is not None:
            self.HTTP_Status_Line.export(outfile, level, namespace_, name_='HTTP_Status_Line', pretty_print=pretty_print)
        if self.HTTP_Response_Header is not None:
            self.HTTP_Response_Header.export(outfile, level, namespace_, name_='HTTP_Response_Header', pretty_print=pretty_print)
        if self.HTTP_Message_Body is not None:
            self.HTTP_Message_Body.export(outfile, level, namespace_, name_='HTTP_Message_Body', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPServerResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HTTP_Status_Line is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Status_Line=model_.HTTPStatusLineType(\n')
            self.HTTP_Status_Line.exportLiteral(outfile, level, name_='HTTP_Status_Line')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HTTP_Response_Header is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Response_Header=model_.HTTPResponseHeaderType(\n')
            self.HTTP_Response_Header.exportLiteral(outfile, level, name_='HTTP_Response_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HTTP_Message_Body is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Message_Body=model_.HTTPMessageType(\n')
            self.HTTP_Message_Body.exportLiteral(outfile, level, name_='HTTP_Message_Body')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HTTP_Status_Line':
            obj_ = HTTPStatusLineType.factory()
            obj_.build(child_)
            self.HTTP_Status_Line = obj_
        elif nodeName_ == 'HTTP_Response_Header':
            obj_ = HTTPResponseHeaderType.factory()
            obj_.build(child_)
            self.HTTP_Response_Header = obj_
        elif nodeName_ == 'HTTP_Message_Body':
            obj_ = HTTPMessageType.factory()
            obj_.build(child_)
            self.HTTP_Message_Body = obj_
# end class HTTPServerResponseType


class HTTPRequestLineType(GeneratedsSuper):
    """The HTTPRequestLineType captures a single HTTP request line."""
    subclass = None
    superclass = None
    def __init__(self, HTTP_Method=None, Value=None, Version=None):
        self.HTTP_Method = HTTP_Method
        self.Value = Value
        self.Version = Version
    def factory(*args_, **kwargs_):
        if HTTPRequestLineType.subclass:
            return HTTPRequestLineType.subclass(*args_, **kwargs_)
        else:
            return HTTPRequestLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HTTP_Method(self): return self.HTTP_Method
    def set_HTTP_Method(self, HTTP_Method): self.HTTP_Method = HTTP_Method
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_HTTPMethodType(self, value):
        # Validate type HTTPMethodType, a restriction on None.
        pass
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.HTTP_Method is not None or
            self.Value is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPRequestLineType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPRequestLineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPRequestLineType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPRequestLineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HTTP_Method is not None:
            self.HTTP_Method.export(outfile, level, namespace_, name_='HTTP_Method', pretty_print=pretty_print)
        if self.Value is not None:
            self.Value.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPRequestLineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HTTP_Method is not None:
            showIndent(outfile, level)
            outfile.write('HTTP_Method=model_.HTTPMethodType(\n')
            self.HTTP_Method.exportLiteral(outfile, level, name_='HTTP_Method')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=model_.StringObjectPropertyType(\n')
            self.Value.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=model_.StringObjectPropertyType(\n')
            self.Version.exportLiteral(outfile, level, name_='Version')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HTTP_Method':
            obj_ = None
            self.HTTP_Method = obj_
            self.validate_HTTPMethodType(self.HTTP_Method)    # validate type HTTPMethodType
        elif nodeName_ == 'Value':
            obj_ = None
            self.Value = obj_
            self.validate_StringObjectPropertyType(self.Value)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Version':
            obj_ = None
            self.Version = obj_
            self.validate_StringObjectPropertyType(self.Version)    # validate type StringObjectPropertyType
# end class HTTPRequestLineType


class HTTPRequestHeaderType(GeneratedsSuper):
    """The HTTPRequestHeaderType captures the raw or parsed header of an
    HTTP request."""
    subclass = None
    superclass = None
    def __init__(self, Raw_Header=None, Parsed_Header=None):
        self.Raw_Header = Raw_Header
        self.Parsed_Header = Parsed_Header
    def factory(*args_, **kwargs_):
        if HTTPRequestHeaderType.subclass:
            return HTTPRequestHeaderType.subclass(*args_, **kwargs_)
        else:
            return HTTPRequestHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Raw_Header(self): return self.Raw_Header
    def set_Raw_Header(self, Raw_Header): self.Raw_Header = Raw_Header
    def get_Parsed_Header(self): return self.Parsed_Header
    def set_Parsed_Header(self, Parsed_Header): self.Parsed_Header = Parsed_Header
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Raw_Header is not None or
            self.Parsed_Header is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPRequestHeaderType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPRequestHeaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPRequestHeaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPRequestHeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Raw_Header is not None:
            self.Raw_Header.export(outfile, level, namespace_, name_='Raw_Header', pretty_print=pretty_print)
        if self.Parsed_Header is not None:
            self.Parsed_Header.export(outfile, level, namespace_, name_='Parsed_Header', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPRequestHeaderType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Raw_Header is not None:
            showIndent(outfile, level)
            outfile.write('Raw_Header=model_.StringObjectPropertyType(\n')
            self.Raw_Header.exportLiteral(outfile, level, name_='Raw_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Parsed_Header is not None:
            showIndent(outfile, level)
            outfile.write('Parsed_Header=model_.HTTPRequestHeaderFieldsType(\n')
            self.Parsed_Header.exportLiteral(outfile, level, name_='Parsed_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Raw_Header':
            obj_ = None
            self.Raw_Header = obj_
            self.validate_StringObjectPropertyType(self.Raw_Header)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Parsed_Header':
            obj_ = HTTPRequestHeaderFieldsType.factory()
            obj_.build(child_)
            self.Parsed_Header = obj_
# end class HTTPRequestHeaderType


class HTTPRequestHeaderFieldsType(GeneratedsSuper):
    """The HTTPRequestHeaderFieldsType captures parsed HTTP request header
    fields."""
    subclass = None
    superclass = None
    def __init__(self, Accept=None, Accept_Charset=None, Accept_Language=None, Accept_Datetime=None, Accept_Encoding=None, Authorization=None, Cache_Control=None, Connection=None, Cookie=None, Content_Length=None, Content_MD5=None, Content_Type=None, Date=None, Expect=None, From=None, Host=None, If_Match=None, If_Modified_Since=None, If_None_Match=None, If_Range=None, If_Unmodified_Since=None, Max_Forwards=None, Pragma=None, Proxy_Authorization=None, Range=None, Referer=None, TE=None, User_Agent=None, Via=None, Warning=None, DNT=None, X_Requested_With=None, X_Requested_For=None, X_ATT_DeviceId=None, X_Wap_Profile=None):
        self.Accept = Accept
        self.Accept_Charset = Accept_Charset
        self.Accept_Language = Accept_Language
        self.Accept_Datetime = Accept_Datetime
        self.Accept_Encoding = Accept_Encoding
        self.Authorization = Authorization
        self.Cache_Control = Cache_Control
        self.Connection = Connection
        self.Cookie = Cookie
        self.Content_Length = Content_Length
        self.Content_MD5 = Content_MD5
        self.Content_Type = Content_Type
        self.Date = Date
        self.Expect = Expect
        self.From = From
        self.Host = Host
        self.If_Match = If_Match
        self.If_Modified_Since = If_Modified_Since
        self.If_None_Match = If_None_Match
        self.If_Range = If_Range
        self.If_Unmodified_Since = If_Unmodified_Since
        self.Max_Forwards = Max_Forwards
        self.Pragma = Pragma
        self.Proxy_Authorization = Proxy_Authorization
        self.Range = Range
        self.Referer = Referer
        self.TE = TE
        self.User_Agent = User_Agent
        self.Via = Via
        self.Warning = Warning
        self.DNT = DNT
        self.X_Requested_With = X_Requested_With
        self.X_Requested_For = X_Requested_For
        self.X_ATT_DeviceId = X_ATT_DeviceId
        self.X_Wap_Profile = X_Wap_Profile
    def factory(*args_, **kwargs_):
        if HTTPRequestHeaderFieldsType.subclass:
            return HTTPRequestHeaderFieldsType.subclass(*args_, **kwargs_)
        else:
            return HTTPRequestHeaderFieldsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Accept(self): return self.Accept
    def set_Accept(self, Accept): self.Accept = Accept
    def get_Accept_Charset(self): return self.Accept_Charset
    def set_Accept_Charset(self, Accept_Charset): self.Accept_Charset = Accept_Charset
    def get_Accept_Language(self): return self.Accept_Language
    def set_Accept_Language(self, Accept_Language): self.Accept_Language = Accept_Language
    def get_Accept_Datetime(self): return self.Accept_Datetime
    def set_Accept_Datetime(self, Accept_Datetime): self.Accept_Datetime = Accept_Datetime
    def get_Accept_Encoding(self): return self.Accept_Encoding
    def set_Accept_Encoding(self, Accept_Encoding): self.Accept_Encoding = Accept_Encoding
    def get_Authorization(self): return self.Authorization
    def set_Authorization(self, Authorization): self.Authorization = Authorization
    def get_Cache_Control(self): return self.Cache_Control
    def set_Cache_Control(self, Cache_Control): self.Cache_Control = Cache_Control
    def get_Connection(self): return self.Connection
    def set_Connection(self, Connection): self.Connection = Connection
    def get_Cookie(self): return self.Cookie
    def set_Cookie(self, Cookie): self.Cookie = Cookie
    def get_Content_Length(self): return self.Content_Length
    def set_Content_Length(self, Content_Length): self.Content_Length = Content_Length
    def get_Content_MD5(self): return self.Content_MD5
    def set_Content_MD5(self, Content_MD5): self.Content_MD5 = Content_MD5
    def get_Content_Type(self): return self.Content_Type
    def set_Content_Type(self, Content_Type): self.Content_Type = Content_Type
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Expect(self): return self.Expect
    def set_Expect(self, Expect): self.Expect = Expect
    def get_From(self): return self.From
    def set_From(self, From): self.From = From
    def get_Host(self): return self.Host
    def set_Host(self, Host): self.Host = Host
    def get_If_Match(self): return self.If_Match
    def set_If_Match(self, If_Match): self.If_Match = If_Match
    def get_If_Modified_Since(self): return self.If_Modified_Since
    def set_If_Modified_Since(self, If_Modified_Since): self.If_Modified_Since = If_Modified_Since
    def get_If_None_Match(self): return self.If_None_Match
    def set_If_None_Match(self, If_None_Match): self.If_None_Match = If_None_Match
    def get_If_Range(self): return self.If_Range
    def set_If_Range(self, If_Range): self.If_Range = If_Range
    def get_If_Unmodified_Since(self): return self.If_Unmodified_Since
    def set_If_Unmodified_Since(self, If_Unmodified_Since): self.If_Unmodified_Since = If_Unmodified_Since
    def get_Max_Forwards(self): return self.Max_Forwards
    def set_Max_Forwards(self, Max_Forwards): self.Max_Forwards = Max_Forwards
    def get_Pragma(self): return self.Pragma
    def set_Pragma(self, Pragma): self.Pragma = Pragma
    def get_Proxy_Authorization(self): return self.Proxy_Authorization
    def set_Proxy_Authorization(self, Proxy_Authorization): self.Proxy_Authorization = Proxy_Authorization
    def get_Range(self): return self.Range
    def set_Range(self, Range): self.Range = Range
    def get_Referer(self): return self.Referer
    def set_Referer(self, Referer): self.Referer = Referer
    def get_TE(self): return self.TE
    def set_TE(self, TE): self.TE = TE
    def get_User_Agent(self): return self.User_Agent
    def set_User_Agent(self, User_Agent): self.User_Agent = User_Agent
    def get_Via(self): return self.Via
    def set_Via(self, Via): self.Via = Via
    def get_Warning(self): return self.Warning
    def set_Warning(self, Warning): self.Warning = Warning
    def get_DNT(self): return self.DNT
    def set_DNT(self, DNT): self.DNT = DNT
    def get_X_Requested_With(self): return self.X_Requested_With
    def set_X_Requested_With(self, X_Requested_With): self.X_Requested_With = X_Requested_With
    def get_X_Requested_For(self): return self.X_Requested_For
    def set_X_Requested_For(self, X_Requested_For): self.X_Requested_For = X_Requested_For
    def get_X_ATT_DeviceId(self): return self.X_ATT_DeviceId
    def set_X_ATT_DeviceId(self, X_ATT_DeviceId): self.X_ATT_DeviceId = X_ATT_DeviceId
    def get_X_Wap_Profile(self): return self.X_Wap_Profile
    def set_X_Wap_Profile(self, X_Wap_Profile): self.X_Wap_Profile = X_Wap_Profile
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def validate_IntegerObjectPropertyType(self, value):
        # Validate type IntegerObjectPropertyType, a restriction on None.
        pass
    def validate_DateTimeObjectPropertyType(self, value):
        # Validate type DateTimeObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Accept is not None or
            self.Accept_Charset is not None or
            self.Accept_Language is not None or
            self.Accept_Datetime is not None or
            self.Accept_Encoding is not None or
            self.Authorization is not None or
            self.Cache_Control is not None or
            self.Connection is not None or
            self.Cookie is not None or
            self.Content_Length is not None or
            self.Content_MD5 is not None or
            self.Content_Type is not None or
            self.Date is not None or
            self.Expect is not None or
            self.From is not None or
            self.Host is not None or
            self.If_Match is not None or
            self.If_Modified_Since is not None or
            self.If_None_Match is not None or
            self.If_Range is not None or
            self.If_Unmodified_Since is not None or
            self.Max_Forwards is not None or
            self.Pragma is not None or
            self.Proxy_Authorization is not None or
            self.Range is not None or
            self.Referer is not None or
            self.TE is not None or
            self.User_Agent is not None or
            self.Via is not None or
            self.Warning is not None or
            self.DNT is not None or
            self.X_Requested_With is not None or
            self.X_Requested_For is not None or
            self.X_ATT_DeviceId is not None or
            self.X_Wap_Profile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPRequestHeaderFieldsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:URIObj="http://cybox.mitre.org/objects#URIObject-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPRequestHeaderFieldsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPRequestHeaderFieldsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPRequestHeaderFieldsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Accept is not None:
            self.Accept.export(outfile, level, namespace_, name_='Accept', pretty_print=pretty_print)
        if self.Accept_Charset is not None:
            self.Accept_Charset.export(outfile, level, namespace_, name_='Accept_Charset', pretty_print=pretty_print)
        if self.Accept_Language is not None:
            self.Accept_Language.export(outfile, level, namespace_, name_='Accept_Language', pretty_print=pretty_print)
        if self.Accept_Datetime is not None:
            self.Accept_Datetime.export(outfile, level, namespace_, name_='Accept_Datetime', pretty_print=pretty_print)
        if self.Accept_Encoding is not None:
            self.Accept_Encoding.export(outfile, level, namespace_, name_='Accept_Encoding', pretty_print=pretty_print)
        if self.Authorization is not None:
            self.Authorization.export(outfile, level, namespace_, name_='Authorization', pretty_print=pretty_print)
        if self.Cache_Control is not None:
            self.Cache_Control.export(outfile, level, namespace_, name_='Cache_Control', pretty_print=pretty_print)
        if self.Connection is not None:
            self.Connection.export(outfile, level, namespace_, name_='Connection', pretty_print=pretty_print)
        if self.Cookie is not None:
            self.Cookie.export(outfile, level, namespace_, name_='Cookie', pretty_print=pretty_print)
        if self.Content_Length is not None:
            self.Content_Length.export(outfile, level, namespace_, name_='Content_Length', pretty_print=pretty_print)
        if self.Content_MD5 is not None:
            self.Content_MD5.export(outfile, level, namespace_, name_='Content_MD5', pretty_print=pretty_print)
        if self.Content_Type is not None:
            self.Content_Type.export(outfile, level, namespace_, name_='Content_Type', pretty_print=pretty_print)
        if self.Date is not None:
            self.Date.export(outfile, level, namespace_, name_='Date', pretty_print=pretty_print)
        if self.Expect is not None:
            self.Expect.export(outfile, level, namespace_, name_='Expect', pretty_print=pretty_print)
        if self.From is not None:
            self.From.export(outfile, level, namespace_, name_='From', pretty_print=pretty_print)
        if self.Host is not None:
            self.Host.export(outfile, level, namespace_, name_='Host', pretty_print=pretty_print)
        if self.If_Match is not None:
            self.If_Match.export(outfile, level, namespace_, name_='If_Match', pretty_print=pretty_print)
        if self.If_Modified_Since is not None:
            self.If_Modified_Since.export(outfile, level, namespace_, name_='If_Modified_Since', pretty_print=pretty_print)
        if self.If_None_Match is not None:
            self.If_None_Match.export(outfile, level, namespace_, name_='If_None_Match', pretty_print=pretty_print)
        if self.If_Range is not None:
            self.If_Range.export(outfile, level, namespace_, name_='If_Range', pretty_print=pretty_print)
        if self.If_Unmodified_Since is not None:
            self.If_Unmodified_Since.export(outfile, level, namespace_, name_='If_Unmodified_Since', pretty_print=pretty_print)
        if self.Max_Forwards is not None:
            self.Max_Forwards.export(outfile, level, namespace_, name_='Max_Forwards', pretty_print=pretty_print)
        if self.Pragma is not None:
            self.Pragma.export(outfile, level, namespace_, name_='Pragma', pretty_print=pretty_print)
        if self.Proxy_Authorization is not None:
            self.Proxy_Authorization.export(outfile, level, namespace_, name_='Proxy_Authorization', pretty_print=pretty_print)
        if self.Range is not None:
            self.Range.export(outfile, level, namespace_, name_='Range', pretty_print=pretty_print)
        if self.Referer is not None:
            self.Referer.export(outfile, level, namespace_, name_='Referer', pretty_print=pretty_print)
        if self.TE is not None:
            self.TE.export(outfile, level, namespace_, name_='TE', pretty_print=pretty_print)
        if self.User_Agent is not None:
            self.User_Agent.export(outfile, level, namespace_, name_='User_Agent', pretty_print=pretty_print)
        if self.Via is not None:
            self.Via.export(outfile, level, namespace_, name_='Via', pretty_print=pretty_print)
        if self.Warning is not None:
            self.Warning.export(outfile, level, namespace_, name_='Warning', pretty_print=pretty_print)
        if self.DNT is not None:
            self.DNT.export(outfile, level, namespace_, name_='DNT', pretty_print=pretty_print)
        if self.X_Requested_With is not None:
            self.X_Requested_With.export(outfile, level, namespace_, name_='X_Requested_With', pretty_print=pretty_print)
        if self.X_Requested_For is not None:
            self.X_Requested_For.export(outfile, level, namespace_, name_='X_Requested_For', pretty_print=pretty_print)
        if self.X_ATT_DeviceId is not None:
            self.X_ATT_DeviceId.export(outfile, level, namespace_, name_='X_ATT_DeviceId', pretty_print=pretty_print)
        if self.X_Wap_Profile is not None:
            self.X_Wap_Profile.export(outfile, level, namespace_, name_='X_Wap_Profile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPRequestHeaderFieldsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Accept is not None:
            showIndent(outfile, level)
            outfile.write('Accept=model_.StringObjectPropertyType(\n')
            self.Accept.exportLiteral(outfile, level, name_='Accept')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accept_Charset is not None:
            showIndent(outfile, level)
            outfile.write('Accept_Charset=model_.StringObjectPropertyType(\n')
            self.Accept_Charset.exportLiteral(outfile, level, name_='Accept_Charset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accept_Language is not None:
            showIndent(outfile, level)
            outfile.write('Accept_Language=model_.StringObjectPropertyType(\n')
            self.Accept_Language.exportLiteral(outfile, level, name_='Accept_Language')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accept_Datetime is not None:
            showIndent(outfile, level)
            outfile.write('Accept_Datetime=model_.StringObjectPropertyType(\n')
            self.Accept_Datetime.exportLiteral(outfile, level, name_='Accept_Datetime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accept_Encoding is not None:
            showIndent(outfile, level)
            outfile.write('Accept_Encoding=model_.StringObjectPropertyType(\n')
            self.Accept_Encoding.exportLiteral(outfile, level, name_='Accept_Encoding')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Authorization is not None:
            showIndent(outfile, level)
            outfile.write('Authorization=model_.StringObjectPropertyType(\n')
            self.Authorization.exportLiteral(outfile, level, name_='Authorization')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Cache_Control is not None:
            showIndent(outfile, level)
            outfile.write('Cache_Control=model_.StringObjectPropertyType(\n')
            self.Cache_Control.exportLiteral(outfile, level, name_='Cache_Control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Connection is not None:
            showIndent(outfile, level)
            outfile.write('Connection=model_.StringObjectPropertyType(\n')
            self.Connection.exportLiteral(outfile, level, name_='Connection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Cookie is not None:
            showIndent(outfile, level)
            outfile.write('Cookie=model_.StringObjectPropertyType(\n')
            self.Cookie.exportLiteral(outfile, level, name_='Cookie')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Length is not None:
            showIndent(outfile, level)
            outfile.write('Content_Length=model_.IntegerObjectPropertyType(\n')
            self.Content_Length.exportLiteral(outfile, level, name_='Content_Length')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_MD5 is not None:
            showIndent(outfile, level)
            outfile.write('Content_MD5=model_.StringObjectPropertyType(\n')
            self.Content_MD5.exportLiteral(outfile, level, name_='Content_MD5')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Type is not None:
            showIndent(outfile, level)
            outfile.write('Content_Type=model_.StringObjectPropertyType(\n')
            self.Content_Type.exportLiteral(outfile, level, name_='Content_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=model_.DateTimeObjectPropertyType(\n')
            self.Date.exportLiteral(outfile, level, name_='Date')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Expect is not None:
            showIndent(outfile, level)
            outfile.write('Expect=model_.StringObjectPropertyType(\n')
            self.Expect.exportLiteral(outfile, level, name_='Expect')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.From is not None:
            showIndent(outfile, level)
            outfile.write('From=model_.AddressObjectType(\n')
            self.From.exportLiteral(outfile, level, name_='From')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Host is not None:
            showIndent(outfile, level)
            outfile.write('Host=model_.HostFieldType(\n')
            self.Host.exportLiteral(outfile, level, name_='Host')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.If_Match is not None:
            showIndent(outfile, level)
            outfile.write('If_Match=model_.StringObjectPropertyType(\n')
            self.If_Match.exportLiteral(outfile, level, name_='If_Match')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.If_Modified_Since is not None:
            showIndent(outfile, level)
            outfile.write('If_Modified_Since=model_.DateTimeObjectPropertyType(\n')
            self.If_Modified_Since.exportLiteral(outfile, level, name_='If_Modified_Since')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.If_None_Match is not None:
            showIndent(outfile, level)
            outfile.write('If_None_Match=model_.StringObjectPropertyType(\n')
            self.If_None_Match.exportLiteral(outfile, level, name_='If_None_Match')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.If_Range is not None:
            showIndent(outfile, level)
            outfile.write('If_Range=model_.StringObjectPropertyType(\n')
            self.If_Range.exportLiteral(outfile, level, name_='If_Range')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.If_Unmodified_Since is not None:
            showIndent(outfile, level)
            outfile.write('If_Unmodified_Since=model_.DateTimeObjectPropertyType(\n')
            self.If_Unmodified_Since.exportLiteral(outfile, level, name_='If_Unmodified_Since')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Max_Forwards is not None:
            showIndent(outfile, level)
            outfile.write('Max_Forwards=model_.IntegerObjectPropertyType(\n')
            self.Max_Forwards.exportLiteral(outfile, level, name_='Max_Forwards')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Pragma is not None:
            showIndent(outfile, level)
            outfile.write('Pragma=model_.StringObjectPropertyType(\n')
            self.Pragma.exportLiteral(outfile, level, name_='Pragma')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Proxy_Authorization is not None:
            showIndent(outfile, level)
            outfile.write('Proxy_Authorization=model_.StringObjectPropertyType(\n')
            self.Proxy_Authorization.exportLiteral(outfile, level, name_='Proxy_Authorization')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Range is not None:
            showIndent(outfile, level)
            outfile.write('Range=model_.StringObjectPropertyType(\n')
            self.Range.exportLiteral(outfile, level, name_='Range')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Referer is not None:
            showIndent(outfile, level)
            outfile.write('Referer=model_.URIObjectType(\n')
            self.Referer.exportLiteral(outfile, level, name_='Referer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TE is not None:
            showIndent(outfile, level)
            outfile.write('TE=model_.StringObjectPropertyType(\n')
            self.TE.exportLiteral(outfile, level, name_='TE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.User_Agent is not None:
            showIndent(outfile, level)
            outfile.write('User_Agent=model_.StringObjectPropertyType(\n')
            self.User_Agent.exportLiteral(outfile, level, name_='User_Agent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Via is not None:
            showIndent(outfile, level)
            outfile.write('Via=model_.StringObjectPropertyType(\n')
            self.Via.exportLiteral(outfile, level, name_='Via')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Warning is not None:
            showIndent(outfile, level)
            outfile.write('Warning=model_.StringObjectPropertyType(\n')
            self.Warning.exportLiteral(outfile, level, name_='Warning')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DNT is not None:
            showIndent(outfile, level)
            outfile.write('DNT=model_.URIObjectType(\n')
            self.DNT.exportLiteral(outfile, level, name_='DNT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_Requested_With is not None:
            showIndent(outfile, level)
            outfile.write('X_Requested_With=model_.StringObjectPropertyType(\n')
            self.X_Requested_With.exportLiteral(outfile, level, name_='X_Requested_With')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_Requested_For is not None:
            showIndent(outfile, level)
            outfile.write('X_Requested_For=model_.StringObjectPropertyType(\n')
            self.X_Requested_For.exportLiteral(outfile, level, name_='X_Requested_For')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_ATT_DeviceId is not None:
            showIndent(outfile, level)
            outfile.write('X_ATT_DeviceId=model_.StringObjectPropertyType(\n')
            self.X_ATT_DeviceId.exportLiteral(outfile, level, name_='X_ATT_DeviceId')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_Wap_Profile is not None:
            showIndent(outfile, level)
            outfile.write('X_Wap_Profile=model_.URIObjectType(\n')
            self.X_Wap_Profile.exportLiteral(outfile, level, name_='X_Wap_Profile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Accept':
            obj_ = None
            self.Accept = obj_
            self.validate_StringObjectPropertyType(self.Accept)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Accept_Charset':
            obj_ = None
            self.Accept_Charset = obj_
            self.validate_StringObjectPropertyType(self.Accept_Charset)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Accept_Language':
            obj_ = None
            self.Accept_Language = obj_
            self.validate_StringObjectPropertyType(self.Accept_Language)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Accept_Datetime':
            obj_ = None
            self.Accept_Datetime = obj_
            self.validate_StringObjectPropertyType(self.Accept_Datetime)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Accept_Encoding':
            obj_ = None
            self.Accept_Encoding = obj_
            self.validate_StringObjectPropertyType(self.Accept_Encoding)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Authorization':
            obj_ = None
            self.Authorization = obj_
            self.validate_StringObjectPropertyType(self.Authorization)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Cache_Control':
            obj_ = None
            self.Cache_Control = obj_
            self.validate_StringObjectPropertyType(self.Cache_Control)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Connection':
            obj_ = None
            self.Connection = obj_
            self.validate_StringObjectPropertyType(self.Connection)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Cookie':
            obj_ = None
            self.Cookie = obj_
            self.validate_StringObjectPropertyType(self.Cookie)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_Length':
            obj_ = None
            self.Content_Length = obj_
            self.validate_IntegerObjectPropertyType(self.Content_Length)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Content_MD5':
            obj_ = None
            self.Content_MD5 = obj_
            self.validate_StringObjectPropertyType(self.Content_MD5)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_Type':
            obj_ = None
            self.Content_Type = obj_
            self.validate_StringObjectPropertyType(self.Content_Type)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Date':
            obj_ = None
            self.Date = obj_
            self.validate_DateTimeObjectPropertyType(self.Date)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'Expect':
            obj_ = None
            self.Expect = obj_
            self.validate_StringObjectPropertyType(self.Expect)    # validate type StringObjectPropertyType
        elif nodeName_ == 'From':
            obj_ = AddressObjectType.factory()
            obj_.build(child_)
            self.From = obj_
        elif nodeName_ == 'Host':
            obj_ = HostFieldType.factory()
            obj_.build(child_)
            self.Host = obj_
        elif nodeName_ == 'If_Match':
            obj_ = None
            self.If_Match = obj_
            self.validate_StringObjectPropertyType(self.If_Match)    # validate type StringObjectPropertyType
        elif nodeName_ == 'If_Modified_Since':
            obj_ = None
            self.If_Modified_Since = obj_
            self.validate_DateTimeObjectPropertyType(self.If_Modified_Since)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'If_None_Match':
            obj_ = None
            self.If_None_Match = obj_
            self.validate_StringObjectPropertyType(self.If_None_Match)    # validate type StringObjectPropertyType
        elif nodeName_ == 'If_Range':
            obj_ = None
            self.If_Range = obj_
            self.validate_StringObjectPropertyType(self.If_Range)    # validate type StringObjectPropertyType
        elif nodeName_ == 'If_Unmodified_Since':
            obj_ = None
            self.If_Unmodified_Since = obj_
            self.validate_DateTimeObjectPropertyType(self.If_Unmodified_Since)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'Max_Forwards':
            obj_ = None
            self.Max_Forwards = obj_
            self.validate_IntegerObjectPropertyType(self.Max_Forwards)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Pragma':
            obj_ = None
            self.Pragma = obj_
            self.validate_StringObjectPropertyType(self.Pragma)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Proxy_Authorization':
            obj_ = None
            self.Proxy_Authorization = obj_
            self.validate_StringObjectPropertyType(self.Proxy_Authorization)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Range':
            obj_ = None
            self.Range = obj_
            self.validate_StringObjectPropertyType(self.Range)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Referer':
            obj_ = URIObjectType.factory()
            obj_.build(child_)
            self.Referer = obj_
        elif nodeName_ == 'TE':
            obj_ = None
            self.TE = obj_
            self.validate_StringObjectPropertyType(self.TE)    # validate type StringObjectPropertyType
        elif nodeName_ == 'User_Agent':
            obj_ = None
            self.User_Agent = obj_
            self.validate_StringObjectPropertyType(self.User_Agent)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Via':
            obj_ = None
            self.Via = obj_
            self.validate_StringObjectPropertyType(self.Via)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Warning':
            obj_ = None
            self.Warning = obj_
            self.validate_StringObjectPropertyType(self.Warning)    # validate type StringObjectPropertyType
        elif nodeName_ == 'DNT':
            obj_ = URIObjectType.factory()
            obj_.build(child_)
            self.DNT = obj_
        elif nodeName_ == 'X_Requested_With':
            obj_ = None
            self.X_Requested_With = obj_
            self.validate_StringObjectPropertyType(self.X_Requested_With)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_Requested_For':
            obj_ = None
            self.X_Requested_For = obj_
            self.validate_StringObjectPropertyType(self.X_Requested_For)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_ATT_DeviceId':
            obj_ = None
            self.X_ATT_DeviceId = obj_
            self.validate_StringObjectPropertyType(self.X_ATT_DeviceId)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_Wap_Profile':
            obj_ = URIObjectType.factory()
            obj_.build(child_)
            self.X_Wap_Profile = obj_
# end class HTTPRequestHeaderFieldsType


class HTTPResponseHeaderType(GeneratedsSuper):
    """The HTTPResponseHeaderType captures the raw or parsed header of an
    HTTP response."""
    subclass = None
    superclass = None
    def __init__(self, Raw_Header=None, Parsed_Header=None):
        self.Raw_Header = Raw_Header
        self.Parsed_Header = Parsed_Header
    def factory(*args_, **kwargs_):
        if HTTPResponseHeaderType.subclass:
            return HTTPResponseHeaderType.subclass(*args_, **kwargs_)
        else:
            return HTTPResponseHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Raw_Header(self): return self.Raw_Header
    def set_Raw_Header(self, Raw_Header): self.Raw_Header = Raw_Header
    def get_Parsed_Header(self): return self.Parsed_Header
    def set_Parsed_Header(self, Parsed_Header): self.Parsed_Header = Parsed_Header
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Raw_Header is not None or
            self.Parsed_Header is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPResponseHeaderType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPResponseHeaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPResponseHeaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPResponseHeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Raw_Header is not None:
            self.Raw_Header.export(outfile, level, namespace_, name_='Raw_Header', pretty_print=pretty_print)
        if self.Parsed_Header is not None:
            self.Parsed_Header.export(outfile, level, namespace_, name_='Parsed_Header', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPResponseHeaderType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Raw_Header is not None:
            showIndent(outfile, level)
            outfile.write('Raw_Header=model_.StringObjectPropertyType(\n')
            self.Raw_Header.exportLiteral(outfile, level, name_='Raw_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Parsed_Header is not None:
            showIndent(outfile, level)
            outfile.write('Parsed_Header=model_.HTTPResponseHeaderFieldsType(\n')
            self.Parsed_Header.exportLiteral(outfile, level, name_='Parsed_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Raw_Header':
            obj_ = None
            self.Raw_Header = obj_
            self.validate_StringObjectPropertyType(self.Raw_Header)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Parsed_Header':
            obj_ = HTTPResponseHeaderFieldsType.factory()
            obj_.build(child_)
            self.Parsed_Header = obj_
# end class HTTPResponseHeaderType


class HTTPResponseHeaderFieldsType(GeneratedsSuper):
    """The HTTPRequestHeaderFieldsType captures parsed HTTP request header
    fields."""
    subclass = None
    superclass = None
    def __init__(self, Access_Control_Allow_Origin=None, Accept_Ranges=None, Age=None, Cache_Control=None, Connection=None, Content_Encoding=None, Content_Language=None, Content_Length=None, Content_Location=None, Content_MD5=None, Content_Disposition=None, Content_Range=None, Content_Type=None, Date=None, ETag=None, Expires=None, Last_Modified=None, Link=None, Location=None, P3P=None, Pragma=None, Proxy_Authenticate=None, Refresh=None, Retry_After=None, Server=None, Set_Cookie=None, Strict_Transport_Security=None, Trailer=None, Transfer_Encoding=None, Vary=None, Via=None, Warning=None, WWW_Authenticate=None, X_Frame_Options=None, X_XSS_Protection=None, X_Content_Type_Options=None, X_Forwarded_Proto=None, X_Powered_By=None, X_UA_Compatible=None):
        self.Access_Control_Allow_Origin = Access_Control_Allow_Origin
        self.Accept_Ranges = Accept_Ranges
        self.Age = Age
        self.Cache_Control = Cache_Control
        self.Connection = Connection
        self.Content_Encoding = Content_Encoding
        self.Content_Language = Content_Language
        self.Content_Length = Content_Length
        self.Content_Location = Content_Location
        self.Content_MD5 = Content_MD5
        self.Content_Disposition = Content_Disposition
        self.Content_Range = Content_Range
        self.Content_Type = Content_Type
        self.Date = Date
        self.ETag = ETag
        self.Expires = Expires
        self.Last_Modified = Last_Modified
        self.Link = Link
        self.Location = Location
        self.P3P = P3P
        self.Pragma = Pragma
        self.Proxy_Authenticate = Proxy_Authenticate
        self.Refresh = Refresh
        self.Retry_After = Retry_After
        self.Server = Server
        self.Set_Cookie = Set_Cookie
        self.Strict_Transport_Security = Strict_Transport_Security
        self.Trailer = Trailer
        self.Transfer_Encoding = Transfer_Encoding
        self.Vary = Vary
        self.Via = Via
        self.Warning = Warning
        self.WWW_Authenticate = WWW_Authenticate
        self.X_Frame_Options = X_Frame_Options
        self.X_XSS_Protection = X_XSS_Protection
        self.X_Content_Type_Options = X_Content_Type_Options
        self.X_Forwarded_Proto = X_Forwarded_Proto
        self.X_Powered_By = X_Powered_By
        self.X_UA_Compatible = X_UA_Compatible
    def factory(*args_, **kwargs_):
        if HTTPResponseHeaderFieldsType.subclass:
            return HTTPResponseHeaderFieldsType.subclass(*args_, **kwargs_)
        else:
            return HTTPResponseHeaderFieldsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Access_Control_Allow_Origin(self): return self.Access_Control_Allow_Origin
    def set_Access_Control_Allow_Origin(self, Access_Control_Allow_Origin): self.Access_Control_Allow_Origin = Access_Control_Allow_Origin
    def get_Accept_Ranges(self): return self.Accept_Ranges
    def set_Accept_Ranges(self, Accept_Ranges): self.Accept_Ranges = Accept_Ranges
    def get_Age(self): return self.Age
    def set_Age(self, Age): self.Age = Age
    def get_Cache_Control(self): return self.Cache_Control
    def set_Cache_Control(self, Cache_Control): self.Cache_Control = Cache_Control
    def get_Connection(self): return self.Connection
    def set_Connection(self, Connection): self.Connection = Connection
    def get_Content_Encoding(self): return self.Content_Encoding
    def set_Content_Encoding(self, Content_Encoding): self.Content_Encoding = Content_Encoding
    def get_Content_Language(self): return self.Content_Language
    def set_Content_Language(self, Content_Language): self.Content_Language = Content_Language
    def get_Content_Length(self): return self.Content_Length
    def set_Content_Length(self, Content_Length): self.Content_Length = Content_Length
    def get_Content_Location(self): return self.Content_Location
    def set_Content_Location(self, Content_Location): self.Content_Location = Content_Location
    def get_Content_MD5(self): return self.Content_MD5
    def set_Content_MD5(self, Content_MD5): self.Content_MD5 = Content_MD5
    def get_Content_Disposition(self): return self.Content_Disposition
    def set_Content_Disposition(self, Content_Disposition): self.Content_Disposition = Content_Disposition
    def get_Content_Range(self): return self.Content_Range
    def set_Content_Range(self, Content_Range): self.Content_Range = Content_Range
    def get_Content_Type(self): return self.Content_Type
    def set_Content_Type(self, Content_Type): self.Content_Type = Content_Type
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_ETag(self): return self.ETag
    def set_ETag(self, ETag): self.ETag = ETag
    def get_Expires(self): return self.Expires
    def set_Expires(self, Expires): self.Expires = Expires
    def get_Last_Modified(self): return self.Last_Modified
    def set_Last_Modified(self, Last_Modified): self.Last_Modified = Last_Modified
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_P3P(self): return self.P3P
    def set_P3P(self, P3P): self.P3P = P3P
    def get_Pragma(self): return self.Pragma
    def set_Pragma(self, Pragma): self.Pragma = Pragma
    def get_Proxy_Authenticate(self): return self.Proxy_Authenticate
    def set_Proxy_Authenticate(self, Proxy_Authenticate): self.Proxy_Authenticate = Proxy_Authenticate
    def get_Refresh(self): return self.Refresh
    def set_Refresh(self, Refresh): self.Refresh = Refresh
    def get_Retry_After(self): return self.Retry_After
    def set_Retry_After(self, Retry_After): self.Retry_After = Retry_After
    def get_Server(self): return self.Server
    def set_Server(self, Server): self.Server = Server
    def get_Set_Cookie(self): return self.Set_Cookie
    def set_Set_Cookie(self, Set_Cookie): self.Set_Cookie = Set_Cookie
    def get_Strict_Transport_Security(self): return self.Strict_Transport_Security
    def set_Strict_Transport_Security(self, Strict_Transport_Security): self.Strict_Transport_Security = Strict_Transport_Security
    def get_Trailer(self): return self.Trailer
    def set_Trailer(self, Trailer): self.Trailer = Trailer
    def get_Transfer_Encoding(self): return self.Transfer_Encoding
    def set_Transfer_Encoding(self, Transfer_Encoding): self.Transfer_Encoding = Transfer_Encoding
    def get_Vary(self): return self.Vary
    def set_Vary(self, Vary): self.Vary = Vary
    def get_Via(self): return self.Via
    def set_Via(self, Via): self.Via = Via
    def get_Warning(self): return self.Warning
    def set_Warning(self, Warning): self.Warning = Warning
    def get_WWW_Authenticate(self): return self.WWW_Authenticate
    def set_WWW_Authenticate(self, WWW_Authenticate): self.WWW_Authenticate = WWW_Authenticate
    def get_X_Frame_Options(self): return self.X_Frame_Options
    def set_X_Frame_Options(self, X_Frame_Options): self.X_Frame_Options = X_Frame_Options
    def get_X_XSS_Protection(self): return self.X_XSS_Protection
    def set_X_XSS_Protection(self, X_XSS_Protection): self.X_XSS_Protection = X_XSS_Protection
    def get_X_Content_Type_Options(self): return self.X_Content_Type_Options
    def set_X_Content_Type_Options(self, X_Content_Type_Options): self.X_Content_Type_Options = X_Content_Type_Options
    def get_X_Forwarded_Proto(self): return self.X_Forwarded_Proto
    def set_X_Forwarded_Proto(self, X_Forwarded_Proto): self.X_Forwarded_Proto = X_Forwarded_Proto
    def get_X_Powered_By(self): return self.X_Powered_By
    def set_X_Powered_By(self, X_Powered_By): self.X_Powered_By = X_Powered_By
    def get_X_UA_Compatible(self): return self.X_UA_Compatible
    def set_X_UA_Compatible(self, X_UA_Compatible): self.X_UA_Compatible = X_UA_Compatible
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def validate_IntegerObjectPropertyType(self, value):
        # Validate type IntegerObjectPropertyType, a restriction on None.
        pass
    def validate_DateTimeObjectPropertyType(self, value):
        # Validate type DateTimeObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Access_Control_Allow_Origin is not None or
            self.Accept_Ranges is not None or
            self.Age is not None or
            self.Cache_Control is not None or
            self.Connection is not None or
            self.Content_Encoding is not None or
            self.Content_Language is not None or
            self.Content_Length is not None or
            self.Content_Location is not None or
            self.Content_MD5 is not None or
            self.Content_Disposition is not None or
            self.Content_Range is not None or
            self.Content_Type is not None or
            self.Date is not None or
            self.ETag is not None or
            self.Expires is not None or
            self.Last_Modified is not None or
            self.Link is not None or
            self.Location is not None or
            self.P3P is not None or
            self.Pragma is not None or
            self.Proxy_Authenticate is not None or
            self.Refresh is not None or
            self.Retry_After is not None or
            self.Server is not None or
            self.Set_Cookie is not None or
            self.Strict_Transport_Security is not None or
            self.Trailer is not None or
            self.Transfer_Encoding is not None or
            self.Vary is not None or
            self.Via is not None or
            self.Warning is not None or
            self.WWW_Authenticate is not None or
            self.X_Frame_Options is not None or
            self.X_XSS_Protection is not None or
            self.X_Content_Type_Options is not None or
            self.X_Forwarded_Proto is not None or
            self.X_Powered_By is not None or
            self.X_UA_Compatible is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPResponseHeaderFieldsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:URIObj="http://cybox.mitre.org/objects#URIObject-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPResponseHeaderFieldsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPResponseHeaderFieldsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPResponseHeaderFieldsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Access_Control_Allow_Origin is not None:
            self.Access_Control_Allow_Origin.export(outfile, level, namespace_, name_='Access_Control_Allow_Origin', pretty_print=pretty_print)
        if self.Accept_Ranges is not None:
            self.Accept_Ranges.export(outfile, level, namespace_, name_='Accept_Ranges', pretty_print=pretty_print)
        if self.Age is not None:
            self.Age.export(outfile, level, namespace_, name_='Age', pretty_print=pretty_print)
        if self.Cache_Control is not None:
            self.Cache_Control.export(outfile, level, namespace_, name_='Cache_Control', pretty_print=pretty_print)
        if self.Connection is not None:
            self.Connection.export(outfile, level, namespace_, name_='Connection', pretty_print=pretty_print)
        if self.Content_Encoding is not None:
            self.Content_Encoding.export(outfile, level, namespace_, name_='Content_Encoding', pretty_print=pretty_print)
        if self.Content_Language is not None:
            self.Content_Language.export(outfile, level, namespace_, name_='Content_Language', pretty_print=pretty_print)
        if self.Content_Length is not None:
            self.Content_Length.export(outfile, level, namespace_, name_='Content_Length', pretty_print=pretty_print)
        if self.Content_Location is not None:
            self.Content_Location.export(outfile, level, namespace_, name_='Content_Location', pretty_print=pretty_print)
        if self.Content_MD5 is not None:
            self.Content_MD5.export(outfile, level, namespace_, name_='Content_MD5', pretty_print=pretty_print)
        if self.Content_Disposition is not None:
            self.Content_Disposition.export(outfile, level, namespace_, name_='Content_Disposition', pretty_print=pretty_print)
        if self.Content_Range is not None:
            self.Content_Range.export(outfile, level, namespace_, name_='Content_Range', pretty_print=pretty_print)
        if self.Content_Type is not None:
            self.Content_Type.export(outfile, level, namespace_, name_='Content_Type', pretty_print=pretty_print)
        if self.Date is not None:
            self.Date.export(outfile, level, namespace_, name_='Date', pretty_print=pretty_print)
        if self.ETag is not None:
            self.ETag.export(outfile, level, namespace_, name_='ETag', pretty_print=pretty_print)
        if self.Expires is not None:
            self.Expires.export(outfile, level, namespace_, name_='Expires', pretty_print=pretty_print)
        if self.Last_Modified is not None:
            self.Last_Modified.export(outfile, level, namespace_, name_='Last_Modified', pretty_print=pretty_print)
        if self.Link is not None:
            self.Link.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location', pretty_print=pretty_print)
        if self.P3P is not None:
            self.P3P.export(outfile, level, namespace_, name_='P3P', pretty_print=pretty_print)
        if self.Pragma is not None:
            self.Pragma.export(outfile, level, namespace_, name_='Pragma', pretty_print=pretty_print)
        if self.Proxy_Authenticate is not None:
            self.Proxy_Authenticate.export(outfile, level, namespace_, name_='Proxy_Authenticate', pretty_print=pretty_print)
        if self.Refresh is not None:
            self.Refresh.export(outfile, level, namespace_, name_='Refresh', pretty_print=pretty_print)
        if self.Retry_After is not None:
            self.Retry_After.export(outfile, level, namespace_, name_='Retry_After', pretty_print=pretty_print)
        if self.Server is not None:
            self.Server.export(outfile, level, namespace_, name_='Server', pretty_print=pretty_print)
        if self.Set_Cookie is not None:
            self.Set_Cookie.export(outfile, level, namespace_, name_='Set_Cookie', pretty_print=pretty_print)
        if self.Strict_Transport_Security is not None:
            self.Strict_Transport_Security.export(outfile, level, namespace_, name_='Strict_Transport_Security', pretty_print=pretty_print)
        if self.Trailer is not None:
            self.Trailer.export(outfile, level, namespace_, name_='Trailer', pretty_print=pretty_print)
        if self.Transfer_Encoding is not None:
            self.Transfer_Encoding.export(outfile, level, namespace_, name_='Transfer_Encoding', pretty_print=pretty_print)
        if self.Vary is not None:
            self.Vary.export(outfile, level, namespace_, name_='Vary', pretty_print=pretty_print)
        if self.Via is not None:
            self.Via.export(outfile, level, namespace_, name_='Via', pretty_print=pretty_print)
        if self.Warning is not None:
            self.Warning.export(outfile, level, namespace_, name_='Warning', pretty_print=pretty_print)
        if self.WWW_Authenticate is not None:
            self.WWW_Authenticate.export(outfile, level, namespace_, name_='WWW_Authenticate', pretty_print=pretty_print)
        if self.X_Frame_Options is not None:
            self.X_Frame_Options.export(outfile, level, namespace_, name_='X_Frame_Options', pretty_print=pretty_print)
        if self.X_XSS_Protection is not None:
            self.X_XSS_Protection.export(outfile, level, namespace_, name_='X_XSS_Protection', pretty_print=pretty_print)
        if self.X_Content_Type_Options is not None:
            self.X_Content_Type_Options.export(outfile, level, namespace_, name_='X_Content_Type_Options', pretty_print=pretty_print)
        if self.X_Forwarded_Proto is not None:
            self.X_Forwarded_Proto.export(outfile, level, namespace_, name_='X_Forwarded_Proto', pretty_print=pretty_print)
        if self.X_Powered_By is not None:
            self.X_Powered_By.export(outfile, level, namespace_, name_='X_Powered_By', pretty_print=pretty_print)
        if self.X_UA_Compatible is not None:
            self.X_UA_Compatible.export(outfile, level, namespace_, name_='X_UA_Compatible', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPResponseHeaderFieldsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Access_Control_Allow_Origin is not None:
            showIndent(outfile, level)
            outfile.write('Access_Control_Allow_Origin=model_.StringObjectPropertyType(\n')
            self.Access_Control_Allow_Origin.exportLiteral(outfile, level, name_='Access_Control_Allow_Origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accept_Ranges is not None:
            showIndent(outfile, level)
            outfile.write('Accept_Ranges=model_.StringObjectPropertyType(\n')
            self.Accept_Ranges.exportLiteral(outfile, level, name_='Accept_Ranges')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Age is not None:
            showIndent(outfile, level)
            outfile.write('Age=model_.IntegerObjectPropertyType(\n')
            self.Age.exportLiteral(outfile, level, name_='Age')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Cache_Control is not None:
            showIndent(outfile, level)
            outfile.write('Cache_Control=model_.StringObjectPropertyType(\n')
            self.Cache_Control.exportLiteral(outfile, level, name_='Cache_Control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Connection is not None:
            showIndent(outfile, level)
            outfile.write('Connection=model_.StringObjectPropertyType(\n')
            self.Connection.exportLiteral(outfile, level, name_='Connection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Encoding is not None:
            showIndent(outfile, level)
            outfile.write('Content_Encoding=model_.StringObjectPropertyType(\n')
            self.Content_Encoding.exportLiteral(outfile, level, name_='Content_Encoding')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Language is not None:
            showIndent(outfile, level)
            outfile.write('Content_Language=model_.StringObjectPropertyType(\n')
            self.Content_Language.exportLiteral(outfile, level, name_='Content_Language')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Length is not None:
            showIndent(outfile, level)
            outfile.write('Content_Length=model_.IntegerObjectPropertyType(\n')
            self.Content_Length.exportLiteral(outfile, level, name_='Content_Length')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Location is not None:
            showIndent(outfile, level)
            outfile.write('Content_Location=model_.StringObjectPropertyType(\n')
            self.Content_Location.exportLiteral(outfile, level, name_='Content_Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_MD5 is not None:
            showIndent(outfile, level)
            outfile.write('Content_MD5=model_.StringObjectPropertyType(\n')
            self.Content_MD5.exportLiteral(outfile, level, name_='Content_MD5')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Disposition is not None:
            showIndent(outfile, level)
            outfile.write('Content_Disposition=model_.StringObjectPropertyType(\n')
            self.Content_Disposition.exportLiteral(outfile, level, name_='Content_Disposition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Range is not None:
            showIndent(outfile, level)
            outfile.write('Content_Range=model_.StringObjectPropertyType(\n')
            self.Content_Range.exportLiteral(outfile, level, name_='Content_Range')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_Type is not None:
            showIndent(outfile, level)
            outfile.write('Content_Type=model_.StringObjectPropertyType(\n')
            self.Content_Type.exportLiteral(outfile, level, name_='Content_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=model_.DateTimeObjectPropertyType(\n')
            self.Date.exportLiteral(outfile, level, name_='Date')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ETag is not None:
            showIndent(outfile, level)
            outfile.write('ETag=model_.StringObjectPropertyType(\n')
            self.ETag.exportLiteral(outfile, level, name_='ETag')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Expires is not None:
            showIndent(outfile, level)
            outfile.write('Expires=model_.DateTimeObjectPropertyType(\n')
            self.Expires.exportLiteral(outfile, level, name_='Expires')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Last_Modified is not None:
            showIndent(outfile, level)
            outfile.write('Last_Modified=model_.DateTimeObjectPropertyType(\n')
            self.Last_Modified.exportLiteral(outfile, level, name_='Last_Modified')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Link is not None:
            showIndent(outfile, level)
            outfile.write('Link=model_.StringObjectPropertyType(\n')
            self.Link.exportLiteral(outfile, level, name_='Link')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.URIObjectType(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.P3P is not None:
            showIndent(outfile, level)
            outfile.write('P3P=model_.StringObjectPropertyType(\n')
            self.P3P.exportLiteral(outfile, level, name_='P3P')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Pragma is not None:
            showIndent(outfile, level)
            outfile.write('Pragma=model_.StringObjectPropertyType(\n')
            self.Pragma.exportLiteral(outfile, level, name_='Pragma')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Proxy_Authenticate is not None:
            showIndent(outfile, level)
            outfile.write('Proxy_Authenticate=model_.StringObjectPropertyType(\n')
            self.Proxy_Authenticate.exportLiteral(outfile, level, name_='Proxy_Authenticate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Refresh is not None:
            showIndent(outfile, level)
            outfile.write('Refresh=model_.IntegerObjectPropertyType(\n')
            self.Refresh.exportLiteral(outfile, level, name_='Refresh')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Retry_After is not None:
            showIndent(outfile, level)
            outfile.write('Retry_After=model_.IntegerObjectPropertyType(\n')
            self.Retry_After.exportLiteral(outfile, level, name_='Retry_After')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Server is not None:
            showIndent(outfile, level)
            outfile.write('Server=model_.StringObjectPropertyType(\n')
            self.Server.exportLiteral(outfile, level, name_='Server')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Set_Cookie is not None:
            showIndent(outfile, level)
            outfile.write('Set_Cookie=model_.StringObjectPropertyType(\n')
            self.Set_Cookie.exportLiteral(outfile, level, name_='Set_Cookie')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Strict_Transport_Security is not None:
            showIndent(outfile, level)
            outfile.write('Strict_Transport_Security=model_.StringObjectPropertyType(\n')
            self.Strict_Transport_Security.exportLiteral(outfile, level, name_='Strict_Transport_Security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Trailer is not None:
            showIndent(outfile, level)
            outfile.write('Trailer=model_.StringObjectPropertyType(\n')
            self.Trailer.exportLiteral(outfile, level, name_='Trailer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Transfer_Encoding is not None:
            showIndent(outfile, level)
            outfile.write('Transfer_Encoding=model_.StringObjectPropertyType(\n')
            self.Transfer_Encoding.exportLiteral(outfile, level, name_='Transfer_Encoding')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vary is not None:
            showIndent(outfile, level)
            outfile.write('Vary=model_.URIObjectType(\n')
            self.Vary.exportLiteral(outfile, level, name_='Vary')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Via is not None:
            showIndent(outfile, level)
            outfile.write('Via=model_.StringObjectPropertyType(\n')
            self.Via.exportLiteral(outfile, level, name_='Via')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Warning is not None:
            showIndent(outfile, level)
            outfile.write('Warning=model_.StringObjectPropertyType(\n')
            self.Warning.exportLiteral(outfile, level, name_='Warning')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.WWW_Authenticate is not None:
            showIndent(outfile, level)
            outfile.write('WWW_Authenticate=model_.StringObjectPropertyType(\n')
            self.WWW_Authenticate.exportLiteral(outfile, level, name_='WWW_Authenticate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_Frame_Options is not None:
            showIndent(outfile, level)
            outfile.write('X_Frame_Options=model_.StringObjectPropertyType(\n')
            self.X_Frame_Options.exportLiteral(outfile, level, name_='X_Frame_Options')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_XSS_Protection is not None:
            showIndent(outfile, level)
            outfile.write('X_XSS_Protection=model_.StringObjectPropertyType(\n')
            self.X_XSS_Protection.exportLiteral(outfile, level, name_='X_XSS_Protection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_Content_Type_Options is not None:
            showIndent(outfile, level)
            outfile.write('X_Content_Type_Options=model_.StringObjectPropertyType(\n')
            self.X_Content_Type_Options.exportLiteral(outfile, level, name_='X_Content_Type_Options')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_Forwarded_Proto is not None:
            showIndent(outfile, level)
            outfile.write('X_Forwarded_Proto=model_.StringObjectPropertyType(\n')
            self.X_Forwarded_Proto.exportLiteral(outfile, level, name_='X_Forwarded_Proto')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_Powered_By is not None:
            showIndent(outfile, level)
            outfile.write('X_Powered_By=model_.StringObjectPropertyType(\n')
            self.X_Powered_By.exportLiteral(outfile, level, name_='X_Powered_By')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X_UA_Compatible is not None:
            showIndent(outfile, level)
            outfile.write('X_UA_Compatible=model_.StringObjectPropertyType(\n')
            self.X_UA_Compatible.exportLiteral(outfile, level, name_='X_UA_Compatible')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Access_Control_Allow_Origin':
            obj_ = None
            self.Access_Control_Allow_Origin = obj_
            self.validate_StringObjectPropertyType(self.Access_Control_Allow_Origin)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Accept_Ranges':
            obj_ = None
            self.Accept_Ranges = obj_
            self.validate_StringObjectPropertyType(self.Accept_Ranges)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Age':
            obj_ = None
            self.Age = obj_
            self.validate_IntegerObjectPropertyType(self.Age)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Cache_Control':
            obj_ = None
            self.Cache_Control = obj_
            self.validate_StringObjectPropertyType(self.Cache_Control)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Connection':
            obj_ = None
            self.Connection = obj_
            self.validate_StringObjectPropertyType(self.Connection)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_Encoding':
            obj_ = None
            self.Content_Encoding = obj_
            self.validate_StringObjectPropertyType(self.Content_Encoding)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_Language':
            obj_ = None
            self.Content_Language = obj_
            self.validate_StringObjectPropertyType(self.Content_Language)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_Length':
            obj_ = None
            self.Content_Length = obj_
            self.validate_IntegerObjectPropertyType(self.Content_Length)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Content_Location':
            obj_ = None
            self.Content_Location = obj_
            self.validate_StringObjectPropertyType(self.Content_Location)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_MD5':
            obj_ = None
            self.Content_MD5 = obj_
            self.validate_StringObjectPropertyType(self.Content_MD5)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_Disposition':
            obj_ = None
            self.Content_Disposition = obj_
            self.validate_StringObjectPropertyType(self.Content_Disposition)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_Range':
            obj_ = None
            self.Content_Range = obj_
            self.validate_StringObjectPropertyType(self.Content_Range)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Content_Type':
            obj_ = None
            self.Content_Type = obj_
            self.validate_StringObjectPropertyType(self.Content_Type)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Date':
            obj_ = None
            self.Date = obj_
            self.validate_DateTimeObjectPropertyType(self.Date)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'ETag':
            obj_ = None
            self.ETag = obj_
            self.validate_StringObjectPropertyType(self.ETag)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Expires':
            obj_ = None
            self.Expires = obj_
            self.validate_DateTimeObjectPropertyType(self.Expires)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'Last_Modified':
            obj_ = None
            self.Last_Modified = obj_
            self.validate_DateTimeObjectPropertyType(self.Last_Modified)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'Link':
            obj_ = None
            self.Link = obj_
            self.validate_StringObjectPropertyType(self.Link)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Location':
            obj_ = URIObjectType.factory()
            obj_.build(child_)
            self.Location = obj_
        elif nodeName_ == 'P3P':
            obj_ = None
            self.P3P = obj_
            self.validate_StringObjectPropertyType(self.P3P)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Pragma':
            obj_ = None
            self.Pragma = obj_
            self.validate_StringObjectPropertyType(self.Pragma)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Proxy_Authenticate':
            obj_ = None
            self.Proxy_Authenticate = obj_
            self.validate_StringObjectPropertyType(self.Proxy_Authenticate)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Refresh':
            obj_ = None
            self.Refresh = obj_
            self.validate_IntegerObjectPropertyType(self.Refresh)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Retry_After':
            obj_ = None
            self.Retry_After = obj_
            self.validate_IntegerObjectPropertyType(self.Retry_After)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Server':
            obj_ = None
            self.Server = obj_
            self.validate_StringObjectPropertyType(self.Server)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Set_Cookie':
            obj_ = None
            self.Set_Cookie = obj_
            self.validate_StringObjectPropertyType(self.Set_Cookie)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Strict_Transport_Security':
            obj_ = None
            self.Strict_Transport_Security = obj_
            self.validate_StringObjectPropertyType(self.Strict_Transport_Security)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Trailer':
            obj_ = None
            self.Trailer = obj_
            self.validate_StringObjectPropertyType(self.Trailer)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Transfer_Encoding':
            obj_ = None
            self.Transfer_Encoding = obj_
            self.validate_StringObjectPropertyType(self.Transfer_Encoding)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Vary':
            obj_ = URIObjectType.factory()
            obj_.build(child_)
            self.Vary = obj_
        elif nodeName_ == 'Via':
            obj_ = None
            self.Via = obj_
            self.validate_StringObjectPropertyType(self.Via)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Warning':
            obj_ = None
            self.Warning = obj_
            self.validate_StringObjectPropertyType(self.Warning)    # validate type StringObjectPropertyType
        elif nodeName_ == 'WWW_Authenticate':
            obj_ = None
            self.WWW_Authenticate = obj_
            self.validate_StringObjectPropertyType(self.WWW_Authenticate)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_Frame_Options':
            obj_ = None
            self.X_Frame_Options = obj_
            self.validate_StringObjectPropertyType(self.X_Frame_Options)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_XSS_Protection':
            obj_ = None
            self.X_XSS_Protection = obj_
            self.validate_StringObjectPropertyType(self.X_XSS_Protection)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_Content_Type_Options':
            obj_ = None
            self.X_Content_Type_Options = obj_
            self.validate_StringObjectPropertyType(self.X_Content_Type_Options)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_Forwarded_Proto':
            obj_ = None
            self.X_Forwarded_Proto = obj_
            self.validate_StringObjectPropertyType(self.X_Forwarded_Proto)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_Powered_By':
            obj_ = None
            self.X_Powered_By = obj_
            self.validate_StringObjectPropertyType(self.X_Powered_By)    # validate type StringObjectPropertyType
        elif nodeName_ == 'X_UA_Compatible':
            obj_ = None
            self.X_UA_Compatible = obj_
            self.validate_StringObjectPropertyType(self.X_UA_Compatible)    # validate type StringObjectPropertyType
# end class HTTPResponseHeaderFieldsType


class HTTPMessageType(GeneratedsSuper):
    """The HTTPMessageType captures a single HTTP message body and its
    length."""
    subclass = None
    superclass = None
    def __init__(self, Length=None, Message_Body=None):
        self.Length = Length
        self.Message_Body = Message_Body
    def factory(*args_, **kwargs_):
        if HTTPMessageType.subclass:
            return HTTPMessageType.subclass(*args_, **kwargs_)
        else:
            return HTTPMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_Message_Body(self): return self.Message_Body
    def set_Message_Body(self, Message_Body): self.Message_Body = Message_Body
    def validate_PositiveIntegerObjectPropertyType(self, value):
        # Validate type PositiveIntegerObjectPropertyType, a restriction on None.
        pass
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Length is not None or
            self.Message_Body is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPMessageType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPMessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPMessageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPMessageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Length is not None:
            self.Length.export(outfile, level, namespace_, name_='Length', pretty_print=pretty_print)
        if self.Message_Body is not None:
            self.Message_Body.export(outfile, level, namespace_, name_='Message_Body', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPMessageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Length is not None:
            showIndent(outfile, level)
            outfile.write('Length=model_.PositiveIntegerObjectPropertyType(\n')
            self.Length.exportLiteral(outfile, level, name_='Length')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Message_Body is not None:
            showIndent(outfile, level)
            outfile.write('Message_Body=model_.StringObjectPropertyType(\n')
            self.Message_Body.exportLiteral(outfile, level, name_='Message_Body')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Length':
            obj_ = None
            self.Length = obj_
            self.validate_PositiveIntegerObjectPropertyType(self.Length)    # validate type PositiveIntegerObjectPropertyType
        elif nodeName_ == 'Message_Body':
            obj_ = None
            self.Message_Body = obj_
            self.validate_StringObjectPropertyType(self.Message_Body)    # validate type StringObjectPropertyType
# end class HTTPMessageType


class HTTPStatusLineType(GeneratedsSuper):
    """The HTTPStatusLineType captures a single HTTP response status line."""
    subclass = None
    superclass = None
    def __init__(self, Version=None, Status_Code=None, Reason_Phrase=None):
        self.Version = Version
        self.Status_Code = Status_Code
        self.Reason_Phrase = Reason_Phrase
    def factory(*args_, **kwargs_):
        if HTTPStatusLineType.subclass:
            return HTTPStatusLineType.subclass(*args_, **kwargs_)
        else:
            return HTTPStatusLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Status_Code(self): return self.Status_Code
    def set_Status_Code(self, Status_Code): self.Status_Code = Status_Code
    def get_Reason_Phrase(self): return self.Reason_Phrase
    def set_Reason_Phrase(self, Reason_Phrase): self.Reason_Phrase = Reason_Phrase
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def validate_PositiveIntegerObjectPropertyType(self, value):
        # Validate type PositiveIntegerObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Version is not None or
            self.Status_Code is not None or
            self.Reason_Phrase is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPStatusLineType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPStatusLineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPStatusLineType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPStatusLineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.Status_Code is not None:
            self.Status_Code.export(outfile, level, namespace_, name_='Status_Code', pretty_print=pretty_print)
        if self.Reason_Phrase is not None:
            self.Reason_Phrase.export(outfile, level, namespace_, name_='Reason_Phrase', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HTTPStatusLineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=model_.StringObjectPropertyType(\n')
            self.Version.exportLiteral(outfile, level, name_='Version')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Status_Code is not None:
            showIndent(outfile, level)
            outfile.write('Status_Code=model_.PositiveIntegerObjectPropertyType(\n')
            self.Status_Code.exportLiteral(outfile, level, name_='Status_Code')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Reason_Phrase is not None:
            showIndent(outfile, level)
            outfile.write('Reason_Phrase=model_.StringObjectPropertyType(\n')
            self.Reason_Phrase.exportLiteral(outfile, level, name_='Reason_Phrase')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Version':
            obj_ = None
            self.Version = obj_
            self.validate_StringObjectPropertyType(self.Version)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Status_Code':
            obj_ = None
            self.Status_Code = obj_
            self.validate_PositiveIntegerObjectPropertyType(self.Status_Code)    # validate type PositiveIntegerObjectPropertyType
        elif nodeName_ == 'Reason_Phrase':
            obj_ = None
            self.Reason_Phrase = obj_
            self.validate_StringObjectPropertyType(self.Reason_Phrase)    # validate type StringObjectPropertyType
# end class HTTPStatusLineType


class HostFieldType(GeneratedsSuper):
    """The HostFieldType captures the details of the HTTP request Host
    header field."""
    subclass = None
    superclass = None
    def __init__(self, Domain_Name=None, Port=None):
        self.Domain_Name = Domain_Name
        self.Port = Port
    def factory(*args_, **kwargs_):
        if HostFieldType.subclass:
            return HostFieldType.subclass(*args_, **kwargs_)
        else:
            return HostFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain_Name(self): return self.Domain_Name
    def set_Domain_Name(self, Domain_Name): self.Domain_Name = Domain_Name
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def hasContent_(self):
        if (
            self.Domain_Name is not None or
            self.Port is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HostFieldType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:URIObj="http://cybox.mitre.org/objects#URIObject-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HostFieldType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HostFieldType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HostFieldType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Domain_Name is not None:
            self.Domain_Name.export(outfile, level, namespace_, name_='Domain_Name', pretty_print=pretty_print)
        if self.Port is not None:
            self.Port.export(outfile, level, namespace_, name_='Port', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HostFieldType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Domain_Name is not None:
            showIndent(outfile, level)
            outfile.write('Domain_Name=model_.URIObjectType(\n')
            self.Domain_Name.exportLiteral(outfile, level, name_='Domain_Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=model_.PortObjectType(\n')
            self.Port.exportLiteral(outfile, level, name_='Port')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain_Name':
            obj_ = URIObjectType.factory()
            obj_.build(child_)
            self.Domain_Name = obj_
        elif nodeName_ == 'Port':
            obj_ = PortObjectType.factory()
            obj_.build(child_)
            self.Port = obj_
# end class HostFieldType


class HTTPMethodType(BaseObjectPropertyType):
    """HTTPMethodType specifies HTTP method types, via a union of the
    HTTPMethodEnum type and the atomic xs:string type. Its base type
    is the CybOX Core BaseObjectPropertyType, for permitting complex
    (i.e. regular-expression based) specifications.This attribute is
    optional and specifies the expected type for the value of the
    specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(HTTPMethodType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if HTTPMethodType.subclass:
            return HTTPMethodType.subclass(*args_, **kwargs_)
        else:
            return HTTPMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(HTTPMethodType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HTTPMethodType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPMethodType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HTTPMethodType'):
        super(HTTPMethodType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HTTPMethodType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HTTPMethodType', fromsubclass_=False, pretty_print=True):
        super(HTTPMethodType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='HTTPMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(HTTPMethodType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HTTPMethodType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(HTTPMethodType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HTTPMethodType


class AddressObjectType(ObjectPropertiesType):
    """The AddressObjectType is intended to characterize cyber
    addresses.The category field specifies the address category that
    is being defined. The is_source field specifies if this is a
    "Source" addressThe is_destination field specifies if this is a
    "Destination" address"""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, category='ipv4-addr', is_source=None, is_destination=None, Address_Value=None, VLAN_Name=None, VLAN_Num=None):
        super(AddressObjectType, self).__init__(object_reference, Custom_Properties, )
        self.category = _cast(None, category)
        self.is_source = _cast(bool, is_source)
        self.is_destination = _cast(bool, is_destination)
        self.Address_Value = Address_Value
        self.VLAN_Name = VLAN_Name
        self.VLAN_Num = VLAN_Num
    def factory(*args_, **kwargs_):
        if AddressObjectType.subclass:
            return AddressObjectType.subclass(*args_, **kwargs_)
        else:
            return AddressObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address_Value(self): return self.Address_Value
    def set_Address_Value(self, Address_Value): self.Address_Value = Address_Value
    def get_VLAN_Name(self): return self.VLAN_Name
    def set_VLAN_Name(self, VLAN_Name): self.VLAN_Name = VLAN_Name
    def get_VLAN_Num(self): return self.VLAN_Num
    def set_VLAN_Num(self, VLAN_Num): self.VLAN_Num = VLAN_Num
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_is_source(self): return self.is_source
    def set_is_source(self, is_source): self.is_source = is_source
    def get_is_destination(self): return self.is_destination
    def set_is_destination(self, is_destination): self.is_destination = is_destination
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def validate_IntegerObjectPropertyType(self, value):
        # Validate type IntegerObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Address_Value is not None or
            self.VLAN_Name is not None or
            self.VLAN_Num is not None or
            super(AddressObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='AddressObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='AddressObjectType'):
        super(AddressObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AddressObjectType')
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (quote_attrib(self.category), ))
        if self.is_source is not None and 'is_source' not in already_processed:
            already_processed.add('is_source')
            outfile.write(' is_source="%s"' % self.gds_format_boolean(self.is_source, input_name='is_source'))
        if self.is_destination is not None and 'is_destination' not in already_processed:
            already_processed.add('is_destination')
            outfile.write(' is_destination="%s"' % self.gds_format_boolean(self.is_destination, input_name='is_destination'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='AddressObjectType', fromsubclass_=False, pretty_print=True):
        super(AddressObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address_Value is not None:
            self.Address_Value.export(outfile, level, namespace_, name_='Address_Value', pretty_print=pretty_print)
        if self.VLAN_Name is not None:
            self.VLAN_Name.export(outfile, level, namespace_, name_='VLAN_Name', pretty_print=pretty_print)
        if self.VLAN_Num is not None:
            self.VLAN_Num.export(outfile, level, namespace_, name_='VLAN_Num', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AddressObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            showIndent(outfile, level)
            outfile.write('category=%s,\n' % (self.category,))
        if self.is_source is not None and 'is_source' not in already_processed:
            already_processed.add('is_source')
            showIndent(outfile, level)
            outfile.write('is_source=%s,\n' % (self.is_source,))
        if self.is_destination is not None and 'is_destination' not in already_processed:
            already_processed.add('is_destination')
            showIndent(outfile, level)
            outfile.write('is_destination=%s,\n' % (self.is_destination,))
        super(AddressObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AddressObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Address_Value is not None:
            showIndent(outfile, level)
            outfile.write('Address_Value=model_.StringObjectPropertyType(\n')
            self.Address_Value.exportLiteral(outfile, level, name_='Address_Value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VLAN_Name is not None:
            showIndent(outfile, level)
            outfile.write('VLAN_Name=model_.StringObjectPropertyType(\n')
            self.VLAN_Name.exportLiteral(outfile, level, name_='VLAN_Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VLAN_Num is not None:
            showIndent(outfile, level)
            outfile.write('VLAN_Num=model_.IntegerObjectPropertyType(\n')
            self.VLAN_Num.exportLiteral(outfile, level, name_='VLAN_Num')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
        value = find_attr_value_('is_source', node)
        if value is not None and 'is_source' not in already_processed:
            already_processed.add('is_source')
            if value in ('true', '1'):
                self.is_source = True
            elif value in ('false', '0'):
                self.is_source = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('is_destination', node)
        if value is not None and 'is_destination' not in already_processed:
            already_processed.add('is_destination')
            if value in ('true', '1'):
                self.is_destination = True
            elif value in ('false', '0'):
                self.is_destination = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(AddressObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address_Value':
            obj_ = None
            self.Address_Value = obj_
            self.validate_StringObjectPropertyType(self.Address_Value)    # validate type StringObjectPropertyType
        elif nodeName_ == 'VLAN_Name':
            obj_ = None
            self.VLAN_Name = obj_
            self.validate_StringObjectPropertyType(self.VLAN_Name)    # validate type StringObjectPropertyType
        elif nodeName_ == 'VLAN_Num':
            obj_ = None
            self.VLAN_Num = obj_
            self.validate_IntegerObjectPropertyType(self.VLAN_Num)    # validate type IntegerObjectPropertyType
        super(AddressObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class AddressObjectType


class URIObjectType(ObjectPropertiesType):
    """The URIObjectType type is intended to characterize Uniform Resource
    Identifiers (URI's).The type field specifies the type of URI
    that is being defined."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, type_=None, Value=None):
        super(URIObjectType, self).__init__(object_reference, Custom_Properties, )
        self.type_ = _cast(None, type_)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if URIObjectType.subclass:
            return URIObjectType.subclass(*args_, **kwargs_)
        else:
            return URIObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_AnyURIObjectPropertyType(self, value):
        # Validate type AnyURIObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Value is not None or
            super(URIObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='URIObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URIObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='URIObjectType'):
        super(URIObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='URIObjectType')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='URIObjectType', fromsubclass_=False, pretty_print=True):
        super(URIObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            self.Value.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='URIObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % (self.type_,))
        super(URIObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(URIObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=model_.AnyURIObjectPropertyType(\n')
            self.Value.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(URIObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            obj_ = None
            self.Value = obj_
            self.validate_AnyURIObjectPropertyType(self.Value)    # validate type AnyURIObjectPropertyType
        super(URIObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class URIObjectType


class DNSQueryObjectType(ObjectPropertiesType):
    """The DNSQueryType is intended to characterize a single DNS query and
    its components.The successful field specifies whether or not the
    DNS Query was successful."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, successful=None, Question=None, Answer_Resource_Records=None, Authority_Resource_Records=None, Additional_Records=None, Date_Ran=None, Service_Used=None):
        super(DNSQueryObjectType, self).__init__(object_reference, Custom_Properties, )
        self.successful = _cast(bool, successful)
        self.Question = Question
        self.Answer_Resource_Records = Answer_Resource_Records
        self.Authority_Resource_Records = Authority_Resource_Records
        self.Additional_Records = Additional_Records
        self.Date_Ran = Date_Ran
        self.Service_Used = Service_Used
    def factory(*args_, **kwargs_):
        if DNSQueryObjectType.subclass:
            return DNSQueryObjectType.subclass(*args_, **kwargs_)
        else:
            return DNSQueryObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Question(self): return self.Question
    def set_Question(self, Question): self.Question = Question
    def get_Answer_Resource_Records(self): return self.Answer_Resource_Records
    def set_Answer_Resource_Records(self, Answer_Resource_Records): self.Answer_Resource_Records = Answer_Resource_Records
    def get_Authority_Resource_Records(self): return self.Authority_Resource_Records
    def set_Authority_Resource_Records(self, Authority_Resource_Records): self.Authority_Resource_Records = Authority_Resource_Records
    def get_Additional_Records(self): return self.Additional_Records
    def set_Additional_Records(self, Additional_Records): self.Additional_Records = Additional_Records
    def get_Date_Ran(self): return self.Date_Ran
    def set_Date_Ran(self, Date_Ran): self.Date_Ran = Date_Ran
    def get_Service_Used(self): return self.Service_Used
    def set_Service_Used(self, Service_Used): self.Service_Used = Service_Used
    def get_successful(self): return self.successful
    def set_successful(self, successful): self.successful = successful
    def validate_DateTimeObjectPropertyType(self, value):
        # Validate type DateTimeObjectPropertyType, a restriction on None.
        pass
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Question is not None or
            self.Answer_Resource_Records is not None or
            self.Authority_Resource_Records is not None or
            self.Additional_Records is not None or
            self.Date_Ran is not None or
            self.Service_Used is not None or
            super(DNSQueryObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DNSQueryObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DNSQueryObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DNSQueryObjectType'):
        super(DNSQueryObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DNSQueryObjectType')
        if self.successful is not None and 'successful' not in already_processed:
            already_processed.add('successful')
            outfile.write(' successful="%s"' % self.gds_format_boolean(self.successful, input_name='successful'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DNSQueryObjectType', fromsubclass_=False, pretty_print=True):
        super(DNSQueryObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Question is not None:
            self.Question.export(outfile, level, namespace_, name_='Question', pretty_print=pretty_print)
        if self.Answer_Resource_Records is not None:
            self.Answer_Resource_Records.export(outfile, level, namespace_, name_='Answer_Resource_Records', pretty_print=pretty_print)
        if self.Authority_Resource_Records is not None:
            self.Authority_Resource_Records.export(outfile, level, namespace_, name_='Authority_Resource_Records', pretty_print=pretty_print)
        if self.Additional_Records is not None:
            self.Additional_Records.export(outfile, level, namespace_, name_='Additional_Records', pretty_print=pretty_print)
        if self.Date_Ran is not None:
            self.Date_Ran.export(outfile, level, namespace_, name_='Date_Ran', pretty_print=pretty_print)
        if self.Service_Used is not None:
            self.Service_Used.export(outfile, level, namespace_, name_='Service_Used', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DNSQueryObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.successful is not None and 'successful' not in already_processed:
            already_processed.add('successful')
            showIndent(outfile, level)
            outfile.write('successful=%s,\n' % (self.successful,))
        super(DNSQueryObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DNSQueryObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Question is not None:
            showIndent(outfile, level)
            outfile.write('Question=model_.DNSQuestionType(\n')
            self.Question.exportLiteral(outfile, level, name_='Question')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Answer_Resource_Records is not None:
            showIndent(outfile, level)
            outfile.write('Answer_Resource_Records=model_.DNSResourceRecordsType(\n')
            self.Answer_Resource_Records.exportLiteral(outfile, level, name_='Answer_Resource_Records')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Authority_Resource_Records is not None:
            showIndent(outfile, level)
            outfile.write('Authority_Resource_Records=model_.DNSResourceRecordsType(\n')
            self.Authority_Resource_Records.exportLiteral(outfile, level, name_='Authority_Resource_Records')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Additional_Records is not None:
            showIndent(outfile, level)
            outfile.write('Additional_Records=model_.DNSResourceRecordsType(\n')
            self.Additional_Records.exportLiteral(outfile, level, name_='Additional_Records')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Date_Ran is not None:
            showIndent(outfile, level)
            outfile.write('Date_Ran=model_.DateTimeObjectPropertyType(\n')
            self.Date_Ran.exportLiteral(outfile, level, name_='Date_Ran')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Service_Used is not None:
            showIndent(outfile, level)
            outfile.write('Service_Used=model_.StringObjectPropertyType(\n')
            self.Service_Used.exportLiteral(outfile, level, name_='Service_Used')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('successful', node)
        if value is not None and 'successful' not in already_processed:
            already_processed.add('successful')
            if value in ('true', '1'):
                self.successful = True
            elif value in ('false', '0'):
                self.successful = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(DNSQueryObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Question':
            obj_ = DNSQuestionType.factory()
            obj_.build(child_)
            self.Question = obj_
        elif nodeName_ == 'Answer_Resource_Records':
            obj_ = DNSResourceRecordsType.factory()
            obj_.build(child_)
            self.Answer_Resource_Records = obj_
        elif nodeName_ == 'Authority_Resource_Records':
            obj_ = DNSResourceRecordsType.factory()
            obj_.build(child_)
            self.Authority_Resource_Records = obj_
        elif nodeName_ == 'Additional_Records':
            obj_ = DNSResourceRecordsType.factory()
            obj_.build(child_)
            self.Additional_Records = obj_
        elif nodeName_ == 'Date_Ran':
            obj_ = None
            self.Date_Ran = obj_
            self.validate_DateTimeObjectPropertyType(self.Date_Ran)    # validate type DateTimeObjectPropertyType
        elif nodeName_ == 'Service_Used':
            obj_ = None
            self.Service_Used = obj_
            self.validate_StringObjectPropertyType(self.Service_Used)    # validate type StringObjectPropertyType
        super(DNSQueryObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class DNSQueryObjectType


class DNSQuestionType(GeneratedsSuper):
    """The DNSQuestionType specifies the components of a DNS Question,
    including the domain name queried, type, and class."""
    subclass = None
    superclass = None
    def __init__(self, QName=None, QType=None, QClass=None):
        self.QName = QName
        self.QType = QType
        self.QClass = QClass
    def factory(*args_, **kwargs_):
        if DNSQuestionType.subclass:
            return DNSQuestionType.subclass(*args_, **kwargs_)
        else:
            return DNSQuestionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QName(self): return self.QName
    def set_QName(self, QName): self.QName = QName
    def get_QType(self): return self.QType
    def set_QType(self, QType): self.QType = QType
    def get_QClass(self): return self.QClass
    def set_QClass(self, QClass): self.QClass = QClass
    def validate_DNSRecordType(self, value):
        # Validate type DNSRecordType, a restriction on None.
        pass
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.QName is not None or
            self.QType is not None or
            self.QClass is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DNSQuestionType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:URIObj="http://cybox.mitre.org/objects#URIObject-2"  xmlns:cyboxCommon="http://cybox.mitre.org/common-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DNSQuestionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DNSQuestionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DNSQuestionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.QName is not None:
            self.QName.export(outfile, level, namespace_, name_='QName', pretty_print=pretty_print)
        if self.QType is not None:
            self.QType.export(outfile, level, namespace_, name_='QType', pretty_print=pretty_print)
        if self.QClass is not None:
            self.QClass.export(outfile, level, namespace_, name_='QClass', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DNSQuestionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.QName is not None:
            showIndent(outfile, level)
            outfile.write('QName=model_.URIObjectType(\n')
            self.QName.exportLiteral(outfile, level, name_='QName')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QType is not None:
            showIndent(outfile, level)
            outfile.write('QType=model_.DNSRecordType(\n')
            self.QType.exportLiteral(outfile, level, name_='QType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QClass is not None:
            showIndent(outfile, level)
            outfile.write('QClass=model_.StringObjectPropertyType(\n')
            self.QClass.exportLiteral(outfile, level, name_='QClass')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QName':
            obj_ = URIObjectType.factory()
            obj_.build(child_)
            self.QName = obj_
        elif nodeName_ == 'QType':
            obj_ = None
            self.QType = obj_
            self.validate_DNSRecordType(self.QType)    # validate type DNSRecordType
        elif nodeName_ == 'QClass':
            obj_ = None
            self.QClass = obj_
            self.validate_StringObjectPropertyType(self.QClass)    # validate type StringObjectPropertyType
# end class DNSQuestionType


class DNSResourceRecordsType(GeneratedsSuper):
    """The DNSAnswersType encompasses one or more resource records returned
    for a DNS query."""
    subclass = None
    superclass = None
    def __init__(self, Resource_Record=None):
        if Resource_Record is None:
            self.Resource_Record = []
        else:
            self.Resource_Record = Resource_Record
    def factory(*args_, **kwargs_):
        if DNSResourceRecordsType.subclass:
            return DNSResourceRecordsType.subclass(*args_, **kwargs_)
        else:
            return DNSResourceRecordsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Resource_Record(self): return self.Resource_Record
    def set_Resource_Record(self, Resource_Record): self.Resource_Record = Resource_Record
    def add_Resource_Record(self, value): self.Resource_Record.append(value)
    def insert_Resource_Record(self, index, value): self.Resource_Record[index] = value
    def hasContent_(self):
        if (
            self.Resource_Record
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DNSResourceRecordsType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DNSResourceRecordsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DNSResourceRecordsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DNSResourceRecordsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Resource_Record_ in self.Resource_Record:
            Resource_Record_.export(outfile, level, namespace_, name_='Resource_Record', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DNSResourceRecordsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Resource_Record=[\n')
        level += 1
        for Resource_Record_ in self.Resource_Record:
            showIndent(outfile, level)
            outfile.write('model_.DNSRecordObjectType(\n')
            Resource_Record_.exportLiteral(outfile, level, name_='DNSRecordObjectType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Resource_Record':
            obj_ = DNSRecordObjectType.factory()
            obj_.build(child_)
            self.Resource_Record.append(obj_)
# end class DNSResourceRecordsType


class DNSRecordType(BaseObjectPropertyType):
    """DNSRecordType specifies DNS record types, via a union of the
    DNSRecordTypeEnum type and the atomic xs:string type. Its base
    type is the CybOX Core BaseObjectPropertyType, for permitting
    complex (i.e. regular-expression based) specifications.This
    attribute is optional and specifies the expected type for the
    value of the specified property."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, valueOf_=None):
        super(DNSRecordType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DNSRecordType.subclass:
            return DNSRecordType.subclass(*args_, **kwargs_)
        else:
            return DNSRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DNSRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DNSRecordType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DNSRecordType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DNSRecordType'):
        super(DNSRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DNSRecordType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DNSRecordType', fromsubclass_=False, pretty_print=True):
        super(DNSRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DNSRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype=%s,\n' % (self.datatype,))
        super(DNSRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DNSRecordType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(DNSRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DNSRecordType


class DNSRecordObjectType(ObjectPropertiesType):
    """The DNSRecordObjectType type is intended to characterize an
    individual DNS record."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, Description=None, Domain_Name=None, IP_Address=None, Address_Class=None, Entry_Type=None, Record_Name=None, Record_Type=None, TTL=None, Flags=None, Data_Length=None, Record_Data=None):
        super(DNSRecordObjectType, self).__init__(object_reference, Custom_Properties, )
        self.Description = Description
        self.Domain_Name = Domain_Name
        self.IP_Address = IP_Address
        self.Address_Class = Address_Class
        self.Entry_Type = Entry_Type
        self.Record_Name = Record_Name
        self.Record_Type = Record_Type
        self.TTL = TTL
        self.Flags = Flags
        self.Data_Length = Data_Length
        self.Record_Data = Record_Data
    def factory(*args_, **kwargs_):
        if DNSRecordObjectType.subclass:
            return DNSRecordObjectType.subclass(*args_, **kwargs_)
        else:
            return DNSRecordObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Domain_Name(self): return self.Domain_Name
    def set_Domain_Name(self, Domain_Name): self.Domain_Name = Domain_Name
    def get_IP_Address(self): return self.IP_Address
    def set_IP_Address(self, IP_Address): self.IP_Address = IP_Address
    def get_Address_Class(self): return self.Address_Class
    def set_Address_Class(self, Address_Class): self.Address_Class = Address_Class
    def get_Entry_Type(self): return self.Entry_Type
    def set_Entry_Type(self, Entry_Type): self.Entry_Type = Entry_Type
    def get_Record_Name(self): return self.Record_Name
    def set_Record_Name(self, Record_Name): self.Record_Name = Record_Name
    def get_Record_Type(self): return self.Record_Type
    def set_Record_Type(self, Record_Type): self.Record_Type = Record_Type
    def get_TTL(self): return self.TTL
    def set_TTL(self, TTL): self.TTL = TTL
    def get_Flags(self): return self.Flags
    def set_Flags(self, Flags): self.Flags = Flags
    def get_Data_Length(self): return self.Data_Length
    def set_Data_Length(self, Data_Length): self.Data_Length = Data_Length
    def get_Record_Data(self): return self.Record_Data
    def set_Record_Data(self, Record_Data): self.Record_Data = Record_Data
    def validate_StringObjectPropertyType(self, value):
        # Validate type StringObjectPropertyType, a restriction on None.
        pass
    def validate_IntegerObjectPropertyType(self, value):
        # Validate type IntegerObjectPropertyType, a restriction on None.
        pass
    def validate_HexBinaryObjectPropertyType(self, value):
        # Validate type HexBinaryObjectPropertyType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Domain_Name is not None or
            self.IP_Address is not None or
            self.Address_Class is not None or
            self.Entry_Type is not None or
            self.Record_Name is not None or
            self.Record_Type is not None or
            self.TTL is not None or
            self.Flags is not None or
            self.Data_Length is not None or
            self.Record_Data is not None or
            super(DNSRecordObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='DNSRecordObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4" xmlns:cyboxCommon="http://cybox.mitre.org/common-2"  xmlns:URIObj="http://cybox.mitre.org/objects#URIObject-2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DNSRecordObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='DNSRecordObjectType'):
        super(DNSRecordObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DNSRecordObjectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='DNSRecordObjectType', fromsubclass_=False, pretty_print=True):
        super(DNSRecordObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Domain_Name is not None:
            self.Domain_Name.export(outfile, level, namespace_, name_='Domain_Name', pretty_print=pretty_print)
        if self.IP_Address is not None:
            self.IP_Address.export(outfile, level, namespace_, name_='IP_Address', pretty_print=pretty_print)
        if self.Address_Class is not None:
            self.Address_Class.export(outfile, level, namespace_, name_='Address_Class', pretty_print=pretty_print)
        if self.Entry_Type is not None:
            self.Entry_Type.export(outfile, level, namespace_, name_='Entry_Type', pretty_print=pretty_print)
        if self.Record_Name is not None:
            self.Record_Name.export(outfile, level, namespace_, name_='Record_Name', pretty_print=pretty_print)
        if self.Record_Type is not None:
            self.Record_Type.export(outfile, level, namespace_, name_='Record_Type', pretty_print=pretty_print)
        if self.TTL is not None:
            self.TTL.export(outfile, level, namespace_, name_='TTL', pretty_print=pretty_print)
        if self.Flags is not None:
            self.Flags.export(outfile, level, namespace_, name_='Flags', pretty_print=pretty_print)
        if self.Data_Length is not None:
            self.Data_Length.export(outfile, level, namespace_, name_='Data_Length', pretty_print=pretty_print)
        if self.Record_Data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecord_Data>%s</%sRecord_Data>%s' % (namespace_, self.gds_format_string(quote_xml(self.Record_Data).encode(ExternalEncoding), input_name='Record_Data'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DNSRecordObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DNSRecordObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DNSRecordObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.StructuredTextType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Domain_Name is not None:
            showIndent(outfile, level)
            outfile.write('Domain_Name=model_.URIObjectType(\n')
            self.Domain_Name.exportLiteral(outfile, level, name_='Domain_Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IP_Address is not None:
            showIndent(outfile, level)
            outfile.write('IP_Address=model_.AddressObjectType(\n')
            self.IP_Address.exportLiteral(outfile, level, name_='IP_Address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Address_Class is not None:
            showIndent(outfile, level)
            outfile.write('Address_Class=model_.StringObjectPropertyType(\n')
            self.Address_Class.exportLiteral(outfile, level, name_='Address_Class')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Entry_Type is not None:
            showIndent(outfile, level)
            outfile.write('Entry_Type=model_.StringObjectPropertyType(\n')
            self.Entry_Type.exportLiteral(outfile, level, name_='Entry_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Record_Name is not None:
            showIndent(outfile, level)
            outfile.write('Record_Name=model_.StringObjectPropertyType(\n')
            self.Record_Name.exportLiteral(outfile, level, name_='Record_Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Record_Type is not None:
            showIndent(outfile, level)
            outfile.write('Record_Type=model_.StringObjectPropertyType(\n')
            self.Record_Type.exportLiteral(outfile, level, name_='Record_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TTL is not None:
            showIndent(outfile, level)
            outfile.write('TTL=model_.IntegerObjectPropertyType(\n')
            self.TTL.exportLiteral(outfile, level, name_='TTL')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Flags is not None:
            showIndent(outfile, level)
            outfile.write('Flags=model_.HexBinaryObjectPropertyType(\n')
            self.Flags.exportLiteral(outfile, level, name_='Flags')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Data_Length is not None:
            showIndent(outfile, level)
            outfile.write('Data_Length=model_.IntegerObjectPropertyType(\n')
            self.Data_Length.exportLiteral(outfile, level, name_='Data_Length')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Record_Data is not None:
            showIndent(outfile, level)
            outfile.write('Record_Data=%s,\n' % quote_python(self.Record_Data).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DNSRecordObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = StructuredTextType.factory()
            obj_.build(child_)
            self.Description = obj_
        elif nodeName_ == 'Domain_Name':
            obj_ = URIObjectType.factory()
            obj_.build(child_)
            self.Domain_Name = obj_
        elif nodeName_ == 'IP_Address':
            obj_ = AddressObjectType.factory()
            obj_.build(child_)
            self.IP_Address = obj_
        elif nodeName_ == 'Address_Class':
            obj_ = None
            self.Address_Class = obj_
            self.validate_StringObjectPropertyType(self.Address_Class)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Entry_Type':
            obj_ = None
            self.Entry_Type = obj_
            self.validate_StringObjectPropertyType(self.Entry_Type)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Record_Name':
            obj_ = None
            self.Record_Name = obj_
            self.validate_StringObjectPropertyType(self.Record_Name)    # validate type StringObjectPropertyType
        elif nodeName_ == 'Record_Type':
            obj_ = None
            self.Record_Type = obj_
            self.validate_StringObjectPropertyType(self.Record_Type)    # validate type StringObjectPropertyType
        elif nodeName_ == 'TTL':
            obj_ = None
            self.TTL = obj_
            self.validate_IntegerObjectPropertyType(self.TTL)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Flags':
            obj_ = None
            self.Flags = obj_
            self.validate_HexBinaryObjectPropertyType(self.Flags)    # validate type HexBinaryObjectPropertyType
        elif nodeName_ == 'Data_Length':
            obj_ = None
            self.Data_Length = obj_
            self.validate_IntegerObjectPropertyType(self.Data_Length)    # validate type IntegerObjectPropertyType
        elif nodeName_ == 'Record_Data':
            Record_Data_ = child_.text
            Record_Data_ = self.gds_validate_string(Record_Data_, node, 'Record_Data')
            self.Record_Data = Record_Data_
        super(DNSRecordObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class DNSRecordObjectType


class SocketAddressObjectType(ObjectPropertiesType):
    """The SocketAddressObjectType specifies an IP address/port number
    pair."""
    subclass = None
    superclass = ObjectPropertiesType
    def __init__(self, object_reference=None, Custom_Properties=None, IP_Address=None, Port=None):
        super(SocketAddressObjectType, self).__init__(object_reference, Custom_Properties, )
        self.IP_Address = IP_Address
        self.Port = Port
    def factory(*args_, **kwargs_):
        if SocketAddressObjectType.subclass:
            return SocketAddressObjectType.subclass(*args_, **kwargs_)
        else:
            return SocketAddressObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IP_Address(self): return self.IP_Address
    def set_IP_Address(self, IP_Address): self.IP_Address = IP_Address
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def hasContent_(self):
        if (
            self.IP_Address is not None or
            self.Port is not None or
            super(SocketAddressObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='SocketAddressObjectType', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SocketAddressObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='SocketAddressObjectType'):
        super(SocketAddressObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SocketAddressObjectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='SocketAddressObjectType', fromsubclass_=False, pretty_print=True):
        super(SocketAddressObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IP_Address is not None:
            self.IP_Address.export(outfile, level, namespace_, name_='IP_Address', pretty_print=pretty_print)
        if self.Port is not None:
            self.Port.export(outfile, level, namespace_, name_='Port', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SocketAddressObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SocketAddressObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SocketAddressObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.IP_Address is not None:
            showIndent(outfile, level)
            outfile.write('IP_Address=model_.AddressObjectType(\n')
            self.IP_Address.exportLiteral(outfile, level, name_='IP_Address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=model_.PortObjectType(\n')
            self.Port.exportLiteral(outfile, level, name_='Port')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SocketAddressObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IP_Address':
            obj_ = AddressObjectType.factory()
            obj_.build(child_)
            self.IP_Address = obj_
        elif nodeName_ == 'Port':
            obj_ = PortObjectType.factory()
            obj_.build(child_)
            self.Port = obj_
        super(SocketAddressObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class SocketAddressObjectType


class ActionTypeVocab_1_0(ControlledVocabularyStringType):
    """The ActionTypeVocab is the default CybOX vocabulary for Action
    Types, captured via the ActionType/Type element in CybOX Core."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(ActionTypeVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ActionTypeVocab_1_0.subclass:
            return ActionTypeVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return ActionTypeVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ActionTypeVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionTypeVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionTypeVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionTypeVocab-1.0'):
        super(ActionTypeVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActionTypeVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionTypeVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(ActionTypeVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActionTypeVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ActionTypeVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActionTypeVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(ActionTypeVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionTypeVocab_1_0


class ActionNameVocab_1_0(ControlledVocabularyStringType):
    """The ActionNameVocab is the default CybOX vocabulary for Action
    Types, captured via the ActionType/Name element in CybOX Core."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(ActionNameVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ActionNameVocab_1_0.subclass:
            return ActionNameVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return ActionNameVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ActionNameVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionNameVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionNameVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionNameVocab-1.0'):
        super(ActionNameVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActionNameVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionNameVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(ActionNameVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActionNameVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ActionNameVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActionNameVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(ActionNameVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionNameVocab_1_0


class ActionArgumentNameVocab_1_0(ControlledVocabularyStringType):
    """The ActionArgumentNameVocab is the default CybOX vocabulary for
    Action Argument Names, captured via the
    ActionArgumentType/Argument_Name element in CybOX Core."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(ActionArgumentNameVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ActionArgumentNameVocab_1_0.subclass:
            return ActionArgumentNameVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return ActionArgumentNameVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ActionArgumentNameVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionArgumentNameVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionArgumentNameVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionArgumentNameVocab-1.0'):
        super(ActionArgumentNameVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActionArgumentNameVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionArgumentNameVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(ActionArgumentNameVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActionArgumentNameVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ActionArgumentNameVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActionArgumentNameVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(ActionArgumentNameVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionArgumentNameVocab_1_0


class ActionObjectAssociationTypeVocab_1_0(ControlledVocabularyStringType):
    """The ActionObjectAssocationVocab is the default CybOX vocabulary for
    Action-Object association types, captured via the
    AssociatedObjectType/Association_Type element in CybOX Core."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(ActionObjectAssociationTypeVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ActionObjectAssociationTypeVocab_1_0.subclass:
            return ActionObjectAssociationTypeVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return ActionObjectAssociationTypeVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ActionObjectAssociationTypeVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionObjectAssociationTypeVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionObjectAssociationTypeVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionObjectAssociationTypeVocab-1.0'):
        super(ActionObjectAssociationTypeVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActionObjectAssociationTypeVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionObjectAssociationTypeVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(ActionObjectAssociationTypeVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActionObjectAssociationTypeVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ActionObjectAssociationTypeVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActionObjectAssociationTypeVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(ActionObjectAssociationTypeVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionObjectAssociationTypeVocab_1_0


class ActionRelationshipTypeVocab_1_0(ControlledVocabularyStringType):
    """The ActionObjectAssocationVocab is the default CybOX vocabulary for
    Action-Action relationships, captured via the
    ActionRelationshipType/Type element in the CybOX Core."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(ActionRelationshipTypeVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ActionRelationshipTypeVocab_1_0.subclass:
            return ActionRelationshipTypeVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return ActionRelationshipTypeVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ActionRelationshipTypeVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionRelationshipTypeVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionRelationshipTypeVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionRelationshipTypeVocab-1.0'):
        super(ActionRelationshipTypeVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActionRelationshipTypeVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionRelationshipTypeVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(ActionRelationshipTypeVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActionRelationshipTypeVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ActionRelationshipTypeVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActionRelationshipTypeVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(ActionRelationshipTypeVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActionRelationshipTypeVocab_1_0


class EventTypeVocab_1_0(ControlledVocabularyStringType):
    """The EventTypeVocab is the default CybOX vocabulary for Event types,
    captured via the EventType/Type element in the CybOX Core."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(EventTypeVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EventTypeVocab_1_0.subclass:
            return EventTypeVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return EventTypeVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EventTypeVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='EventTypeVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventTypeVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='EventTypeVocab-1.0'):
        super(EventTypeVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EventTypeVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='EventTypeVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(EventTypeVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EventTypeVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(EventTypeVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EventTypeVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(EventTypeVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EventTypeVocab_1_0


class ObjectRelationshipVocab_1_0(ControlledVocabularyStringType):
    """The ObjectRelationshipVocab is the default CybOX vocabulary for
    Object-Object relationships, captured via the
    RelatedObjectType/Relationship element in CybOX Core."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(ObjectRelationshipVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ObjectRelationshipVocab_1_0.subclass:
            return ObjectRelationshipVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return ObjectRelationshipVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ObjectRelationshipVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectRelationshipVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectRelationshipVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectRelationshipVocab-1.0'):
        super(ObjectRelationshipVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectRelationshipVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectRelationshipVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(ObjectRelationshipVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ObjectRelationshipVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ObjectRelationshipVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ObjectRelationshipVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(ObjectRelationshipVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ObjectRelationshipVocab_1_0


class ObjectStateVocab_1_0(ControlledVocabularyStringType):
    """The ObjectStateVocab is the default CybOX vocabulary for Object
    states, captured via the ObjectType/State element in CybOX Core."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(ObjectStateVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ObjectStateVocab_1_0.subclass:
            return ObjectStateVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return ObjectStateVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ObjectStateVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectStateVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectStateVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectStateVocab-1.0'):
        super(ObjectStateVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectStateVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectStateVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(ObjectStateVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ObjectStateVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ObjectStateVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ObjectStateVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(ObjectStateVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ObjectStateVocab_1_0


class CharacterEncodingVocab_1_0(ControlledVocabularyStringType):
    """The CharacterEncodingVocab is the default CybOX vocabulary for
    character encoding, used in the ExtractedStringType/Encoding
    element in CybOX Common."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(CharacterEncodingVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CharacterEncodingVocab_1_0.subclass:
            return CharacterEncodingVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return CharacterEncodingVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CharacterEncodingVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='CharacterEncodingVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CharacterEncodingVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='CharacterEncodingVocab-1.0'):
        super(CharacterEncodingVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CharacterEncodingVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='CharacterEncodingVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(CharacterEncodingVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CharacterEncodingVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(CharacterEncodingVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CharacterEncodingVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(CharacterEncodingVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CharacterEncodingVocab_1_0


class InformationSourceTypeVocab_1_0(ControlledVocabularyStringType):
    """The InformationSourceTypeVocab is the default CybOX vocabulary for
    information source types, used in the
    MeasureSourceType/Information_Source_Type element in CybOX
    Common."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(InformationSourceTypeVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if InformationSourceTypeVocab_1_0.subclass:
            return InformationSourceTypeVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return InformationSourceTypeVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(InformationSourceTypeVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='InformationSourceTypeVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformationSourceTypeVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='InformationSourceTypeVocab-1.0'):
        super(InformationSourceTypeVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InformationSourceTypeVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='InformationSourceTypeVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(InformationSourceTypeVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='InformationSourceTypeVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(InformationSourceTypeVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InformationSourceTypeVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(InformationSourceTypeVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InformationSourceTypeVocab_1_0


class HashNameVocab_1_0(ControlledVocabularyStringType):
    """The HashNameVocab is the default CybOX vocabulary for hashing
    algorithm names, used in the HashType/Type element in CybOX
    Common."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(HashNameVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if HashNameVocab_1_0.subclass:
            return HashNameVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return HashNameVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(HashNameVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='HashNameVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HashNameVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='HashNameVocab-1.0'):
        super(HashNameVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HashNameVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='HashNameVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(HashNameVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='HashNameVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(HashNameVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HashNameVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(HashNameVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HashNameVocab_1_0


class ToolTypeVocab_1_0(ControlledVocabularyStringType):
    """The ToolTypeVocab is the default CybOX vocabulary for tool types,
    used in the MeasureSourceType/Tool_Type element in CybOX Common."""
    subclass = None
    superclass = ControlledVocabularyStringType
    def __init__(self, pattern_type=None, has_changed=None, trend=None, apply_condition='ANY', bit_mask=None, regex_syntax=None, condition=None, vocab_reference=None, vocab_name=None, valueOf_=None):
        super(ToolTypeVocab_1_0, self).__init__(pattern_type, has_changed, trend, apply_condition, bit_mask, regex_syntax, condition, vocab_reference, vocab_name, valueOf_, )
        self.vocab_reference = _cast(None, vocab_reference)
        self.vocab_name = _cast(None, vocab_name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ToolTypeVocab_1_0.subclass:
            return ToolTypeVocab_1_0.subclass(*args_, **kwargs_)
        else:
            return ToolTypeVocab_1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vocab_reference(self): return self.vocab_reference
    def set_vocab_reference(self, vocab_reference): self.vocab_reference = vocab_reference
    def get_vocab_name(self): return self.vocab_name
    def set_vocab_name(self, vocab_name): self.vocab_name = vocab_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ToolTypeVocab_1_0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ToolTypeVocab-1.0', namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToolTypeVocab-1.0')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ToolTypeVocab-1.0'):
        super(ToolTypeVocab_1_0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ToolTypeVocab-1.0')
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            outfile.write(' vocab_reference=%s' % (self.gds_format_string(quote_attrib(self.vocab_reference).encode(ExternalEncoding), input_name='vocab_reference'), ))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            outfile.write(' vocab_name=%s' % (self.gds_format_string(quote_attrib(self.vocab_name).encode(ExternalEncoding), input_name='vocab_name'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ToolTypeVocab-1.0', fromsubclass_=False, pretty_print=True):
        super(ToolTypeVocab_1_0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ToolTypeVocab-1.0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocab_reference is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            showIndent(outfile, level)
            outfile.write('vocab_reference="%s",\n' % (self.vocab_reference,))
        if self.vocab_name is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            showIndent(outfile, level)
            outfile.write('vocab_name="%s",\n' % (self.vocab_name,))
        super(ToolTypeVocab_1_0, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ToolTypeVocab_1_0, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocab_reference', node)
        if value is not None and 'vocab_reference' not in already_processed:
            already_processed.add('vocab_reference')
            self.vocab_reference = value
        value = find_attr_value_('vocab_name', node)
        if value is not None and 'vocab_name' not in already_processed:
            already_processed.add('vocab_name')
            self.vocab_name = value
        super(ToolTypeVocab_1_0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ToolTypeVocab_1_0


class PropertyType(BaseObjectPropertyType):
    """The PropertyType is a type representing the specification of a
    single Object Property.The name field specifies a name for this
    property.A description of what this property represents."""
    subclass = None
    superclass = BaseObjectPropertyType
    def __init__(self, obfuscation_algorithm_ref=None, refanging_transform_type=None, has_changed=None, pattern_type=None, datatype='string', refanging_transform=None, bit_mask=None, appears_random=None, trend=None, defanging_algorithm_ref=None, is_obfuscated=None, regex_syntax=None, apply_condition='ANY', idref=None, is_defanged=None, id=None, condition=None, name=None, description=None, valueOf_=None):
        super(PropertyType, self).__init__(obfuscation_algorithm_ref, refanging_transform_type, has_changed, pattern_type, datatype, refanging_transform, bit_mask, appears_random, trend, defanging_algorithm_ref, is_obfuscated, regex_syntax, apply_condition, idref, is_defanged, id, condition, valueOf_, )
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PropertyType.subclass:
            return PropertyType.subclass(*args_, **kwargs_)
        else:
            return PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(PropertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='PropertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='PropertyType'):
        super(PropertyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='PropertyType', fromsubclass_=False, pretty_print=True):
        super(PropertyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        super(PropertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PropertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        super(PropertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropertyType


class AssociatedObjectType(ObjectType):
    """The AssociatedObjectType is a complex type representing the
    characterization of a cyber observable Object associated with a
    given cyber observable Action."""
    subclass = None
    superclass = ObjectType
    def __init__(self, has_changed=None, idref=None, id=None, State=None, Description=None, Properties=None, Domain_Specific_Object_Properties=None, Related_Objects=None, Defined_Effect=None, Discovery_Method=None, Association_Type=None, Action_Pertinent_Object_Properties=None):
        super(AssociatedObjectType, self).__init__(has_changed, idref, id, State, Description, Properties, Domain_Specific_Object_Properties, Related_Objects, Defined_Effect, Discovery_Method, )
        self.Association_Type = Association_Type
        self.Action_Pertinent_Object_Properties = Action_Pertinent_Object_Properties
    def factory(*args_, **kwargs_):
        if AssociatedObjectType.subclass:
            return AssociatedObjectType.subclass(*args_, **kwargs_)
        else:
            return AssociatedObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Association_Type(self): return self.Association_Type
    def set_Association_Type(self, Association_Type): self.Association_Type = Association_Type
    def get_Action_Pertinent_Object_Properties(self): return self.Action_Pertinent_Object_Properties
    def set_Action_Pertinent_Object_Properties(self, Action_Pertinent_Object_Properties): self.Action_Pertinent_Object_Properties = Action_Pertinent_Object_Properties
    def hasContent_(self):
        if (
            self.Association_Type is not None or
            self.Action_Pertinent_Object_Properties is not None or
            super(AssociatedObjectType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='AssociatedObjectType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='AssociatedObjectType'):
        super(AssociatedObjectType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedObjectType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='AssociatedObjectType', fromsubclass_=False, pretty_print=True):
        super(AssociatedObjectType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Association_Type is not None:
            self.Association_Type.export(outfile, level, namespace_, name_='Association_Type', pretty_print=pretty_print)
        if self.Action_Pertinent_Object_Properties is not None:
            self.Action_Pertinent_Object_Properties.export(outfile, level, namespace_, name_='Action_Pertinent_Object_Properties', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AssociatedObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssociatedObjectType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssociatedObjectType, self).exportLiteralChildren(outfile, level, name_)
        if self.Association_Type is not None:
            showIndent(outfile, level)
            outfile.write('Association_Type=model_.ControlledVocabularyStringType(\n')
            self.Association_Type.exportLiteral(outfile, level, name_='Association_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action_Pertinent_Object_Properties is not None:
            showIndent(outfile, level)
            outfile.write('Action_Pertinent_Object_Properties=model_.ActionPertinentObjectPropertiesType(\n')
            self.Action_Pertinent_Object_Properties.exportLiteral(outfile, level, name_='Action_Pertinent_Object_Properties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AssociatedObjectType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Association_Type':
            class_obj_ = self.get_class_obj_(child_, ControlledVocabularyStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Association_Type = obj_
        elif nodeName_ == 'Action_Pertinent_Object_Properties':
            obj_ = ActionPertinentObjectPropertiesType.factory()
            obj_.build(child_)
            self.Action_Pertinent_Object_Properties = obj_
        super(AssociatedObjectType, self).buildChildren(child_, node, nodeName_, True)
# end class AssociatedObjectType


class AVClassificationType(ToolInformationType):
    """The AVClassificationType captures information on AV scanner
    classifications for the malware instance object captured in the
    Bundle or Package."""
    subclass = None
    superclass = ToolInformationType
    def __init__(self, idref=None, id=None, Name=None, Type=None, Description=None, References=None, Vendor=None, Version=None, Service_Pack=None, Tool_Specific_Data=None, Tool_Hashes=None, Tool_Configuration=None, Execution_Environment=None, Errors=None, Metadata=None, Engine_Version=None, Definition_Version=None, Classification_Name=None):
        super(AVClassificationType, self).__init__(idref, id, Name, Type, Description, References, Vendor, Version, Service_Pack, Tool_Specific_Data, Tool_Hashes, Tool_Configuration, Execution_Environment, Errors, Metadata, )
        self.Engine_Version = Engine_Version
        self.Definition_Version = Definition_Version
        self.Classification_Name = Classification_Name
    def factory(*args_, **kwargs_):
        if AVClassificationType.subclass:
            return AVClassificationType.subclass(*args_, **kwargs_)
        else:
            return AVClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Engine_Version(self): return self.Engine_Version
    def set_Engine_Version(self, Engine_Version): self.Engine_Version = Engine_Version
    def get_Definition_Version(self): return self.Definition_Version
    def set_Definition_Version(self, Definition_Version): self.Definition_Version = Definition_Version
    def get_Classification_Name(self): return self.Classification_Name
    def set_Classification_Name(self, Classification_Name): self.Classification_Name = Classification_Name
    def hasContent_(self):
        if (
            self.Engine_Version is not None or
            self.Definition_Version is not None or
            self.Classification_Name is not None or
            super(AVClassificationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='AVClassificationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AVClassificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='AVClassificationType'):
        super(AVClassificationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AVClassificationType')
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='AVClassificationType', fromsubclass_=False, pretty_print=True):
        super(AVClassificationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Engine_Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEngine_Version>%s</%sEngine_Version>%s' % (namespace_, self.gds_format_string(quote_xml(self.Engine_Version).encode(ExternalEncoding), input_name='Engine_Version'), namespace_, eol_))
        if self.Definition_Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefinition_Version>%s</%sDefinition_Version>%s' % (namespace_, self.gds_format_string(quote_xml(self.Definition_Version).encode(ExternalEncoding), input_name='Definition_Version'), namespace_, eol_))
        if self.Classification_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClassification_Name>%s</%sClassification_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.Classification_Name).encode(ExternalEncoding), input_name='Classification_Name'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AVClassificationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AVClassificationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AVClassificationType, self).exportLiteralChildren(outfile, level, name_)
        if self.Engine_Version is not None:
            showIndent(outfile, level)
            outfile.write('Engine_Version=%s,\n' % quote_python(self.Engine_Version).encode(ExternalEncoding))
        if self.Definition_Version is not None:
            showIndent(outfile, level)
            outfile.write('Definition_Version=%s,\n' % quote_python(self.Definition_Version).encode(ExternalEncoding))
        if self.Classification_Name is not None:
            showIndent(outfile, level)
            outfile.write('Classification_Name=%s,\n' % quote_python(self.Classification_Name).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AVClassificationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Engine_Version':
            Engine_Version_ = child_.text
            Engine_Version_ = self.gds_validate_string(Engine_Version_, node, 'Engine_Version')
            self.Engine_Version = Engine_Version_
        elif nodeName_ == 'Definition_Version':
            Definition_Version_ = child_.text
            Definition_Version_ = self.gds_validate_string(Definition_Version_, node, 'Definition_Version')
            self.Definition_Version = Definition_Version_
        elif nodeName_ == 'Classification_Name':
            Classification_Name_ = child_.text
            Classification_Name_ = self.gds_validate_string(Classification_Name_, node, 'Classification_Name')
            self.Classification_Name = Classification_Name_
        super(AVClassificationType, self).buildChildren(child_, node, nodeName_, True)
# end class AVClassificationType


class ProcessTreeNodeType(ProcessObjectType):
    """The ProcessTreeNodeType captures a single process, or node, in the
    process tree. It imports and extends the ProcessObjectType from
    the CybOX Process Object.The required id field specifies a
    unique ID for the Process Node. The ID must follow the pattern
    defined in the ProcessTreeNodeIDPattern simple type.The
    parent_action_idref field specifies the id of the action that
    created or injected this process."""
    subclass = None
    superclass = ProcessObjectType
    def __init__(self, object_reference=None, Custom_Properties=None, is_hidden=None, PID=None, Name=None, Creation_Time=None, Parent_PID=None, Child_PID_List=None, Image_Info=None, Argument_List=None, Environment_Variable_List=None, Kernel_Time=None, Port_List=None, Network_Connection_List=None, Start_Time=None, Status=None, Username=None, User_Time=None, Extracted_Features=None, id=None, parent_action_idref=None, Initiated_Actions=None, Spawned_Process=None, Injected_Process=None):
        super(ProcessTreeNodeType, self).__init__(object_reference, Custom_Properties, is_hidden, PID, Name, Creation_Time, Parent_PID, Child_PID_List, Image_Info, Argument_List, Environment_Variable_List, Kernel_Time, Port_List, Network_Connection_List, Start_Time, Status, Username, User_Time, Extracted_Features, )
        self.id = _cast(None, id)
        self.parent_action_idref = _cast(None, parent_action_idref)
        self.Initiated_Actions = Initiated_Actions
        if Spawned_Process is None:
            self.Spawned_Process = []
        else:
            self.Spawned_Process = Spawned_Process
        if Injected_Process is None:
            self.Injected_Process = []
        else:
            self.Injected_Process = Injected_Process
    def factory(*args_, **kwargs_):
        if ProcessTreeNodeType.subclass:
            return ProcessTreeNodeType.subclass(*args_, **kwargs_)
        else:
            return ProcessTreeNodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Initiated_Actions(self): return self.Initiated_Actions
    def set_Initiated_Actions(self, Initiated_Actions): self.Initiated_Actions = Initiated_Actions
    def get_Spawned_Process(self): return self.Spawned_Process
    def set_Spawned_Process(self, Spawned_Process): self.Spawned_Process = Spawned_Process
    def add_Spawned_Process(self, value): self.Spawned_Process.append(value)
    def insert_Spawned_Process(self, index, value): self.Spawned_Process[index] = value
    def get_Injected_Process(self): return self.Injected_Process
    def set_Injected_Process(self, Injected_Process): self.Injected_Process = Injected_Process
    def add_Injected_Process(self, value): self.Injected_Process.append(value)
    def insert_Injected_Process(self, index, value): self.Injected_Process[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_parent_action_idref(self): return self.parent_action_idref
    def set_parent_action_idref(self, parent_action_idref): self.parent_action_idref = parent_action_idref
    def hasContent_(self):
        if (
            self.Initiated_Actions is not None or
            self.Spawned_Process or
            self.Injected_Process or
            super(ProcessTreeNodeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ProcessTreeNodeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessTreeNodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ProcessTreeNodeType'):
        super(ProcessTreeNodeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessTreeNodeType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.parent_action_idref is not None and 'parent_action_idref' not in already_processed:
            already_processed.add('parent_action_idref')
            outfile.write(' parent_action_idref=%s' % (quote_attrib(self.parent_action_idref), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ProcessTreeNodeType', fromsubclass_=False, pretty_print=True):
        super(ProcessTreeNodeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Initiated_Actions is not None:
            self.Initiated_Actions.export(outfile, level, namespace_, name_='Initiated_Actions', pretty_print=pretty_print)
        for Spawned_Process_ in self.Spawned_Process:
            Spawned_Process_.export(outfile, level, namespace_, name_='Spawned_Process', pretty_print=pretty_print)
        for Injected_Process_ in self.Injected_Process:
            Injected_Process_.export(outfile, level, namespace_, name_='Injected_Process', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessTreeNodeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.parent_action_idref is not None and 'parent_action_idref' not in already_processed:
            already_processed.add('parent_action_idref')
            showIndent(outfile, level)
            outfile.write('parent_action_idref=%s,\n' % (self.parent_action_idref,))
        super(ProcessTreeNodeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProcessTreeNodeType, self).exportLiteralChildren(outfile, level, name_)
        if self.Initiated_Actions is not None:
            showIndent(outfile, level)
            outfile.write('Initiated_Actions=model_.ActionReferenceListType(\n')
            self.Initiated_Actions.exportLiteral(outfile, level, name_='Initiated_Actions')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Spawned_Process=[\n')
        level += 1
        for Spawned_Process_ in self.Spawned_Process:
            showIndent(outfile, level)
            outfile.write('model_.ProcessTreeNodeType(\n')
            Spawned_Process_.exportLiteral(outfile, level, name_='ProcessTreeNodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Injected_Process=[\n')
        level += 1
        for Injected_Process_ in self.Injected_Process:
            showIndent(outfile, level)
            outfile.write('model_.ProcessTreeNodeType(\n')
            Injected_Process_.exportLiteral(outfile, level, name_='ProcessTreeNodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('parent_action_idref', node)
        if value is not None and 'parent_action_idref' not in already_processed:
            already_processed.add('parent_action_idref')
            self.parent_action_idref = value
        super(ProcessTreeNodeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Initiated_Actions':
            obj_ = ActionReferenceListType.factory()
            obj_.build(child_)
            self.Initiated_Actions = obj_
        elif nodeName_ == 'Spawned_Process':
            obj_ = ProcessTreeNodeType.factory()
            obj_.build(child_)
            self.Spawned_Process.append(obj_)
        elif nodeName_ == 'Injected_Process':
            obj_ = ProcessTreeNodeType.factory()
            obj_.build(child_)
            self.Injected_Process.append(obj_)
        super(ProcessTreeNodeType, self).buildChildren(child_, node, nodeName_, True)
# end class ProcessTreeNodeType


class BehavioralActionReferenceType(ActionReferenceType):
    """The BehavioralActionReferenceType defines an action reference that
    can be used as part of a Behavior.The behavioral_ordering field
    defines the ordering of the Action with respect to the other
    Actions that make up the Behavior. For example, an Action with a
    behavioral_ordering of "1" would come before an Action with a
    behavioral_ordering of "2", etc."""
    subclass = None
    superclass = ActionReferenceType
    def __init__(self, action_id=None, behavioral_ordering=None):
        super(BehavioralActionReferenceType, self).__init__(action_id, )
        self.behavioral_ordering = _cast(int, behavioral_ordering)
        pass
    def factory(*args_, **kwargs_):
        if BehavioralActionReferenceType.subclass:
            return BehavioralActionReferenceType.subclass(*args_, **kwargs_)
        else:
            return BehavioralActionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_behavioral_ordering(self): return self.behavioral_ordering
    def set_behavioral_ordering(self, behavioral_ordering): self.behavioral_ordering = behavioral_ordering
    def hasContent_(self):
        if (
            super(BehavioralActionReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehavioralActionReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehavioralActionReferenceType'):
        super(BehavioralActionReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionReferenceType')
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            outfile.write(' behavioral_ordering="%s"' % self.gds_format_integer(self.behavioral_ordering, input_name='behavioral_ordering'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehavioralActionReferenceType', fromsubclass_=False, pretty_print=True):
        super(BehavioralActionReferenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='BehavioralActionReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            showIndent(outfile, level)
            outfile.write('behavioral_ordering=%d,\n' % (self.behavioral_ordering,))
        super(BehavioralActionReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BehavioralActionReferenceType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('behavioral_ordering', node)
        if value is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            try:
                self.behavioral_ordering = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.behavioral_ordering <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(BehavioralActionReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BehavioralActionReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BehavioralActionReferenceType


class ObjectCollectionType(BaseCollectionType):
    """The ObjectCollectionType provides a mechanism for characterizing
    collections of Objects. For instance, it can be used to group
    all of the Objects that are associated with a specific
    behavior.The id attribute specifies a unique ID for this Object
    Collection. The ID must follow the pattern defined in the
    ObjectCollIDPattern simple type."""
    subclass = None
    superclass = BaseCollectionType
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, id=None, Object_List=None):
        super(ObjectCollectionType, self).__init__(name, Affinity_Type, Affinity_Degree, Description, )
        self.id = _cast(None, id)
        self.Object_List = Object_List
    def factory(*args_, **kwargs_):
        if ObjectCollectionType.subclass:
            return ObjectCollectionType.subclass(*args_, **kwargs_)
        else:
            return ObjectCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object_List(self): return self.Object_List
    def set_Object_List(self, Object_List): self.Object_List = Object_List
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Object_List is not None or
            super(ObjectCollectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ObjectCollectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectCollectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ObjectCollectionType'):
        super(ObjectCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectCollectionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ObjectCollectionType', fromsubclass_=False, pretty_print=True):
        super(ObjectCollectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Object_List is not None:
            self.Object_List.export(outfile, level, namespace_, name_='Object_List', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectCollectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        super(ObjectCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ObjectCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Object_List is not None:
            showIndent(outfile, level)
            outfile.write('Object_List=model_.ObjectListType(\n')
            self.Object_List.exportLiteral(outfile, level, name_='Object_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(ObjectCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object_List':
            obj_ = ObjectListType.factory()
            obj_.build(child_)
            self.Object_List = obj_
        super(ObjectCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class ObjectCollectionType


class ActionCollectionType(BaseCollectionType):
    """The ActionCollectionType provides a method for characterizing
    collections of actions. This can be useful for organizing
    actions that may be related and where the exact relationship is
    unknown, as well as actions whose associated behavior has not
    yet been established.The id field specifies a unique ID for this
    Action Collection. The ID must follow the pattern defined in the
    ActionCollIDPattern simple type."""
    subclass = None
    superclass = BaseCollectionType
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, id=None, Action_List=None):
        super(ActionCollectionType, self).__init__(name, Affinity_Type, Affinity_Degree, Description, )
        self.id = _cast(None, id)
        self.Action_List = Action_List
    def factory(*args_, **kwargs_):
        if ActionCollectionType.subclass:
            return ActionCollectionType.subclass(*args_, **kwargs_)
        else:
            return ActionCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action_List(self): return self.Action_List
    def set_Action_List(self, Action_List): self.Action_List = Action_List
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Action_List is not None or
            super(ActionCollectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='ActionCollectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionCollectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='ActionCollectionType'):
        super(ActionCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActionCollectionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='ActionCollectionType', fromsubclass_=False, pretty_print=True):
        super(ActionCollectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Action_List is not None:
            self.Action_List.export(outfile, level, namespace_, name_='Action_List', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ActionCollectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        super(ActionCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActionCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Action_List is not None:
            showIndent(outfile, level)
            outfile.write('Action_List=model_.ActionListType(\n')
            self.Action_List.exportLiteral(outfile, level, name_='Action_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(ActionCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action_List':
            obj_ = ActionListType.factory()
            obj_.build(child_)
            self.Action_List = obj_
        super(ActionCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class ActionCollectionType


class BehaviorCollectionType(BaseCollectionType):
    """The BehaviorCollectionType provides a mechanism for characterizing
    collections of behaviors.The id field specifies a unique ID for
    this Behavior Collection. The ID must follow the pattern defined
    in the BehaviorCollIDPattern simple type."""
    subclass = None
    superclass = BaseCollectionType
    def __init__(self, name=None, Affinity_Type=None, Affinity_Degree=None, Description=None, id=None, Purpose=None, Behavior_List=None):
        super(BehaviorCollectionType, self).__init__(name, Affinity_Type, Affinity_Degree, Description, )
        self.id = _cast(None, id)
        self.Purpose = Purpose
        self.Behavior_List = Behavior_List
    def factory(*args_, **kwargs_):
        if BehaviorCollectionType.subclass:
            return BehaviorCollectionType.subclass(*args_, **kwargs_)
        else:
            return BehaviorCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def get_Behavior_List(self): return self.Behavior_List
    def set_Behavior_List(self, Behavior_List): self.Behavior_List = Behavior_List
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Purpose is not None or
            self.Behavior_List is not None or
            super(BehaviorCollectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehaviorCollectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorCollectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehaviorCollectionType'):
        super(BehaviorCollectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BehaviorCollectionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehaviorCollectionType', fromsubclass_=False, pretty_print=True):
        super(BehaviorCollectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Purpose is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurpose>%s</%sPurpose>%s' % (namespace_, self.gds_format_string(quote_xml(self.Purpose).encode(ExternalEncoding), input_name='Purpose'), namespace_, eol_))
        if self.Behavior_List is not None:
            self.Behavior_List.export(outfile, level, namespace_, name_='Behavior_List', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehaviorCollectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        super(BehaviorCollectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BehaviorCollectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Purpose is not None:
            showIndent(outfile, level)
            outfile.write('Purpose=%s,\n' % quote_python(self.Purpose).encode(ExternalEncoding))
        if self.Behavior_List is not None:
            showIndent(outfile, level)
            outfile.write('Behavior_List=model_.BehaviorListType(\n')
            self.Behavior_List.exportLiteral(outfile, level, name_='Behavior_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(BehaviorCollectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Purpose':
            Purpose_ = child_.text
            Purpose_ = self.gds_validate_string(Purpose_, node, 'Purpose')
            self.Purpose = Purpose_
        elif nodeName_ == 'Behavior_List':
            obj_ = BehaviorListType.factory()
            obj_.build(child_)
            self.Behavior_List = obj_
        super(BehaviorCollectionType, self).buildChildren(child_, node, nodeName_, True)
# end class BehaviorCollectionType


class MalwareActionType(ActionType):
    """The MalwareActionType is one of the foundational MAEC types, and
    serves as a method for the characterization of actions found or
    observed in malware. Actions can be thought of as system state
    changes and similar operations that represent the fundamental
    low-level operation of malware. Some examples include the
    creation of a file, deletion of a registry key, and the sending
    of some data on a socket. It imports and extends the CybOX
    ActionType. For MAEC, the id attribute is required and must
    follow the proper syntax: A dash-delimited format is used with
    the id or idref starting with the word maec followed by a unique
    string, followed by the three letter code 'act', and ending with
    an integer."""
    subclass = None
    superclass = ActionType
    def __init__(self, timestamp=None, action_status=None, ordinal_position=None, context=None, idref=None, id=None, Type=None, Name=None, Description=None, Action_Aliases=None, Action_Arguments=None, Discovery_Method=None, Associated_Objects=None, Relationships=None, Frequency=None, Implementation=None, extensiontype_=None):
        super(MalwareActionType, self).__init__(timestamp, action_status, ordinal_position, context, idref, id, Type, Name, Description, Action_Aliases, Action_Arguments, Discovery_Method, Associated_Objects, Relationships, Frequency, extensiontype_, )
        self.Implementation = Implementation
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MalwareActionType.subclass:
            return MalwareActionType.subclass(*args_, **kwargs_)
        else:
            return MalwareActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Implementation(self): return self.Implementation
    def set_Implementation(self, Implementation): self.Implementation = Implementation
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Implementation is not None or
            super(MalwareActionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='MalwareActionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MalwareActionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='MalwareActionType'):
        super(MalwareActionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MalwareActionType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='MalwareActionType', fromsubclass_=False, pretty_print=True):
        super(MalwareActionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Implementation is not None:
            self.Implementation.export(outfile, level, namespace_, name_='Implementation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MalwareActionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MalwareActionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MalwareActionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Implementation is not None:
            showIndent(outfile, level)
            outfile.write('Implementation=model_.ActionImplementationType(\n')
            self.Implementation.exportLiteral(outfile, level, name_='Implementation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(MalwareActionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Implementation':
            obj_ = ActionImplementationType.factory()
            obj_.build(child_)
            self.Implementation = obj_
        super(MalwareActionType, self).buildChildren(child_, node, nodeName_, True)
# end class MalwareActionType


class BehavioralActionType(MalwareActionType):
    """The BehavioralActionType defines an Action that can be used as part
    of a Behavior.The behavioral_ordering field defines the ordering
    of the Action with respect to the other Actions that make up the
    behavior. So an action with a behavioral_ordering of "1" would
    come before an Action with a behavioral_ordering of "2", etc."""
    subclass = None
    superclass = MalwareActionType
    def __init__(self, timestamp=None, action_status=None, ordinal_position=None, context=None, idref=None, id=None, Type=None, Name=None, Description=None, Action_Aliases=None, Action_Arguments=None, Discovery_Method=None, Associated_Objects=None, Relationships=None, Frequency=None, Implementation=None, behavioral_ordering=None):
        super(BehavioralActionType, self).__init__(timestamp, action_status, ordinal_position, context, idref, id, Type, Name, Description, Action_Aliases, Action_Arguments, Discovery_Method, Associated_Objects, Relationships, Frequency, Implementation, )
        self.behavioral_ordering = _cast(int, behavioral_ordering)
        pass
    def factory(*args_, **kwargs_):
        if BehavioralActionType.subclass:
            return BehavioralActionType.subclass(*args_, **kwargs_)
        else:
            return BehavioralActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_behavioral_ordering(self): return self.behavioral_ordering
    def set_behavioral_ordering(self, behavioral_ordering): self.behavioral_ordering = behavioral_ordering
    def hasContent_(self):
        if (
            super(BehavioralActionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='maecBundle:', name_='BehavioralActionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='maecBundle:', name_='BehavioralActionType'):
        super(BehavioralActionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BehavioralActionType')
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            outfile.write(' behavioral_ordering="%s"' % self.gds_format_integer(self.behavioral_ordering, input_name='behavioral_ordering'))
    def exportChildren(self, outfile, level, namespace_='maecBundle:', name_='BehavioralActionType', fromsubclass_=False, pretty_print=True):
        super(BehavioralActionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BehavioralActionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.behavioral_ordering is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            showIndent(outfile, level)
            outfile.write('behavioral_ordering=%d,\n' % (self.behavioral_ordering,))
        super(BehavioralActionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BehavioralActionType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('behavioral_ordering', node)
        if value is not None and 'behavioral_ordering' not in already_processed:
            already_processed.add('behavioral_ordering')
            try:
                self.behavioral_ordering = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.behavioral_ordering <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(BehavioralActionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BehavioralActionType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BehavioralActionType


GDSClassesMapping = {
    'Relationships': RelationshipsType,
    'Build_Utility': BuildUtilityType,
    'Errors': ErrorsType,
    'Defined_Effect': DefinedEffectType,
    'Compatible_Platforms': PlatformListType,
    'Parsed_Header': HTTPResponseHeaderFieldsType,
    'Object_Collection': ObjectCollectionType,
    'Access_Control_Allow_Origin': StringObjectPropertyType,
    'Action': ActionType,
    'Certificate_Issuer': StringObjectPropertyType,
    'Collections': CollectionsType,
    'HTTP_Server_Response': HTTPServerResponseType,
    'Malware_Entity': MalwareEntityType,
    'Port': PortObjectType,
    'P3P': StringObjectPropertyType,
    'Proxy_Authorization': StringObjectPropertyType,
    'Metadata': MetadataType,
    'Socket_Address': SocketAddressObjectType,
    'Hash': HashType,
    'Address': AddressObjectType,
    'Processor_Family': ProcessorTypeType,
    'Importance': ControlledVocabularyStringType,
    'Entry_Type': StringObjectPropertyType,
    'Object': ObjectType,
    'PID': UnsignedIntegerObjectPropertyType,
    'MAEC_Bundle': BundleType,
    'If_None_Match': StringObjectPropertyType,
    'Host': HostFieldType,
    'HTTP_Method': HTTPMethodType,
    'Referer': URIObjectType,
    'Argument_List': ArgumentListType,
    'Information_Source_Type': ControlledVocabularyStringType,
    'Path': StringObjectPropertyType,
    'Authority_Resource_Records': DNSResourceRecordsType,
    'Segment_Hash': HashValueType,
    'Behavior_List': BehaviorListType,
    'Observable': ObservableType,
    'Action_Argument': ActionArgumentType,
    'Action_Collection': ActionCollectionType,
    'Tool_Hashes': HashListType,
    'Digital_Signature': DigitalSignatureInfoType,
    'X_Forwarded_Proto': StringObjectPropertyType,
    'X_ATT_DeviceId': StringObjectPropertyType,
    'Code_Snippets': CodeSnippetsType,
    'Related_Object': RelatedObjectType,
    'URI': URIObjectType,
    'Value': AnyURIObjectPropertyType,
    'Answer_Resource_Records': DNSResourceRecordsType,
    'Refresh': IntegerObjectPropertyType,
    'Length': PositiveIntegerObjectPropertyType,
    'Expect': StringObjectPropertyType,
    'If_Range': StringObjectPropertyType,
    'Evasion_Techniques': ObfuscationTechniquesType,
    'Action_Collections': ActionCollectionListType,
    'Behaviors': BehaviorListType,
    'API_Call': APICallType,
    'Parent_PID': UnsignedIntegerObjectPropertyType,
    'Reference': ReferenceType,
    'Encoding': ControlledVocabularyStringType,
    'Block_Hash_Value': HashValueType,
    'Internationalization_Settings': InternationalizationSettingsType,
    'Image_Offset': IntegerObjectPropertyType,
    'Associated_Objects': AssociatedObjectsType,
    'Signature_Description': StringObjectPropertyType,
    'File_System_Offset': IntegerObjectPropertyType,
    'Warning': StringObjectPropertyType,
    'Imports': ImportsType,
    'Code_Language': CodeLanguageType,
    'Compiler_Informal_Description': CompilerInformalDescriptionType,
    'English_Translation': StringObjectPropertyType,
    'Event': EventType,
    'Segments': HashSegmentsType,
    'Layer4_Protocol': Layer4ProtocolType,
    'Content_Length': IntegerObjectPropertyType,
    'X_UA_Compatible': StringObjectPropertyType,
    'Functions': FunctionsType,
    'From': AddressObjectType,
    'String_Value': StringObjectPropertyType,
    'Parameters': ParameterListType,
    'Build_Utility_Platform_Specification': PlatformSpecificationType,
    'Implementation': ActionImplementationType,
    'Start_Time': DateTimeObjectPropertyType,
    'Max_Forwards': IntegerObjectPropertyType,
    'Question': DNSQuestionType,
    'System': ObjectPropertiesType,
    'HTTP_Request_Line': HTTPRequestLineType,
    'Platform': PlatformSpecificationType,
    'State': ControlledVocabularyStringType,
    'Version': StringObjectPropertyType,
    'Property_Pool': PropertyPoolType,
    'Accept_Language': StringObjectPropertyType,
    'Import': StringObjectPropertyType,
    'Raw_Header': StringObjectPropertyType,
    'Sub_Composition': CandidateIndicatorCompositionType,
    'Code_Segment_XOR': CodeSegmentXORType,
    'Parameter': ParameterType,
    'Expires': DateTimeObjectPropertyType,
    'Compilers': CompilersType,
    'Username': StringObjectPropertyType,
    'Digital_Signatures': DigitalSignaturesType,
    'Tool_Type': ControlledVocabularyStringType,
    'Behavior_Collection': BehaviorCollectionType,
    'Relationship': ControlledVocabularyStringType,
    'Accept_Charset': StringObjectPropertyType,
    'Accept': StringObjectPropertyType,
    'Tool': ToolInformationType,
    'Layer3_Protocol': Layer3ProtocolType,
    'Build_Information': BuildInformationType,
    'Additional_Records': DNSResourceRecordsType,
    'Obfuscation_Technique': ObfuscationTechniqueType,
    'Link': StringObjectPropertyType,
    'Associated_Code': AssociatedCodeType,
    'Observable_Composition': ObservableCompositionType,
    'TTL': IntegerObjectPropertyType,
    'Code_Segment': StringObjectPropertyType,
    'X_Frame_Options': StringObjectPropertyType,
    'Targeted_Platforms': TargetedPlatformsType,
    'IP_Address': AddressObjectType,
    'Message_Body': StringObjectPropertyType,
    'Address_Value': StringObjectPropertyType,
    'Error_Instances': ErrorInstancesType,
    'Behavior_Reference': BehaviorReferenceType,
    'Age': IntegerObjectPropertyType,
    'Action_Pool': ActionPoolType,
    'Data_Segment': StringObjectPropertyType,
    'Server': StringObjectPropertyType,
    'Image_Info': ImageInfoType,
    'Range': StringObjectPropertyType,
    'Certificate_Subject': StringObjectPropertyType,
    'Retry_After': IntegerObjectPropertyType,
    'Behavior': BehaviorType,
    'Resource_Record': DNSRecordObjectType,
    'Property': PropertyType,
    'Strings': ExtractedStringsType,
    'Initiated_Actions': ActionReferenceListType,
    'WWW_Authenticate': StringObjectPropertyType,
    'X_Wap_Profile': URIObjectType,
    'Via': StringObjectPropertyType,
    'X_Requested_For': StringObjectPropertyType,
    'Contributors': PersonnelType,
    'Transfer_Encoding': StringObjectPropertyType,
    'Command_Line': StringObjectPropertyType,
    'Reference_Description': StructuredTextType,
    'DNS_Record': DNSRecordObjectType,
    'DNS_Query': DNSQueryObjectType,
    'Code_Snippet': ObjectPropertiesType,
    'Child_PID': UnsignedIntegerObjectPropertyType,
    'HTTP_Session': HTTPSessionObjectType,
    'Configuration_Settings': ConfigurationSettingsType,
    'Flags': HexBinaryObjectPropertyType,
    'Compiler_Platform_Specification': PlatformSpecificationType,
    'Destination_Socket_Address': SocketAddressObjectType,
    'Observable_Source': MeasureSourceType,
    'Byte_String_Value': HexBinaryObjectPropertyType,
    'User_Time': DurationObjectPropertyType,
    'Record_Name': StringObjectPropertyType,
    'Vulnerability_Exploit': VulnerabilityExploitType,
    'Association_Type': ControlledVocabularyStringType,
    'Location': URIObjectType,
    'Accept_Ranges': StringObjectPropertyType,
    'Observable_Package_Source': MeasureSourceType,
    'Instance': ObjectPropertiesType,
    'Root_Process': ProcessTreeNodeType,
    'Associated_Object': AssociatedObjectType,
    'Related_Objects': RelatedObjectsType,
    'Reason_Phrase': StringObjectPropertyType,
    'AV_Classification': AVClassificationType,
    'QType': DNSRecordType,
    'HTTP_Client_Request': HTTPClientRequestType,
    'Record_Type': StringObjectPropertyType,
    'Authorization': StringObjectPropertyType,
    'Accept_Encoding': StringObjectPropertyType,
    'Status': ProcessStatusType,
    'Identifier': PlatformIdentifierType,
    'Current_Directory': StringObjectPropertyType,
    'Tool_Specific_Data': ToolSpecificDataType,
    'Child_PID_List': ChildPIDListType,
    'Extracted_Features': ExtractedFeaturesType,
    'Execution_Environment': ExecutionEnvironmentType,
    'If_Modified_Since': DateTimeObjectPropertyType,
    'X_Content_Type_Options': StringObjectPropertyType,
    'HTTP_Message_Body': HTTPMessageType,
    'Search_Distance': IntegerObjectPropertyType,
    'Domain_Specific_Object_Properties': DomainSpecificObjectPropertiesType,
    'Dependencies': DependenciesType,
    'Segment_Count': IntegerObjectPropertyType,
    'Object_Collections': ObjectCollectionListType,
    'Offset': IntegerObjectPropertyType,
    'Date': DateTimeObjectPropertyType,
    'Cookie': StringObjectPropertyType,
    'Hashes': HashListType,
    'Strict_Transport_Security': StringObjectPropertyType,
    'Data': DataSegmentType,
    'Properties': PropertiesType,
    'User_Agent': StringObjectPropertyType,
    'Address_Class': StringObjectPropertyType,
    'Candidate_Indicator_Collections': CandidateIndicatorCollectionListType,
    'Language': StringObjectPropertyType,
    'VLAN_Name': StringObjectPropertyType,
    'Cache_Control': StringObjectPropertyType,
    'QName': URIObjectType,
    'Creation_Time': DateTimeObjectPropertyType,
    'Usage_Context_Assumption': StructuredTextType,
    'Block_Hash': FuzzyHashBlockType,
    'Dependency': DependencyType,
    'Connection': StringObjectPropertyType,
    'X_Requested_With': StringObjectPropertyType,
    'Kernel_Time': DurationObjectPropertyType,
    'Object_Reference': ObjectReferenceType,
    'Pools': PoolsType,
    'HTTP_Status_Line': HTTPStatusLineType,
    'Event_Pool': EventPoolType,
    'If_Unmodified_Since': DateTimeObjectPropertyType,
    'Trigger_Point': HexBinaryObjectPropertyType,
    'Environment_Variable': EnvironmentVariableType,
    'Byte_Run': ByteRunType,
    'Start_Address': HexBinaryObjectPropertyType,
    'Code': CodeObjectType,
    'Code_Object': CodeObjectType,
    'Old_Object': ObjectType,
    'Tool_Configuration': ToolConfigurationType,
    'Process': ProcessObjectType,
    'Object_Pool': ObjectPoolType,
    'X_Powered_By': StringObjectPropertyType,
    'Vary': URIObjectType,
    'Library': LibraryType,
    'Action_Arguments': ActionArgumentsType,
    'Frequency': FrequencyType,
    'References': ToolReferencesType,
    'Service_Used': StringObjectPropertyType,
    'Keywords': KeywordsType,
    'AV_Classifications': AVClassificationsType,
    'HTTP_Response_Header': HTTPResponseHeaderType,
    'Pattern_Fidelity': PatternFidelityType,
    'X_XSS_Protection': StringObjectPropertyType,
    'Layer7_Connections': Layer7ConnectionsType,
    'Usage_Context_Assumptions': UsageContextAssumptionsType,
    'Internal_Strings': InternalStringsType,
    'Time': TimeType,
    'Trailer': StringObjectPropertyType,
    'Domain_Name': URIObjectType,
    'Injected_Process': ProcessTreeNodeType,
    'Fuzzy_Hash_Structure': FuzzyHashStructureType,
    'File_Name': StringObjectPropertyType,
    'Configuration_Setting': ConfigurationSettingType,
    'Content_Location': StringObjectPropertyType,
    'Malware_Instance_Object_Attributes': ObjectType,
    'Argument': StringObjectPropertyType,
    'Libraries': LibrariesType,
    'QClass': StringObjectPropertyType,
    'SubDatum': MetadataType,
    'Content_Language': StringObjectPropertyType,
    'Source_Socket_Address': SocketAddressObjectType,
    'Content_MD5': StringObjectPropertyType,
    'Action_Reference': ActionReferenceType,
    'CVE': CVEVulnerabilityType,
    'Content_Disposition': StringObjectPropertyType,
    'Composition': CandidateIndicatorCompositionType,
    'Action_Composition': BehavioralActionsType,
    'Function': StringObjectPropertyType,
    'Process_Tree': ProcessTreeType,
    'Description': StructuredTextType,
    'Candidate_Indicator_Collection': CandidateIndicatorCollectionType,
    'User_Account_Info': ObjectPropertiesType,
    'Build_Configuration': BuildConfigurationType,
    'Type': CodeTypeType,
    'Discovery_Method': MeasureSourceType,
    'Object_List': ObjectListType,
    'TE': StringObjectPropertyType,
    'Action_Pertinent_Object_Properties': ActionPertinentObjectPropertiesType,
    'Content_Range': StringObjectPropertyType,
    'Observation_Method': MeasureSourceType,
    'Error': ErrorType,
    'Objects': ObjectListType,
    'Purpose': CodePurposeType,
    'Pragma': StringObjectPropertyType,
    'Spawned_Process': ProcessTreeNodeType,
    'Layer7_Protocol': Layer7ProtocolType,
    'Search_Within': IntegerObjectPropertyType,
    'Segment': HashSegmentType,
    'Port_Value': PositiveIntegerObjectPropertyType,
    'DNT': URIObjectType,
    'Compiler': CompilerType,
    'Action_Equivalence_Reference': BehavioralActionEquivalenceReferenceType,
    'Name': StringObjectPropertyType,
    'Action_List': ActionListType,
    'Set_Cookie': StringObjectPropertyType,
    'Network_Connection_List': NetworkConnectionListType,
    'Accept_Datetime': StringObjectPropertyType,
    'Environment_Variable_List': EnvironmentVariableListType,
    'Candidate_Indicator': CandidateIndicatorType,
    'Last_Modified': DateTimeObjectPropertyType,
    'Values': ValuesType,
    'Port_List': PortListType,
    'Content_Type': StringObjectPropertyType,
    'Behavior_Collections': BehaviorCollectionListType,
    'Observables': ObservablesType,
    'Block_Size': IntegerObjectPropertyType,
    'Candidate_Indicator_List': CandidateIndicatorListType,
    'Simple_Hash_Value': SimpleHashValueType,
    'Proxy_Authenticate': StringObjectPropertyType,
    'String': ExtractedStringType,
    'Content_Encoding': StringObjectPropertyType,
    'New_Object': ObjectType,
    'Candidate_Indicators': CandidateIndicatorListType,
    'HTTP_Request_Response': HTTPRequestResponseType,
    'Tools': ToolsInformationType,
    'Network_Connection': NetworkConnectionObjectType,
    'Data_Length': IntegerObjectPropertyType,
    'Fuzzy_Hash_Value': FuzzyHashValueType,
    'Actions': ActionsType,
    'Data_Size': DataSizeType,
    'Targeted_Platform': PlatformSpecificationType,
    'HTTP_Request_Header': HTTPRequestHeaderType,
    'Dependency_Description': StructuredTextType,
    'ETag': StringObjectPropertyType,
    'Date_Ran': DateTimeObjectPropertyType,
    'Status_Code': PositiveIntegerObjectPropertyType,
    'Contributor': ContributorType,
    'Action_Aliases': ActionAliasesType,
    'If_Match': StringObjectPropertyType,
    'Argument_Name': ControlledVocabularyStringType,
    'Custom_Properties': CustomPropertiesType,
    'VLAN_Num': IntegerObjectPropertyType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MAEC_Bundle'
        rootClass = BundleType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MAEC_Bundle'
        rootClass = BundleType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = BundleType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_="MAEC_Bundle",
            namespacedef_='xmlns:maecBundle="http://maec.mitre.org/XMLSchema/maec-bundle-4"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MAEC_Bundle'
        rootClass = BundleType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from maec import *\n\n')
        sys.stdout.write('import maec as model_\n\n')
        sys.stdout.write('rootObj = model_.rootTag(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "APICallType",
    "AVClassificationType",
    "AVClassificationsType",
    "ActionAliasesType",
    "ActionArgumentNameVocab_1_0",
    "ActionArgumentType",
    "ActionArgumentsType",
    "ActionCollectionListType",
    "ActionCollectionType",
    "ActionImplementationType",
    "ActionListType",
    "ActionNameVocab_1_0",
    "ActionObjectAssociationTypeVocab_1_0",
    "ActionPertinentObjectPropertiesType",
    "ActionPertinentObjectPropertyType",
    "ActionPoolType",
    "ActionReferenceListType",
    "ActionReferenceType",
    "ActionRelationshipType",
    "ActionRelationshipTypeVocab_1_0",
    "ActionType",
    "ActionTypeVocab_1_0",
    "ActionsType",
    "AddressObjectType",
    "AnyURIObjectPropertyType",
    "ArgumentListType",
    "AssociatedCodeType",
    "AssociatedObjectType",
    "AssociatedObjectsType",
    "Base64BinaryObjectPropertyType",
    "BaseCollectionType",
    "BaseObjectPropertyType",
    "BehaviorCollectionListType",
    "BehaviorCollectionType",
    "BehaviorListType",
    "BehaviorPurposeType",
    "BehaviorReferenceListType",
    "BehaviorReferenceType",
    "BehaviorRelationshipListType",
    "BehaviorRelationshipType",
    "BehaviorType",
    "BehavioralActionEquivalenceReferenceType",
    "BehavioralActionReferenceType",
    "BehavioralActionType",
    "BehavioralActionsType",
    "BuildConfigurationType",
    "BuildInformationType",
    "BuildUtilityType",
    "BundleReferenceType",
    "BundleType",
    "ByteRunType",
    "ByteRunsType",
    "CVEVulnerabilityType",
    "CandidateIndicatorCollectionListType",
    "CandidateIndicatorCollectionType",
    "CandidateIndicatorCompositionType",
    "CandidateIndicatorListType",
    "CandidateIndicatorType",
    "CharacterEncodingVocab_1_0",
    "ChildPIDListType",
    "CodeLanguageType",
    "CodeObjectType",
    "CodePurposeType",
    "CodeSegmentXORType",
    "CodeSnippetsType",
    "CodeTypeType",
    "CollectionsType",
    "CompilerInformalDescriptionType",
    "CompilerType",
    "CompilersType",
    "ConfigurationSettingType",
    "ConfigurationSettingsType",
    "ContributorType",
    "ControlledVocabularyStringType",
    "CustomPropertiesType",
    "DNSQueryObjectType",
    "DNSQuestionType",
    "DNSRecordObjectType",
    "DNSRecordType",
    "DNSResourceRecordsType",
    "DataReadEffectType",
    "DataReceivedEffectType",
    "DataSegmentType",
    "DataSentEffectType",
    "DataSizeType",
    "DataWrittenEffectType",
    "DateObjectPropertyType",
    "DateRangeType",
    "DateTimeObjectPropertyType",
    "DefinedEffectType",
    "DependenciesType",
    "DependencyType",
    "DigitalSignatureInfoType",
    "DigitalSignaturesType",
    "DomainSpecificObjectPropertiesType",
    "DoubleObjectPropertyType",
    "DurationObjectPropertyType",
    "EnvironmentVariableListType",
    "EnvironmentVariableType",
    "ErrorInstancesType",
    "ErrorType",
    "ErrorsType",
    "EventPoolType",
    "EventType",
    "EventTypeVocab_1_0",
    "ExecutionEnvironmentType",
    "ExtractedFeaturesType",
    "ExtractedStringType",
    "ExtractedStringsType",
    "FloatObjectPropertyType",
    "FrequencyType",
    "FunctionsType",
    "FuzzyHashBlockType",
    "FuzzyHashStructureType",
    "FuzzyHashValueType",
    "HTTPClientRequestType",
    "HTTPMessageType",
    "HTTPMethodType",
    "HTTPRequestHeaderFieldsType",
    "HTTPRequestHeaderType",
    "HTTPRequestLineType",
    "HTTPRequestResponseType",
    "HTTPResponseHeaderFieldsType",
    "HTTPResponseHeaderType",
    "HTTPServerResponseType",
    "HTTPSessionObjectType",
    "HTTPStatusLineType",
    "HashListType",
    "HashNameVocab_1_0",
    "HashSegmentType",
    "HashSegmentsType",
    "HashType",
    "HashValueType",
    "HexBinaryObjectPropertyType",
    "HostFieldType",
    "ImageInfoType",
    "ImportsType",
    "InformationSourceTypeVocab_1_0",
    "IntegerObjectPropertyType",
    "InternalStringsType",
    "InternationalizationSettingsType",
    "KeywordsType",
    "Layer3ProtocolType",
    "Layer4ProtocolType",
    "Layer7ConnectionsType",
    "Layer7ProtocolType",
    "LibrariesType",
    "LibraryType",
    "LongObjectPropertyType",
    "MalwareActionType",
    "MalwareEntityType",
    "MeasureSourceType",
    "MetadataType",
    "NameObjectPropertyType",
    "NetworkConnectionListType",
    "NetworkConnectionObjectType",
    "NonNegativeIntegerObjectPropertyType",
    "ObfuscationTechniqueType",
    "ObfuscationTechniquesType",
    "ObjectCollectionListType",
    "ObjectCollectionType",
    "ObjectListType",
    "ObjectPoolType",
    "ObjectPropertiesType",
    "ObjectReferenceListType",
    "ObjectReferenceType",
    "ObjectRelationshipVocab_1_0",
    "ObjectStateVocab_1_0",
    "ObjectType",
    "ObservableCompositionType",
    "ObservableType",
    "ObservablesType",
    "ParameterListType",
    "ParameterType",
    "PatternFidelityType",
    "PatternableFieldType",
    "PersonnelType",
    "PlatformIdentifierType",
    "PlatformListType",
    "PlatformSpecificationType",
    "PoolsType",
    "PortListType",
    "PortObjectType",
    "PositiveIntegerObjectPropertyType",
    "ProcessObjectType",
    "ProcessStatusType",
    "ProcessTreeNodeType",
    "ProcessTreeType",
    "ProcessorTypeType",
    "PropertiesEnumeratedEffectType",
    "PropertiesType",
    "PropertyPoolType",
    "PropertyReadEffectType",
    "PropertyType",
    "ReferenceListType",
    "ReferenceType",
    "RelatedObjectType",
    "RelatedObjectsType",
    "RelationshipsType",
    "SIDType",
    "SendControlCodeEffectType",
    "SimpleHashValueType",
    "SocketAddressObjectType",
    "StateChangeEffectType",
    "StringObjectPropertyType",
    "StructuredTextType",
    "TargetedPlatformsType",
    "TimeObjectPropertyType",
    "TimeType",
    "ToolConfigurationType",
    "ToolInformationType",
    "ToolReferenceType",
    "ToolReferencesType",
    "ToolSpecificDataType",
    "ToolTypeVocab_1_0",
    "ToolsInformationType",
    "URIObjectType",
    "UnsignedIntegerObjectPropertyType",
    "UnsignedLongObjectPropertyType",
    "UsageContextAssumptionsType",
    "ValuesEnumeratedEffectType",
    "ValuesType",
    "VulnerabilityExploitType"
]
